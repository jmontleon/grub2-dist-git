diff --git a/configure.ac b/configure.ac
index edd184154f7e9aad556b6437b8ec22bc79d5a057..571f7a0b5aa4979218cb08033fe3a3e46c07f1a0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -31,7 +31,7 @@ dnl (such as BUILD_CC, BUILD_CFLAGS, etc.) for the build type and variables
 dnl with the prefix "TARGET_" (such as TARGET_CC, TARGET_CFLAGS, etc.) are
 dnl used for the target type. See INSTALL for full list of variables.
 
-AC_INIT([GRUB],[2.02],[bug-grub@gnu.org])
+AC_INIT([GRUB],[2.03],[bug-grub@gnu.org])
 
 AC_CONFIG_AUX_DIR([build-aux])
 
@@ -167,6 +167,7 @@ case "$target_cpu"-"$platform" in
   mipsel-fuloong) platform=loongson ;;
   mipsel-loongson) ;;
   arm-uboot) ;;
+  arm-coreboot) ;;
   arm-efi) ;;
   arm64-efi) ;;
   *-emu) ;;
@@ -373,7 +374,10 @@ case "$host_os" in
      ;;
   *)
      AC_CHECK_SIZEOF(off_t)
-     test x"$ac_cv_sizeof_off_t" = x8 || AC_MSG_ERROR([Large file support is required]);;
+     if test x"$ac_cv_sizeof_off_t" != x8 ; then
+       AC_CHECK_SIZEOF(off64_t)
+       test x"$ac_cv_sizeof_off64_t" = x8 || AC_MSG_ERROR([Large file support is required])
+     fi;;
 esac
 
 if test x$USE_NLS = xno; then
@@ -456,6 +460,16 @@ case "$build_os" in
 esac
 AC_SUBST(BUILD_EXEEXT)
 
+# In some build environments like termux /bin/sh is not a valid
+# shebang. Use $SHELL instead if it's executable and /bin/sh isn't
+BUILD_SHEBANG=/bin/sh
+for she in /bin/sh "$SHELL"; do
+  if test -x "$she" ; then
+    BUILD_SHEBANG="$she"
+  fi
+done
+AC_SUBST(BUILD_SHEBANG)
+
 # For gnulib.
 gl_INIT
 
@@ -1905,6 +1919,7 @@ AM_CONDITIONAL([COND_mipsel], [test x$target_cpu = xmipsel])
 AM_CONDITIONAL([COND_mipseb], [test x$target_cpu = xmips])
 AM_CONDITIONAL([COND_arm], [test x$target_cpu = xarm ])
 AM_CONDITIONAL([COND_arm_uboot], [test x$target_cpu = xarm -a x$platform = xuboot])
+AM_CONDITIONAL([COND_arm_coreboot], [test x$target_cpu = xarm -a x$platform = xcoreboot])
 AM_CONDITIONAL([COND_arm_efi], [test x$target_cpu = xarm -a x$platform = xefi])
 AM_CONDITIONAL([COND_arm64], [test x$target_cpu = xarm64 ])
 AM_CONDITIONAL([COND_arm64_efi], [test x$target_cpu = xarm64 -a x$platform = xefi])
diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index 2dfa22a9271bd6624fad9b91ce051ac12202dfbd..a65c27f7ff2252133998da52371d0e23b92f5984 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -92,6 +92,8 @@ kernel = {
   emu_cppflags = '$(CPPFLAGS_GNULIB)';
   arm_uboot_ldflags       = '-Wl,-r,-d';
   arm_uboot_stripflags    = '--strip-unneeded -K start -R .note -R .comment -R .note.gnu.gold-version';
+  arm_coreboot_ldflags       = '-Wl,-r,-d';
+  arm_coreboot_stripflags    = '--strip-unneeded -K start -R .note -R .comment -R .note.gnu.gold-version';
 
   i386_pc_startup = kern/i386/pc/startup.S;
   i386_efi_startup = kern/i386/efi/startup.S;
@@ -105,7 +107,8 @@ kernel = {
   mips_startup = kern/mips/startup.S;
   sparc64_ieee1275_startup = kern/sparc64/ieee1275/crt0.S;
   powerpc_ieee1275_startup = kern/powerpc/ieee1275/startup.S;
-  arm_uboot_startup = kern/arm/uboot/startup.S;
+  arm_uboot_startup = kern/arm/startup.S;
+  arm_coreboot_startup = kern/arm/startup.S;
   arm_efi_startup = kern/arm/efi/startup.S;
   arm64_efi_startup = kern/arm64/efi/startup.S;
 
@@ -149,6 +152,21 @@ kernel = {
   uboot = kern/uboot/init.c;
   uboot = kern/uboot/hw.c;
   uboot = term/uboot/console.c;
+  arm_uboot = kern/arm/uboot/init.c;
+  arm_uboot = kern/arm/uboot/uboot.S;
+
+  arm_coreboot = kern/arm/coreboot/init.c;
+  arm_coreboot = kern/arm/coreboot/timer.c;
+  arm_coreboot = kern/arm/coreboot/coreboot.S;
+  arm_coreboot = lib/fdt.c;
+  arm_coreboot = bus/fdt.c;
+  arm_coreboot = term/ps2.c;
+  arm_coreboot = term/arm/pl050.c;
+  arm_coreboot = term/arm/cros.c;
+  arm_coreboot = term/arm/cros_ec.c;
+  arm_coreboot = bus/spi/rk3288_spi.c;
+  arm_coreboot = commands/keylayouts.c;
+  arm_coreboot = kern/arm/coreboot/dma.c;
 
   terminfoinkernel = term/terminfo.c;
   terminfoinkernel = term/tparm.c;
@@ -164,7 +182,7 @@ kernel = {
   i386_multiboot = kern/i386/coreboot/init.c;
   i386_qemu = kern/i386/qemu/init.c;
   i386_coreboot_multiboot_qemu = term/i386/pc/vga_text.c;
-  i386_coreboot = video/i386/coreboot/cbfb.c;
+  coreboot = video/coreboot/cbfb.c;
 
   efi = disk/efi/efidisk.c;
   efi = kern/efi/efi.c;
@@ -225,8 +243,10 @@ kernel = {
   i386_qemu = kern/vga_init.c;
   i386_qemu = kern/i386/qemu/mmap.c;
 
-  i386_coreboot = kern/i386/coreboot/mmap.c;
+  coreboot = kern/coreboot/mmap.c;
   i386_coreboot = kern/i386/coreboot/cbtable.c;
+  coreboot = kern/coreboot/cbtable.c;
+  arm_coreboot = kern/arm/coreboot/cbtable.c;
 
   i386_multiboot = kern/i386/multiboot_mmap.c;
 
@@ -238,6 +258,7 @@ kernel = {
   mips_qemu_mips = term/ns8250.c;
   mips_qemu_mips = term/serial.c;
   mips_qemu_mips = term/at_keyboard.c;
+  mips_qemu_mips = term/ps2.c;
   mips_qemu_mips = commands/boot.c;
   mips_qemu_mips = commands/keylayouts.c;
   mips_qemu_mips = term/i386/pc/vga_text.c;
@@ -253,6 +274,7 @@ kernel = {
   mips_loongson = bus/pci.c;
   mips_loongson = kern/mips/loongson/init.c;
   mips_loongson = term/at_keyboard.c;
+  mips_loongson = term/ps2.c;
   mips_loongson = commands/boot.c;
   mips_loongson = term/serial.c;
   mips_loongson = video/sm712.c;
@@ -574,7 +596,10 @@ module = {
 module = {
   name = ehci;
   common = bus/usb/ehci.c;
+  arm_coreboot = bus/usb/ehci-fdt.c;
+  pci = bus/usb/ehci-pci.c;
   enable = pci;
+  enable = arm_coreboot;
 };
 
 module = {
@@ -641,6 +666,7 @@ module = {
 module = {
   name = cbtable;
   common = kern/i386/coreboot/cbtable.c;
+  common = kern/coreboot/cbtable.c;
   enable = i386_pc;
   enable = i386_efi;
   enable = i386_qemu;
@@ -754,6 +780,7 @@ module = {
   enable = arm_efi;
   enable = arm64_efi;
   enable = arm_uboot;
+  enable = arm_coreboot;
 };
 
 module = {
@@ -837,7 +864,8 @@ module = {
   efi = lib/efi/halt.c;
   ieee1275 = lib/ieee1275/halt.c;
   emu = lib/emu/halt.c;
-  uboot = lib/uboot/halt.c;
+  uboot = lib/dummy/halt.c;
+  arm_coreboot = lib/dummy/halt.c;
 };
 
 module = {
@@ -855,6 +883,7 @@ module = {
   mips_qemu_mips = lib/mips/qemu_mips/reboot.c;
   xen = lib/xen/reboot.c;
   uboot = lib/uboot/reboot.c;
+  arm_coreboot = lib/dummy/reboot.c;
   common = commands/reboot.c;
 };
 
@@ -1548,7 +1577,8 @@ module = {
   name = datetime;
   cmos = lib/cmos_datetime.c;
   efi = lib/efi/datetime.c;
-  uboot = lib/uboot/datetime.c;
+  uboot = lib/dummy/datetime.c;
+  arm_coreboot = lib/dummy/datetime.c;
   sparc64_ieee1275 = lib/ieee1275/datetime.c;
   powerpc_ieee1275 = lib/ieee1275/datetime.c;
   sparc64_ieee1275 = lib/ieee1275/cmos.c;
@@ -1677,7 +1707,7 @@ module = {
 
 module = {
   name = fdt;
-  arm64 = loader/arm64/fdt.c;
+  arm64 = loader/efi/fdt.c;
   common = lib/fdt.c;
   enable = fdt;
 };
@@ -1869,6 +1899,7 @@ module = {
 module = {
   name = at_keyboard;
   common = term/at_keyboard.c;
+  common = term/ps2.c;
   enable = x86;
 };
 
@@ -1961,6 +1992,11 @@ module = {
   common = tests/example_functional_test.c;
 };
 
+module = {
+  name = strtoull_test;
+  common = tests/strtoull_test.c;
+};
+
 module = {
   name = setjmp_test;
   common = tests/setjmp_test.c;
diff --git a/grub-core/bus/fdt.c b/grub-core/bus/fdt.c
new file mode 100644
index 0000000000000000000000000000000000000000..135da497ba67e7545490e0e73ee3a1fa676a6069
--- /dev/null
+++ b/grub-core/bus/fdt.c
@@ -0,0 +1,256 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2016  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/fdtbus.h>
+#include <grub/fdt.h>
+#include <grub/term.h>
+
+static const void *dtb;
+static grub_size_t root_address_cells, root_size_cells;
+/* Pointer to this symbol signals invalid mapping.  */
+char grub_fdtbus_invalid_mapping[1];
+
+struct grub_fdtbus_dev *devs;
+struct grub_fdtbus_driver *drivers;
+
+int
+grub_fdtbus_is_compatible (const char *compat_string,
+			   const struct grub_fdtbus_dev *dev)
+{
+  grub_size_t compatible_size;
+  const char *compatible = grub_fdt_get_prop (dtb, dev->node, "compatible",
+					      &compatible_size);
+  if (!compatible)
+    return 0;
+  const char *compatible_end = compatible + compatible_size;
+  while (compatible < compatible_end)
+    {
+      if (grub_strcmp (compat_string, compatible) == 0)
+	return 1;
+      compatible += grub_strlen (compatible) + 1;
+    }
+  return 0;
+}
+
+static void
+fdtbus_scan (struct grub_fdtbus_dev *parent)
+{
+  int node;
+  for (node = grub_fdt_first_node (dtb, parent ? parent->node : 0); node >= 0;
+       node = grub_fdt_next_node (dtb, node))
+    {
+      struct grub_fdtbus_dev *dev;
+      struct grub_fdtbus_driver *driver;
+      dev = grub_zalloc (sizeof (*dev));
+      if (!dev)
+	{
+	  grub_print_error ();
+	  return;
+	}
+      dev->node = node;
+      dev->next = devs;
+      dev->parent = parent;
+      devs = dev;
+      FOR_LIST_ELEMENTS(driver, drivers)
+	if (!dev->driver && grub_fdtbus_is_compatible (driver->compatible, dev))
+	  {
+	    grub_dprintf ("fdtbus", "Attaching %s\n", driver->compatible);
+	    if (driver->attach (dev) == GRUB_ERR_NONE)
+	      {
+		grub_dprintf ("fdtbus", "Attached %s\n", driver->compatible);
+		dev->driver = driver;
+		break;
+	      }
+	    grub_print_error ();
+	  }
+      fdtbus_scan (dev);
+    }
+}
+
+void
+grub_fdtbus_register (struct grub_fdtbus_driver *driver)
+{
+  struct grub_fdtbus_dev *dev;
+  grub_dprintf ("fdtbus", "Registering %s\n", driver->compatible);
+  grub_list_push (GRUB_AS_LIST_P (&drivers),
+		  GRUB_AS_LIST (driver));
+  for (dev = devs; dev; dev = dev->next)
+    if (!dev->driver && grub_fdtbus_is_compatible (driver->compatible, dev))
+      {
+	grub_dprintf ("fdtbus", "Attaching %s (%p)\n", driver->compatible, dev);
+	if (driver->attach (dev) == GRUB_ERR_NONE)
+	  {
+	    grub_dprintf ("fdtbus", "Attached %s\n", driver->compatible);
+	    dev->driver = driver;
+	  }
+	grub_print_error ();
+      }
+}
+
+void
+grub_fdtbus_unregister (struct grub_fdtbus_driver *driver)
+{
+  grub_list_remove (GRUB_AS_LIST (driver));
+  struct grub_fdtbus_dev *dev;
+  for (dev = devs; dev; dev = dev->next)
+    if (dev->driver == driver)
+      {
+	if (driver->detach)
+	  driver->detach(dev);
+	dev->driver = 0;
+      }
+}
+
+void
+grub_fdtbus_init (const void *dtb_in, grub_size_t size)
+{
+  if (!dtb_in || grub_fdt_check_header (dtb_in, size) < 0)
+    grub_fatal ("invalid FDT");
+  dtb = dtb_in;
+  const grub_uint32_t *prop = grub_fdt_get_prop (dtb, 0, "#address-cells", 0);
+  if (prop)
+    root_address_cells = grub_be_to_cpu32 (*prop);
+  else
+    root_address_cells = 1;
+
+  prop = grub_fdt_get_prop (dtb, 0, "#size-cells", 0);
+  if (prop)
+    root_size_cells = grub_be_to_cpu32 (*prop);
+  else
+    root_size_cells = 1;
+
+  fdtbus_scan (0);
+}
+
+static int
+get_address_cells (const struct grub_fdtbus_dev *dev)
+{
+  const grub_uint32_t *prop;
+  if (!dev)
+    return root_address_cells;
+  prop = grub_fdt_get_prop (dtb, dev->node, "#address-cells", 0);
+  if (prop)
+    return grub_be_to_cpu32 (*prop);
+  return 1;
+}
+
+static int
+get_size_cells (const struct grub_fdtbus_dev *dev)
+{
+  const grub_uint32_t *prop;
+  if (!dev)
+    return root_size_cells;
+  prop = grub_fdt_get_prop (dtb, dev->node, "#size-cells", 0);
+  if (prop)
+    return grub_be_to_cpu32 (*prop);
+  return 1;
+}
+
+static grub_uint64_t
+get64 (const grub_uint32_t *reg, grub_size_t cells)
+{
+  grub_uint64_t val = 0;
+  if (cells >= 1)
+    val = grub_be_to_cpu32 (reg[cells - 1]);
+  if (cells >= 2)
+    val |= ((grub_uint64_t) grub_be_to_cpu32 (reg[cells - 2])) << 32;
+  return val;
+}
+
+static volatile void *
+translate (const struct grub_fdtbus_dev *dev, const grub_uint32_t *reg)
+{
+  volatile void *ret;
+  const grub_uint32_t *ranges;
+  grub_size_t ranges_size, cells_per_mapping;
+  grub_size_t parent_address_cells, child_address_cells, child_size_cells;
+  grub_size_t nmappings, i;
+  if (dev == 0)
+    {
+      grub_uint64_t val;
+      val = get64 (reg, root_address_cells);
+      if (sizeof (void *) == 4 && (val >> 32))
+	return grub_fdtbus_invalid_mapping;
+      return (void *) (grub_addr_t) val;
+    }
+  ranges = grub_fdt_get_prop (dtb, dev->node, "ranges", &ranges_size);
+  if (!ranges)
+    return grub_fdtbus_invalid_mapping;
+  if (ranges_size == 0)
+    return translate (dev->parent, reg);
+  parent_address_cells = get_address_cells (dev->parent);
+  child_address_cells = get_address_cells (dev);
+  child_size_cells = get_size_cells (dev);
+  cells_per_mapping = parent_address_cells + child_address_cells + child_size_cells;
+  nmappings = ranges_size / 4 / cells_per_mapping;
+  for (i = 0; i < nmappings; i++)
+    {
+      const grub_uint32_t *child_addr = &ranges[i * cells_per_mapping];
+      const grub_uint32_t *parent_addr = child_addr + child_address_cells;
+      grub_uint64_t child_size = get64 (parent_addr + parent_address_cells, child_size_cells);
+
+      if (child_address_cells > 2 && grub_memcmp (reg, child_addr, (child_address_cells - 2) * 4) != 0)
+	continue;
+      if (get64 (reg, child_address_cells) < get64 (child_addr, child_address_cells))
+	continue;
+
+      grub_uint64_t offset = get64 (reg, child_address_cells) - get64 (child_addr, child_address_cells);
+      if (offset >= child_size)
+	continue;
+
+      ret = translate (dev->parent, parent_addr);
+      if (grub_fdtbus_is_mapping_valid (ret))
+	ret = (volatile char *) ret + offset;
+      return ret;
+    }
+  return grub_fdtbus_invalid_mapping;
+}
+
+volatile void *
+grub_fdtbus_map_reg (const struct grub_fdtbus_dev *dev, int regno, grub_size_t *size)
+{
+  grub_size_t address_cells, size_cells;
+  address_cells = get_address_cells (dev->parent);
+  size_cells = get_size_cells (dev->parent);
+  const grub_uint32_t *reg = grub_fdt_get_prop (dtb, dev->node, "reg", 0);
+  if (size && size_cells)
+    *size = reg[(address_cells + size_cells) * regno + address_cells];
+  if (size && !size_cells)
+    *size = 0;
+  return translate (dev->parent, reg + (address_cells + size_cells) * regno);
+}
+
+const char *
+grub_fdtbus_get_name (const struct grub_fdtbus_dev *dev)
+{
+  return grub_fdt_get_nodename (dtb, dev->node);
+}
+
+const void *
+grub_fdtbus_get_prop (const struct grub_fdtbus_dev *dev,
+		      const char *name,
+		      grub_uint32_t *len)
+{
+  return grub_fdt_get_prop (dtb, dev->node, name, len);
+}
+
+const void *
+grub_fdtbus_get_fdt (void)
+{
+  return dtb;
+}
diff --git a/grub-core/bus/spi/rk3288_spi.c b/grub-core/bus/spi/rk3288_spi.c
new file mode 100644
index 0000000000000000000000000000000000000000..aacb79ffef103bdbff1bb66dd70229b85b1e8030
--- /dev/null
+++ b/grub-core/bus/spi/rk3288_spi.c
@@ -0,0 +1,103 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *
+ *  Copyright (C) 2012  Google Inc.
+ *  Copyright (C) 2016  Free Software Foundation, Inc.
+ *
+ *  This is based on depthcharge code.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/mm.h>
+#include <grub/time.h>
+#include <grub/misc.h>
+#include <grub/fdtbus.h>
+#include <grub/machine/kernel.h>
+
+static grub_err_t
+spi_send (const struct grub_fdtbus_dev *dev, const void *data, grub_size_t sz)
+{
+  const grub_uint8_t *ptr = data, *end = ptr + sz;
+  volatile grub_uint32_t *spi = grub_fdtbus_map_reg (dev, 0, 0);
+  spi[2] = 0;
+  spi[1] = sz - 1;
+  spi[0] = ((1 << 18) | spi[0]) & ~(1 << 19);
+  spi[2] = 1;
+  while (ptr < end)
+    {
+      while (spi[9] & 2);
+      spi[256] = *ptr++;
+    }
+  while (spi[9] & 1);
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+spi_receive (const struct grub_fdtbus_dev *dev, void *data, grub_size_t sz)
+{
+  grub_uint8_t *ptr = data, *end = ptr + sz;
+  volatile grub_uint32_t *spi = grub_fdtbus_map_reg (dev, 0, 0);
+  spi[2] = 0;
+  spi[1] = sz - 1;
+  spi[0] = ((1 << 19) | spi[0]) & ~(1 << 18);
+  spi[2] = 1;
+  while (ptr < end)
+    {
+      while (spi[9] & 8);
+      *ptr++ = spi[512];
+    }
+  while (spi[9] & 1);
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+spi_start (const struct grub_fdtbus_dev *dev)
+{
+  volatile grub_uint32_t *spi = grub_fdtbus_map_reg (dev, 0, 0);
+  spi[3] = 1;
+  return GRUB_ERR_NONE;
+}
+
+static void
+spi_stop (const struct grub_fdtbus_dev *dev)
+{
+  volatile grub_uint32_t *spi = grub_fdtbus_map_reg (dev, 0, 0);
+  spi[3] = 0;
+}
+
+static grub_err_t
+spi_attach(const struct grub_fdtbus_dev *dev)
+{
+  if (!grub_fdtbus_is_mapping_valid (grub_fdtbus_map_reg (dev, 0, 0)))
+    return GRUB_ERR_IO;
+
+  return GRUB_ERR_NONE;
+}
+
+static struct grub_fdtbus_driver spi =
+{
+  .compatible = "rockchip,rk3288-spi",
+  .attach = spi_attach,
+  .send = spi_send,
+  .receive = spi_receive,
+  .start = spi_start,
+  .stop = spi_stop,
+};
+
+void
+grub_rk3288_spi_init (void)
+{
+  grub_fdtbus_register (&spi);
+}
diff --git a/grub-core/bus/usb/ehci-fdt.c b/grub-core/bus/usb/ehci-fdt.c
new file mode 100644
index 0000000000000000000000000000000000000000..29b50bdd5c30d192cc3cba1d7f466a9bcf321d92
--- /dev/null
+++ b/grub-core/bus/usb/ehci-fdt.c
@@ -0,0 +1,45 @@
+/* ehci.c - EHCI Support.  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2011  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/misc.h>
+#include <grub/mm.h>
+#include <grub/time.h>
+#include <grub/usb.h>
+#include <grub/fdtbus.h>
+
+static grub_err_t
+ehci_attach(const struct grub_fdtbus_dev *dev)
+{
+  grub_dprintf ("ehci", "Found generic-ehci\n");
+
+  grub_ehci_init_device (grub_fdtbus_map_reg (dev, 0, 0));
+  return 0;
+}
+
+struct grub_fdtbus_driver ehci =
+{
+  .compatible = "generic-ehci",
+  .attach = ehci_attach
+};
+
+void
+grub_ehci_pci_scan (void)
+{
+  grub_fdtbus_register (&ehci);
+}
diff --git a/grub-core/bus/usb/ehci-pci.c b/grub-core/bus/usb/ehci-pci.c
new file mode 100644
index 0000000000000000000000000000000000000000..65e6cb57438b7dfa35b80bbbe36a1e50629f025f
--- /dev/null
+++ b/grub-core/bus/usb/ehci-pci.c
@@ -0,0 +1,208 @@
+/* ehci.c - EHCI Support.  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2011  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/pci.h>
+#include <grub/cpu/pci.h>
+#include <grub/cs5536.h>
+#include <grub/misc.h>
+#include <grub/mm.h>
+#include <grub/time.h>
+#include <grub/usb.h>
+
+#define GRUB_EHCI_PCI_SBRN_REG  0x60
+#define GRUB_EHCI_ADDR_MEM_MASK	(~0xff)
+
+/* USBLEGSUP bits and related OS OWNED byte offset */
+enum
+{
+  GRUB_EHCI_BIOS_OWNED = (1 << 16),
+  GRUB_EHCI_OS_OWNED = (1 << 24)
+};
+
+/* PCI iteration function... */
+static int
+grub_ehci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
+		    void *data __attribute__ ((unused)))
+{
+  volatile grub_uint32_t *regs;
+  grub_uint32_t base, base_h;
+  grub_uint32_t eecp_offset;
+  grub_uint32_t usblegsup = 0;
+  grub_uint64_t maxtime;
+  grub_uint32_t interf;
+  grub_uint32_t subclass;
+  grub_uint32_t class;
+  grub_uint8_t release;
+  grub_uint32_t class_code;
+
+  grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: begin\n");
+
+  if (pciid == GRUB_CS5536_PCIID)
+    {
+      grub_uint64_t basereg;
+
+      basereg = grub_cs5536_read_msr (dev, GRUB_CS5536_MSR_USB_EHCI_BASE);
+      if (!(basereg & GRUB_CS5536_MSR_USB_BASE_MEMORY_ENABLE))
+	{
+	  /* Shouldn't happen.  */
+	  grub_dprintf ("ehci", "No EHCI address is assigned\n");
+	  return 0;
+	}
+      base = (basereg & GRUB_CS5536_MSR_USB_BASE_ADDR_MASK);
+      basereg |= GRUB_CS5536_MSR_USB_BASE_BUS_MASTER;
+      basereg &= ~GRUB_CS5536_MSR_USB_BASE_PME_ENABLED;
+      basereg &= ~GRUB_CS5536_MSR_USB_BASE_PME_STATUS;
+      basereg &= ~GRUB_CS5536_MSR_USB_BASE_SMI_ENABLE;
+      grub_cs5536_write_msr (dev, GRUB_CS5536_MSR_USB_EHCI_BASE, basereg);
+    }
+  else
+    {
+      grub_pci_address_t addr;
+      addr = grub_pci_make_address (dev, GRUB_PCI_REG_CLASS);
+      class_code = grub_pci_read (addr) >> 8;
+      interf = class_code & 0xFF;
+      subclass = (class_code >> 8) & 0xFF;
+      class = class_code >> 16;
+
+      /* If this is not an EHCI controller, just return.  */
+      if (class != 0x0c || subclass != 0x03 || interf != 0x20)
+	return 0;
+
+      grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: class OK\n");
+
+      /* Check Serial Bus Release Number */
+      addr = grub_pci_make_address (dev, GRUB_EHCI_PCI_SBRN_REG);
+      release = grub_pci_read_byte (addr);
+      if (release != 0x20)
+	{
+	  grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: Wrong SBRN: %0x\n",
+			release);
+	  return 0;
+	}
+      grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: bus rev. num. OK\n");
+  
+      /* Determine EHCI EHCC registers base address.  */
+      addr = grub_pci_make_address (dev, GRUB_PCI_REG_ADDRESS_REG0);
+      base = grub_pci_read (addr);
+      addr = grub_pci_make_address (dev, GRUB_PCI_REG_ADDRESS_REG1);
+      base_h = grub_pci_read (addr);
+      /* Stop if registers are mapped above 4G - GRUB does not currently
+       * work with registers mapped above 4G */
+      if (((base & GRUB_PCI_ADDR_MEM_TYPE_MASK) != GRUB_PCI_ADDR_MEM_TYPE_32)
+	  && (base_h != 0))
+	{
+	  grub_dprintf ("ehci",
+			"EHCI grub_ehci_pci_iter: registers above 4G are not supported\n");
+	  return 0;
+	}
+      base &= GRUB_PCI_ADDR_MEM_MASK;
+      if (!base)
+	{
+	  grub_dprintf ("ehci",
+			"EHCI: EHCI is not mapped\n");
+	  return 0;
+	}
+
+      /* Set bus master - needed for coreboot, VMware, broken BIOSes etc. */
+      addr = grub_pci_make_address (dev, GRUB_PCI_REG_COMMAND);
+      grub_pci_write_word(addr,
+			  GRUB_PCI_COMMAND_MEM_ENABLED
+			  | GRUB_PCI_COMMAND_BUS_MASTER
+			  | grub_pci_read_word(addr));
+      
+      grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: 32-bit EHCI OK\n");
+    }
+
+  grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: iobase of EHCC: %08x\n",
+		(base & GRUB_EHCI_ADDR_MEM_MASK));
+
+  regs = grub_pci_device_map_range (dev,
+				    (base & GRUB_EHCI_ADDR_MEM_MASK),
+				    0x100);
+
+  /* Is there EECP ? */
+  eecp_offset = (grub_le_to_cpu32 (regs[2]) >> 8) & 0xff;
+
+    /* Determine and change ownership. */
+  /* EECP offset valid in HCCPARAMS */
+  /* Ownership can be changed via EECP only */
+  if (pciid != GRUB_CS5536_PCIID && eecp_offset >= 0x40)	
+    {
+      grub_pci_address_t pciaddr_eecp;
+      pciaddr_eecp = grub_pci_make_address (dev, eecp_offset);
+
+      usblegsup = grub_pci_read (pciaddr_eecp);
+      if (usblegsup & GRUB_EHCI_BIOS_OWNED)
+	{
+	  grub_boot_time ("Taking ownership of EHCI controller");
+	  grub_dprintf ("ehci",
+			"EHCI grub_ehci_pci_iter: EHCI owned by: BIOS\n");
+	  /* Ownership change - set OS_OWNED bit */
+	  grub_pci_write (pciaddr_eecp, usblegsup | GRUB_EHCI_OS_OWNED);
+	  /* Ensure PCI register is written */
+	  grub_pci_read (pciaddr_eecp);
+
+	  /* Wait for finish of ownership change, EHCI specification
+	   * doesn't say how long it can take... */
+	  maxtime = grub_get_time_ms () + 1000;
+	  while ((grub_pci_read (pciaddr_eecp) & GRUB_EHCI_BIOS_OWNED)
+		 && (grub_get_time_ms () < maxtime));
+	  if (grub_pci_read (pciaddr_eecp) & GRUB_EHCI_BIOS_OWNED)
+	    {
+	      grub_dprintf ("ehci",
+			    "EHCI grub_ehci_pci_iter: EHCI change ownership timeout");
+	      /* Change ownership in "hard way" - reset BIOS ownership */
+	      grub_pci_write (pciaddr_eecp, GRUB_EHCI_OS_OWNED);
+	      /* Ensure PCI register is written */
+	      grub_pci_read (pciaddr_eecp);
+	    }
+	}
+      else if (usblegsup & GRUB_EHCI_OS_OWNED)
+	/* XXX: What to do in this case - nothing ? Can it happen ? */
+	grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: EHCI owned by: OS\n");
+      else
+	{
+	  grub_dprintf ("ehci",
+			"EHCI grub_ehci_pci_iter: EHCI owned by: NONE\n");
+	  /* XXX: What to do in this case ? Can it happen ?
+	   * Is code below correct ? */
+	  /* Ownership change - set OS_OWNED bit */
+	  grub_pci_write (pciaddr_eecp, GRUB_EHCI_OS_OWNED);
+	  /* Ensure PCI register is written */
+	  grub_pci_read (pciaddr_eecp);
+	}
+
+      /* Disable SMI, just to be sure.  */
+      pciaddr_eecp = grub_pci_make_address (dev, eecp_offset + 4);
+      grub_pci_write (pciaddr_eecp, 0);
+      /* Ensure PCI register is written */
+      grub_pci_read (pciaddr_eecp);
+    }
+
+  grub_dprintf ("ehci", "inithw: EHCI grub_ehci_pci_iter: ownership OK\n");
+
+  grub_ehci_init_device (regs);
+  return 0;
+}
+
+void
+grub_ehci_pci_scan (void)
+{
+  grub_pci_iterate (grub_ehci_pci_iter, NULL);
+}
diff --git a/grub-core/bus/usb/ehci.c b/grub-core/bus/usb/ehci.c
index 5f4297bb21ec4c28824abb0c442a87a3dd4a872e..d966fc21002602fab3f1b68668ddcb5bfa639442 100644
--- a/grub-core/bus/usb/ehci.c
+++ b/grub-core/bus/usb/ehci.c
@@ -22,13 +22,10 @@
 #include <grub/usb.h>
 #include <grub/usbtrans.h>
 #include <grub/misc.h>
-#include <grub/pci.h>
-#include <grub/cpu/pci.h>
-#include <grub/cpu/io.h>
 #include <grub/time.h>
 #include <grub/loader.h>
-#include <grub/cs5536.h>
 #include <grub/disk.h>
+#include <grub/dma.h>
 #include <grub/cache.h>
 
 GRUB_MOD_LICENSE ("GPLv3+");
@@ -39,8 +36,6 @@ GRUB_MOD_LICENSE ("GPLv3+");
  *      - is not supporting interrupt transfers
  */
 
-#define GRUB_EHCI_PCI_SBRN_REG  0x60
-
 /* Capability registers offsets */
 enum
 {
@@ -54,7 +49,6 @@ enum
 #define GRUB_EHCI_EECP_MASK     (0xff << 8)
 #define GRUB_EHCI_EECP_SHIFT    8
 
-#define GRUB_EHCI_ADDR_MEM_MASK	(~0xff)
 #define GRUB_EHCI_POINTER_MASK	(~0x1f)
 
 /* Capability register SPARAMS bits */
@@ -85,13 +79,6 @@ enum
 
 #define GRUB_EHCI_QH_EMPTY 1
 
-/* USBLEGSUP bits and related OS OWNED byte offset */
-enum
-{
-  GRUB_EHCI_BIOS_OWNED = (1 << 16),
-  GRUB_EHCI_OS_OWNED = (1 << 24)
-};
-
 /* Operational registers offsets */
 enum
 {
@@ -455,9 +442,10 @@ grub_ehci_reset (struct grub_ehci *e)
 
   sync_all_caches (e);
 
+  grub_dprintf ("ehci", "reset\n");
+
   grub_ehci_oper_write32 (e, GRUB_EHCI_COMMAND,
-			  GRUB_EHCI_CMD_HC_RESET
-			  | grub_ehci_oper_read32 (e, GRUB_EHCI_COMMAND));
+			  GRUB_EHCI_CMD_HC_RESET);
   /* Ensure command is written */
   grub_ehci_oper_read32 (e, GRUB_EHCI_COMMAND);
   /* XXX: How long time could take reset of HC ? */
@@ -473,116 +461,24 @@ grub_ehci_reset (struct grub_ehci *e)
 }
 
 /* PCI iteration function... */
-static int
-grub_ehci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
-		    void *data __attribute__ ((unused)))
+void
+grub_ehci_init_device (volatile void *regs)
 {
-  grub_uint8_t release;
-  grub_uint32_t class_code;
-  grub_uint32_t interf;
-  grub_uint32_t subclass;
-  grub_uint32_t class;
-  grub_uint32_t base, base_h;
   struct grub_ehci *e;
-  grub_uint32_t eecp_offset;
   grub_uint32_t fp;
   int i;
-  grub_uint32_t usblegsup = 0;
-  grub_uint64_t maxtime;
   grub_uint32_t n_ports;
   grub_uint8_t caplen;
 
-  grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: begin\n");
-
-  if (pciid == GRUB_CS5536_PCIID)
-    {
-      grub_uint64_t basereg;
-
-      basereg = grub_cs5536_read_msr (dev, GRUB_CS5536_MSR_USB_EHCI_BASE);
-      if (!(basereg & GRUB_CS5536_MSR_USB_BASE_MEMORY_ENABLE))
-	{
-	  /* Shouldn't happen.  */
-	  grub_dprintf ("ehci", "No EHCI address is assigned\n");
-	  return 0;
-	}
-      base = (basereg & GRUB_CS5536_MSR_USB_BASE_ADDR_MASK);
-      basereg |= GRUB_CS5536_MSR_USB_BASE_BUS_MASTER;
-      basereg &= ~GRUB_CS5536_MSR_USB_BASE_PME_ENABLED;
-      basereg &= ~GRUB_CS5536_MSR_USB_BASE_PME_STATUS;
-      basereg &= ~GRUB_CS5536_MSR_USB_BASE_SMI_ENABLE;
-      grub_cs5536_write_msr (dev, GRUB_CS5536_MSR_USB_EHCI_BASE, basereg);
-    }
-  else
-    {
-      grub_pci_address_t addr;
-      addr = grub_pci_make_address (dev, GRUB_PCI_REG_CLASS);
-      class_code = grub_pci_read (addr) >> 8;
-      interf = class_code & 0xFF;
-      subclass = (class_code >> 8) & 0xFF;
-      class = class_code >> 16;
-
-      /* If this is not an EHCI controller, just return.  */
-      if (class != 0x0c || subclass != 0x03 || interf != 0x20)
-	return 0;
-
-      grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: class OK\n");
-
-      /* Check Serial Bus Release Number */
-      addr = grub_pci_make_address (dev, GRUB_EHCI_PCI_SBRN_REG);
-      release = grub_pci_read_byte (addr);
-      if (release != 0x20)
-	{
-	  grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: Wrong SBRN: %0x\n",
-			release);
-	  return 0;
-	}
-      grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: bus rev. num. OK\n");
-  
-      /* Determine EHCI EHCC registers base address.  */
-      addr = grub_pci_make_address (dev, GRUB_PCI_REG_ADDRESS_REG0);
-      base = grub_pci_read (addr);
-      addr = grub_pci_make_address (dev, GRUB_PCI_REG_ADDRESS_REG1);
-      base_h = grub_pci_read (addr);
-      /* Stop if registers are mapped above 4G - GRUB does not currently
-       * work with registers mapped above 4G */
-      if (((base & GRUB_PCI_ADDR_MEM_TYPE_MASK) != GRUB_PCI_ADDR_MEM_TYPE_32)
-	  && (base_h != 0))
-	{
-	  grub_dprintf ("ehci",
-			"EHCI grub_ehci_pci_iter: registers above 4G are not supported\n");
-	  return 0;
-	}
-      base &= GRUB_PCI_ADDR_MEM_MASK;
-      if (!base)
-	{
-	  grub_dprintf ("ehci",
-			"EHCI: EHCI is not mapped\n");
-	  return 0;
-	}
-
-      /* Set bus master - needed for coreboot, VMware, broken BIOSes etc. */
-      addr = grub_pci_make_address (dev, GRUB_PCI_REG_COMMAND);
-      grub_pci_write_word(addr,
-			  GRUB_PCI_COMMAND_MEM_ENABLED
-			  | GRUB_PCI_COMMAND_BUS_MASTER
-			  | grub_pci_read_word(addr));
-      
-      grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: 32-bit EHCI OK\n");
-    }
-
   /* Allocate memory for the controller and fill basic values. */
   e = grub_zalloc (sizeof (*e));
   if (!e)
-    return 1;
+    return;
   e->framelist_chunk = NULL;
   e->td_chunk = NULL;
   e->qh_chunk = NULL;
-  e->iobase_ehcc = grub_pci_device_map_range (dev,
-					      (base & GRUB_EHCI_ADDR_MEM_MASK),
-					      0x100);
+  e->iobase_ehcc = regs;
 
-  grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: iobase of EHCC: %08x\n",
-		(base & GRUB_EHCI_ADDR_MEM_MASK));
   grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: CAPLEN: %02x\n",
 		grub_ehci_ehcc_read8 (e, GRUB_EHCI_EHCC_CAPLEN));
   grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: VERSION: %04x\n",
@@ -598,7 +494,7 @@ grub_ehci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
   if (caplen & (sizeof (grub_uint32_t) - 1))
     {
       grub_dprintf ("ehci", "Unaligned caplen\n");
-      return 0;
+      return;
     }
   e->iobase = ((volatile grub_uint32_t *) e->iobase_ehcc
 	       + (caplen / sizeof (grub_uint32_t)));
@@ -608,8 +504,8 @@ grub_ehci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
 #endif
 
   grub_dprintf ("ehci",
-		"EHCI grub_ehci_pci_iter: iobase of oper. regs: %08x\n",
-		(base & GRUB_EHCI_ADDR_MEM_MASK) + caplen);
+		"EHCI grub_ehci_pci_iter: iobase of oper. regs: %08llxx\n",
+		(unsigned long long) (grub_addr_t) e->iobase_ehcc + caplen);
   grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: COMMAND: %08x\n",
 		grub_ehci_oper_read32 (e, GRUB_EHCI_COMMAND));
   grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: STATUS: %08x\n",
@@ -625,10 +521,6 @@ grub_ehci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
   grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: CONFIG_FLAG: %08x\n",
 		grub_ehci_oper_read32 (e, GRUB_EHCI_CONFIG_FLAG));
 
-  /* Is there EECP ? */
-  eecp_offset = (grub_ehci_ehcc_read32 (e, GRUB_EHCI_EHCC_CPARAMS)
-		 & GRUB_EHCI_EECP_MASK) >> GRUB_EHCI_EECP_SHIFT;
-
   /* Check format of data structures requested by EHCI */
   /* XXX: In fact it is not used at any place, it is prepared for future
    * This implementation uses 32-bits pointers only */
@@ -732,65 +624,6 @@ grub_ehci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
 
   grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: QH/TD init. OK\n");
 
-  /* Determine and change ownership. */
-  /* EECP offset valid in HCCPARAMS */
-  /* Ownership can be changed via EECP only */
-  if (pciid != GRUB_CS5536_PCIID && eecp_offset >= 0x40)	
-    {
-      grub_pci_address_t pciaddr_eecp;
-      pciaddr_eecp = grub_pci_make_address (dev, eecp_offset);
-
-      usblegsup = grub_pci_read (pciaddr_eecp);
-      if (usblegsup & GRUB_EHCI_BIOS_OWNED)
-	{
-	  grub_boot_time ("Taking ownership of EHCI controller");
-	  grub_dprintf ("ehci",
-			"EHCI grub_ehci_pci_iter: EHCI owned by: BIOS\n");
-	  /* Ownership change - set OS_OWNED bit */
-	  grub_pci_write (pciaddr_eecp, usblegsup | GRUB_EHCI_OS_OWNED);
-	  /* Ensure PCI register is written */
-	  grub_pci_read (pciaddr_eecp);
-
-	  /* Wait for finish of ownership change, EHCI specification
-	   * doesn't say how long it can take... */
-	  maxtime = grub_get_time_ms () + 1000;
-	  while ((grub_pci_read (pciaddr_eecp) & GRUB_EHCI_BIOS_OWNED)
-		 && (grub_get_time_ms () < maxtime));
-	  if (grub_pci_read (pciaddr_eecp) & GRUB_EHCI_BIOS_OWNED)
-	    {
-	      grub_dprintf ("ehci",
-			    "EHCI grub_ehci_pci_iter: EHCI change ownership timeout");
-	      /* Change ownership in "hard way" - reset BIOS ownership */
-	      grub_pci_write (pciaddr_eecp, GRUB_EHCI_OS_OWNED);
-	      /* Ensure PCI register is written */
-	      grub_pci_read (pciaddr_eecp);
-	    }
-	}
-      else if (usblegsup & GRUB_EHCI_OS_OWNED)
-	/* XXX: What to do in this case - nothing ? Can it happen ? */
-	grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: EHCI owned by: OS\n");
-      else
-	{
-	  grub_dprintf ("ehci",
-			"EHCI grub_ehci_pci_iter: EHCI owned by: NONE\n");
-	  /* XXX: What to do in this case ? Can it happen ?
-	   * Is code below correct ? */
-	  /* Ownership change - set OS_OWNED bit */
-	  grub_pci_write (pciaddr_eecp, GRUB_EHCI_OS_OWNED);
-	  /* Ensure PCI register is written */
-	  grub_pci_read (pciaddr_eecp);
-	}
-
-    /* Disable SMI, just to be sure.  */
-    pciaddr_eecp = grub_pci_make_address (dev, eecp_offset + 4);
-    grub_pci_write (pciaddr_eecp, 0);
-    /* Ensure PCI register is written */
-    grub_pci_read (pciaddr_eecp);
-
-    }
-
-  grub_dprintf ("ehci", "inithw: EHCI grub_ehci_pci_iter: ownership OK\n");
-
   /* Now we can setup EHCI (maybe...) */
 
   /* Check if EHCI is halted and halt it if not */
@@ -863,8 +696,8 @@ grub_ehci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
   grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: OK at all\n");
 
   grub_dprintf ("ehci",
-		"EHCI grub_ehci_pci_iter: iobase of oper. regs: %08x\n",
-		(base & GRUB_EHCI_ADDR_MEM_MASK));
+		"EHCI grub_ehci_pci_iter: iobase of oper. regs: %08llx\n",
+		(unsigned long long) (grub_addr_t) regs);
   grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: COMMAND: %08x\n",
 		grub_ehci_oper_read32 (e, GRUB_EHCI_COMMAND));
   grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: STATUS: %08x\n",
@@ -880,7 +713,7 @@ grub_ehci_pci_iter (grub_pci_device_t dev, grub_pci_id_t pciid,
   grub_dprintf ("ehci", "EHCI grub_ehci_pci_iter: CONFIG_FLAG: %08x\n",
 		grub_ehci_oper_read32 (e, GRUB_EHCI_CONFIG_FLAG));
 
-  return 0;
+  return;
 
 fail:
   if (e)
@@ -894,7 +727,7 @@ fail:
     }
   grub_free (e);
 
-  return 0;
+  return;
 }
 
 static int
@@ -1891,12 +1724,6 @@ grub_ehci_detect_dev (grub_usb_controller_t dev, int port, int *changed)
     }
 }
 
-static void
-grub_ehci_inithw (void)
-{
-  grub_pci_iterate (grub_ehci_pci_iter, NULL);
-}
-
 static grub_err_t
 grub_ehci_restore_hw (void)
 {
@@ -1997,7 +1824,7 @@ GRUB_MOD_INIT (ehci)
   grub_stop_disk_firmware ();
 
   grub_boot_time ("Initing EHCI hardware");
-  grub_ehci_inithw ();
+  grub_ehci_pci_scan ();
   grub_boot_time ("Registering EHCI driver");
   grub_usb_controller_dev_register (&usb_controller);
   grub_boot_time ("EHCI driver registered");
diff --git a/grub-core/bus/usb/usbtrans.c b/grub-core/bus/usb/usbtrans.c
index 9266e49311c4471d0915aebf9fae05509d0fa5c7..85f081fffb3a2aa7354816c79977ae45a79b1c80 100644
--- a/grub-core/bus/usb/usbtrans.c
+++ b/grub-core/bus/usb/usbtrans.c
@@ -18,7 +18,7 @@
  */
 
 #include <grub/dl.h>
-#include <grub/pci.h>
+#include <grub/dma.h>
 #include <grub/mm.h>
 #include <grub/misc.h>
 #include <grub/usb.h>
diff --git a/grub-core/commands/efi/lsefi.c b/grub-core/commands/efi/lsefi.c
index d901c3892630f2500eda9822c712aae278017907..d1ce99af438914692d1b71b0017050689dd73db9 100644
--- a/grub-core/commands/efi/lsefi.c
+++ b/grub-core/commands/efi/lsefi.c
@@ -109,8 +109,10 @@ grub_cmd_lsefi (grub_command_t cmd __attribute__ ((unused)),
 
       status = efi_call_3 (grub_efi_system_table->boot_services->protocols_per_handle,
 			   handle, &protocols, &num_protocols);
-      if (status != GRUB_EFI_SUCCESS)
+      if (status != GRUB_EFI_SUCCESS) {
 	grub_printf ("Unable to retrieve protocols\n");
+	continue;
+      }
       for (j = 0; j < num_protocols; j++)
 	{
 	  for (k = 0; k < ARRAY_SIZE (known_protocols); k++)
diff --git a/grub-core/commands/i386/coreboot/cb_timestamps.c b/grub-core/commands/i386/coreboot/cb_timestamps.c
index e72f38d6e057dccfb981d6bbc483d2bdd8a06c98..e97ea6bed98b42d4f03f06ab5bc076fadbfee67f 100644
--- a/grub-core/commands/i386/coreboot/cb_timestamps.c
+++ b/grub-core/commands/i386/coreboot/cb_timestamps.c
@@ -20,7 +20,7 @@
 #include <grub/misc.h>
 #include <grub/command.h>
 #include <grub/i18n.h>
-#include <grub/i386/coreboot/lbio.h>
+#include <grub/coreboot/lbio.h>
 #include <grub/i386/tsc.h>
 
 GRUB_MOD_LICENSE ("GPLv3+");
diff --git a/grub-core/commands/i386/coreboot/cbls.c b/grub-core/commands/i386/coreboot/cbls.c
index e0a10596fe279331cca94172e1f452fdfe18394f..102291f424ab782c6cd3bcd4ae1effd836cd832e 100644
--- a/grub-core/commands/i386/coreboot/cbls.c
+++ b/grub-core/commands/i386/coreboot/cbls.c
@@ -20,7 +20,7 @@
 #include <grub/misc.h>
 #include <grub/command.h>
 #include <grub/i18n.h>
-#include <grub/i386/coreboot/lbio.h>
+#include <grub/coreboot/lbio.h>
 #include <grub/i386/tsc.h>
 
 GRUB_MOD_LICENSE ("GPLv3+");
diff --git a/grub-core/commands/keylayouts.c b/grub-core/commands/keylayouts.c
index f4b7730208ab8ffafb1b0283294a140248839d7a..f35d3a369bad7125cb04e25f0e32c01c00c673b0 100644
--- a/grub-core/commands/keylayouts.c
+++ b/grub-core/commands/keylayouts.c
@@ -40,7 +40,7 @@ static struct grub_keyboard_layout layout_us = {
     /* 0x10 */ 'm',  'n',  'o',  'p',  'q', 'r', 's', 't',
     /* 0x18 */ 'u',  'v',  'w',  'x',  'y', 'z', '1', '2',
     /* 0x20 */ '3',  '4',  '5',  '6',  '7', '8', '9', '0',
-    /* 0x28 */ '\n', '\e', '\b', '\t', ' ', '-', '=', '[',
+    /* 0x28 */ '\n', GRUB_TERM_ESC, GRUB_TERM_BACKSPACE, GRUB_TERM_TAB, ' ', '-', '=', '[',
     /* According to usage table 0x31 should be mapped to '/'
        but testing with real keyboard shows that 0x32 is remapped to '/'.
        Map 0x31 to 0. 
@@ -82,8 +82,8 @@ static struct grub_keyboard_layout layout_us = {
     /* 0x10 */ 'M',  'N',  'O',  'P',  'Q', 'R', 'S', 'T',
     /* 0x18 */ 'U',  'V',  'W',  'X',  'Y', 'Z', '!', '@',
     /* 0x20 */ '#',  '$',  '%',  '^',  '&', '*', '(', ')',
-    /* 0x28 */ '\n' | GRUB_TERM_SHIFT, '\e' | GRUB_TERM_SHIFT, 
-    /* 0x2a */ '\b' | GRUB_TERM_SHIFT, '\t' | GRUB_TERM_SHIFT, 
+    /* 0x28 */ '\n' | GRUB_TERM_SHIFT, GRUB_TERM_ESC | GRUB_TERM_SHIFT,
+    /* 0x2a */ GRUB_TERM_BACKSPACE | GRUB_TERM_SHIFT, GRUB_TERM_TAB | GRUB_TERM_SHIFT,
     /* 0x2c */ ' '  | GRUB_TERM_SHIFT,  '_', '+', '{',
     /* According to usage table 0x31 should be mapped to '/'
        but testing with real keyboard shows that 0x32 is remapped to '/'.
diff --git a/grub-core/commands/menuentry.c b/grub-core/commands/menuentry.c
index 58d4dadf6ee4ec392a09d433802803520704cd7b..2c5363da7f549b85ae04d1d88a78db0b85504c51 100644
--- a/grub-core/commands/menuentry.c
+++ b/grub-core/commands/menuentry.c
@@ -52,8 +52,8 @@ static struct
   int key;
 } hotkey_aliases[] =
   {
-    {"backspace", '\b'},
-    {"tab", '\t'},
+    {"backspace", GRUB_TERM_BACKSPACE},
+    {"tab", GRUB_TERM_TAB},
     {"delete", GRUB_TERM_KEY_DC},
     {"insert", GRUB_TERM_KEY_INSERT},
     {"f1", GRUB_TERM_KEY_F1},
diff --git a/grub-core/fs/ext2.c b/grub-core/fs/ext2.c
index cdce63bcc9d57e82b7a4f6a644803a1d8320935d..b8ad75a0ff7c4f72b67bef123510d99231531daf 100644
--- a/grub-core/fs/ext2.c
+++ b/grub-core/fs/ext2.c
@@ -102,6 +102,7 @@ GRUB_MOD_LICENSE ("GPLv3+");
 #define EXT4_FEATURE_INCOMPAT_64BIT		0x0080
 #define EXT4_FEATURE_INCOMPAT_MMP		0x0100
 #define EXT4_FEATURE_INCOMPAT_FLEX_BG		0x0200
+#define EXT4_FEATURE_INCOMPAT_ENCRYPT          0x10000
 
 /* The set of back-incompatible features this driver DOES support. Add (OR)
  * flags here as the related features are implemented into the driver.  */
@@ -109,7 +110,8 @@ GRUB_MOD_LICENSE ("GPLv3+");
                                        | EXT4_FEATURE_INCOMPAT_EXTENTS  \
                                        | EXT4_FEATURE_INCOMPAT_FLEX_BG \
                                        | EXT2_FEATURE_INCOMPAT_META_BG \
-                                       | EXT4_FEATURE_INCOMPAT_64BIT)
+                                       | EXT4_FEATURE_INCOMPAT_64BIT \
+                                       | EXT4_FEATURE_INCOMPAT_ENCRYPT)
 /* List of rationales for the ignored "incompatible" features:
  * needs_recovery: Not really back-incompatible - was added as such to forbid
  *                 ext2 drivers from mounting an ext3 volume with a dirty
@@ -138,6 +140,7 @@ GRUB_MOD_LICENSE ("GPLv3+");
 #define EXT3_JOURNAL_FLAG_DELETED	4
 #define EXT3_JOURNAL_FLAG_LAST_TAG	8
 
+#define EXT4_ENCRYPT_FLAG              0x800
 #define EXT4_EXTENTS_FLAG		0x80000
 
 /* The ext2 superblock.  */
@@ -706,6 +709,12 @@ grub_ext2_read_symlink (grub_fshelp_node_t node)
       grub_ext2_read_inode (diro->data, diro->ino, &diro->inode);
       if (grub_errno)
 	return 0;
+
+      if (diro->inode.flags & grub_cpu_to_le32_compile_time (EXT4_ENCRYPT_FLAG))
+       {
+         grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET, "symlink is encrypted");
+         return 0;
+       }
     }
 
   symlink = grub_malloc (grub_le_to_cpu32 (diro->inode.size) + 1);
@@ -749,6 +758,12 @@ grub_ext2_iterate_dir (grub_fshelp_node_t dir,
 	return 0;
     }
 
+  if (diro->inode.flags & grub_cpu_to_le32_compile_time (EXT4_ENCRYPT_FLAG))
+    {
+      grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET, "directory is encrypted");
+      return 0;
+    }
+
   /* Search the file.  */
   while (fpos < grub_le_to_cpu32 (diro->inode.size))
     {
@@ -859,6 +874,12 @@ grub_ext2_open (struct grub_file *file, const char *name)
 	goto fail;
     }
 
+  if (fdiro->inode.flags & grub_cpu_to_le32_compile_time (EXT4_ENCRYPT_FLAG))
+    {
+      err = grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET, "file is encrypted");
+      goto fail;
+    }
+
   grub_memcpy (data->inode, &fdiro->inode, sizeof (struct grub_ext2_inode));
   grub_free (fdiro);
 
diff --git a/grub-core/fs/udf.c b/grub-core/fs/udf.c
index 839bff88963baba7730d788869e1f50481a66a30..00a16098b47aff52a352fa9433e279beae261329 100644
--- a/grub-core/fs/udf.c
+++ b/grub-core/fs/udf.c
@@ -321,6 +321,32 @@ struct grub_udf_partmap
   };
 } GRUB_PACKED;
 
+struct grub_udf_pvd
+{
+  struct grub_udf_tag tag;
+  grub_uint32_t seq_num;
+  grub_uint32_t pvd_num;
+  grub_uint8_t ident[32];
+  grub_uint16_t vol_seq_num;
+  grub_uint16_t max_vol_seq_num;
+  grub_uint16_t interchange_level;
+  grub_uint16_t max_interchange_level;
+  grub_uint32_t charset_list;
+  grub_uint32_t max_charset_list;
+  grub_uint8_t volset_ident[128];
+  struct grub_udf_charspec desc_charset;
+  struct grub_udf_charspec expl_charset;
+  struct grub_udf_extent_ad vol_abstract;
+  struct grub_udf_extent_ad vol_copyright;
+  struct grub_udf_regid app_ident;
+  struct grub_udf_timestamp recording_time;
+  struct grub_udf_regid imp_ident;
+  grub_uint8_t imp_use[64];
+  grub_uint32_t pred_vds_loc;
+  grub_uint16_t flags;
+  grub_uint8_t reserved[22];
+} GRUB_PACKED;
+
 struct grub_udf_lvd
 {
   struct grub_udf_tag tag;
@@ -348,6 +374,7 @@ struct grub_udf_aed
 struct grub_udf_data
 {
   grub_disk_t disk;
+  struct grub_udf_pvd pvd;
   struct grub_udf_lvd lvd;
   struct grub_udf_pd pds[GRUB_UDF_MAX_PDS];
   struct grub_udf_partmap *pms[GRUB_UDF_MAX_PMS];
@@ -692,7 +719,17 @@ grub_udf_mount (grub_disk_t disk)
 	}
 
       tag.tag_ident = U16 (tag.tag_ident);
-      if (tag.tag_ident == GRUB_UDF_TAG_IDENT_PD)
+      if (tag.tag_ident == GRUB_UDF_TAG_IDENT_PVD)
+	{
+	  if (grub_disk_read (disk, block << lbshift, 0,
+			      sizeof (struct grub_udf_pvd),
+			      &data->pvd))
+	    {
+	      grub_error (GRUB_ERR_BAD_FS, "not an UDF filesystem");
+	      goto fail;
+	    }
+	}
+      else if (tag.tag_ident == GRUB_UDF_TAG_IDENT_PD)
 	{
 	  if (data->npd >= GRUB_UDF_MAX_PDS)
 	    {
@@ -860,6 +897,25 @@ read_string (const grub_uint8_t *raw, grub_size_t sz, char *outbuf)
   return outbuf;
 }
 
+static char *
+read_dstring (const grub_uint8_t *raw, grub_size_t sz)
+{
+  grub_size_t len;
+
+  if (raw[0] == 0) {
+      char *outbuf = grub_malloc (1);
+      if (!outbuf)
+	return NULL;
+      outbuf[0] = 0;
+      return outbuf;
+    }
+
+  len = raw[sz - 1];
+  if (len > sz - 1)
+    len = sz - 1;
+  return read_string (raw, len, NULL);
+}
+
 static int
 grub_udf_iterate_dir (grub_fshelp_node_t dir,
 		      grub_fshelp_iterate_dir_hook_t hook, void *hook_data)
@@ -1197,7 +1253,7 @@ grub_udf_label (grub_device_t device, char **label)
 
   if (data)
     {
-      *label = read_string (data->lvd.ident, sizeof (data->lvd.ident), 0);
+      *label = read_dstring (data->lvd.ident, sizeof (data->lvd.ident));
       grub_free (data);
     }
   else
@@ -1206,6 +1262,87 @@ grub_udf_label (grub_device_t device, char **label)
   return grub_errno;
 }
 
+static char *
+gen_uuid_from_volset (char *volset_ident)
+{
+  grub_size_t i;
+  grub_size_t len;
+  grub_size_t nonhexpos;
+  grub_uint8_t buf[17];
+  char *uuid;
+
+  len = grub_strlen (volset_ident);
+  if (len < 8)
+    return NULL;
+
+  uuid = grub_malloc (17);
+  if (!uuid)
+    return NULL;
+
+  if (len > 16)
+    len = 16;
+
+  grub_memset (buf, 0, sizeof (buf));
+  grub_memcpy (buf, volset_ident, len);
+
+  nonhexpos = 16;
+  for (i = 0; i < 16; ++i)
+    {
+      if (!grub_isxdigit (buf[i]))
+        {
+          nonhexpos = i;
+          break;
+        }
+    }
+
+  if (nonhexpos < 8)
+    {
+      grub_snprintf (uuid, 17, "%02x%02x%02x%02x%02x%02x%02x%02x",
+                    buf[0], buf[1], buf[2], buf[3],
+                    buf[4], buf[5], buf[6], buf[7]);
+    }
+  else if (nonhexpos < 16)
+    {
+      for (i = 0; i < 8; ++i)
+        uuid[i] = grub_tolower (buf[i]);
+      grub_snprintf (uuid+8, 9, "%02x%02x%02x%02x",
+                    buf[8], buf[9], buf[10], buf[11]);
+    }
+  else
+    {
+      for (i = 0; i < 16; ++i)
+        uuid[i] = grub_tolower (buf[i]);
+      uuid[16] = 0;
+    }
+
+  return uuid;
+}
+
+static grub_err_t
+grub_udf_uuid (grub_device_t device, char **uuid)
+{
+  char *volset_ident;
+  struct grub_udf_data *data;
+  data = grub_udf_mount (device->disk);
+
+  if (data)
+    {
+      volset_ident = read_dstring (data->pvd.volset_ident, sizeof (data->pvd.volset_ident));
+      if (volset_ident)
+        {
+          *uuid = gen_uuid_from_volset (volset_ident);
+          grub_free (volset_ident);
+        }
+      else
+        *uuid = 0;
+      grub_free (data);
+    }
+  else
+    *uuid = 0;
+
+  return grub_errno;
+}
+
 static struct grub_fs grub_udf_fs = {
   .name = "udf",
   .dir = grub_udf_dir,
@@ -1213,6 +1350,7 @@ static struct grub_fs grub_udf_fs = {
   .read = grub_udf_read,
   .close = grub_udf_close,
   .label = grub_udf_label,
+  .uuid = grub_udf_uuid,
 #ifdef GRUB_UTIL
   .reserved_first_sector = 1,
   .blocklist_install = 1,
diff --git a/grub-core/fs/zfs/zfs_lz4.c b/grub-core/fs/zfs/zfs_lz4.c
index 2f73449f0d4c63cadc7b5b4388250a4d474594b6..5453822d0258527ba751e551cbb54753f0331043 100644
--- a/grub-core/fs/zfs/zfs_lz4.c
+++ b/grub-core/fs/zfs/zfs_lz4.c
@@ -73,7 +73,6 @@ static int LZ4_uncompress_unknownOutputSize(const char *source, char *dest,
 #define	U32	grub_uint32_t
 #define	S32	grub_int32_t
 #define	U64	grub_uint64_t
-typedef grub_size_t size_t;
 
 typedef struct _U16_S {
 	U16 v;
@@ -133,10 +132,10 @@ typedef struct _U64_S {
 
 /* Decompression functions */
 grub_err_t
-lz4_decompress(void *s_start, void *d_start, size_t s_len, size_t d_len);
+lz4_decompress(void *s_start, void *d_start, grub_size_t s_len, grub_size_t d_len);
 
 grub_err_t
-lz4_decompress(void *s_start, void *d_start, size_t s_len, size_t d_len)
+lz4_decompress(void *s_start, void *d_start, grub_size_t s_len, grub_size_t d_len)
 {
 	const BYTE *src = s_start;
 	U32 bufsiz = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) |
@@ -167,7 +166,7 @@ LZ4_uncompress_unknownOutputSize(const char *source,
 	BYTE *const oend = op + maxOutputSize;
 	BYTE *cpy;
 
-	size_t dec[] = { 0, 3, 2, 3, 0, 0, 0, 0 };
+	grub_size_t dec[] = { 0, 3, 2, 3, 0, 0, 0, 0 };
 
 	/* Main Loop */
 	while (ip < iend) {
@@ -237,8 +236,8 @@ LZ4_uncompress_unknownOutputSize(const char *source,
 		/* copy repeated sequence */
 		if unlikely(op - ref < STEPSIZE) {
 #if LZ4_ARCH64
-			size_t dec2table[] = { 0, 0, 0, -1, 0, 1, 2, 3 };
-			size_t dec2 = dec2table[op - ref];
+			grub_size_t dec2table[] = { 0, 0, 0, -1, 0, 1, 2, 3 };
+			grub_size_t dec2 = dec2table[op - ref];
 #else
 			const int dec2 = 0;
 #endif
diff --git a/grub-core/io/gzio.c b/grub-core/io/gzio.c
index 0f2ea6bd845227265eef205c212e7c52ee03ebcf..a8e33033bf801483253755ab3300614169fa37fe 100644
--- a/grub-core/io/gzio.c
+++ b/grub-core/io/gzio.c
@@ -140,24 +140,24 @@ eat_field (grub_file_t file, int len)
 #define OLD_GZIP_MAGIC	grub_le_to_cpu16 (0x9E1F)
 
 /* Compression methods (see algorithm.doc) */
-#define STORED      0
-#define COMPRESSED  1
-#define PACKED      2
-#define LZHED       3
+#define GRUB_GZ_STORED      0
+#define GRUB_GZ_COMPRESSED  1
+#define GRUB_GZ_PACKED      2
+#define GRUB_GZ_LZHED       3
 /* methods 4 to 7 reserved */
-#define DEFLATED    8
-#define MAX_METHODS 9
+#define GRUB_GZ_DEFLATED    8
+#define GRUB_GZ_MAX_METHODS 9
 
 /* gzip flag byte */
-#define ASCII_FLAG   0x01	/* bit 0 set: file probably ascii text */
-#define CONTINUATION 0x02	/* bit 1 set: continuation of multi-part gzip file */
-#define EXTRA_FIELD  0x04	/* bit 2 set: extra field present */
-#define ORIG_NAME    0x08	/* bit 3 set: original file name present */
-#define COMMENT      0x10	/* bit 4 set: file comment present */
-#define ENCRYPTED    0x20	/* bit 5 set: file is encrypted */
-#define RESERVED     0xC0	/* bit 6,7:   reserved */
+#define GRUB_GZ_ASCII_FLAG   0x01	/* bit 0 set: file probably ascii text */
+#define GRUB_GZ_CONTINUATION 0x02	/* bit 1 set: continuation of multi-part gzip file */
+#define GRUB_GZ_EXTRA_FIELD  0x04	/* bit 2 set: extra field present */
+#define GRUB_GZ_ORIG_NAME    0x08	/* bit 3 set: original file name present */
+#define GRUB_GZ_COMMENT      0x10	/* bit 4 set: file comment present */
+#define GRUB_GZ_ENCRYPTED    0x20	/* bit 5 set: file is encrypted */
+#define GRUB_GZ_RESERVED     0xC0	/* bit 6,7:   reserved */
 
-#define UNSUPPORTED_FLAGS	(CONTINUATION | ENCRYPTED | RESERVED)
+#define GRUB_GZ_UNSUPPORTED_FLAGS	(GRUB_GZ_CONTINUATION | GRUB_GZ_ENCRYPTED | GRUB_GZ_RESERVED)
 
 /* inflate block codes */
 #define INFLATE_STORED	0
@@ -201,14 +201,14 @@ test_gzip_header (grub_file_t file)
    *  problem occurs from here on, then we have corrupt or otherwise
    *  bad data, and the error should be reported to the user.
    */
-  if (hdr.method != DEFLATED
-      || (hdr.flags & UNSUPPORTED_FLAGS)
-      || ((hdr.flags & EXTRA_FIELD)
+  if (hdr.method != GRUB_GZ_DEFLATED
+      || (hdr.flags & GRUB_GZ_UNSUPPORTED_FLAGS)
+      || ((hdr.flags & GRUB_GZ_EXTRA_FIELD)
 	  && (grub_file_read (gzio->file, &extra_len, 2) != 2
 	      || eat_field (gzio->file,
 			    grub_le_to_cpu16 (extra_len))))
-      || ((hdr.flags & ORIG_NAME) && eat_field (gzio->file, -1))
-      || ((hdr.flags & COMMENT) && eat_field (gzio->file, -1)))
+      || ((hdr.flags & GRUB_GZ_ORIG_NAME) && eat_field (gzio->file, -1))
+      || ((hdr.flags & GRUB_GZ_COMMENT) && eat_field (gzio->file, -1)))
     return 0;
 
   gzio->data_offset = grub_file_tell (gzio->file);
@@ -1183,7 +1183,7 @@ test_zlib_header (grub_gzio_t gzio)
   flg = get_byte (gzio);
 
   /* Check that compression method is DEFLATE.  */
-  if ((cmf & 0xf) != DEFLATED)
+  if ((cmf & 0xf) != GRUB_GZ_DEFLATED)
     {
       /* TRANSLATORS: It's about given file having some strange format, not
 	 complete lack of gzip support.  */
diff --git a/grub-core/kern/arm/cache.c b/grub-core/kern/arm/cache.c
index 34154ccdb0e09d7d9fd91c4164fe8577ce449260..af1c4bbf544f0ebcca5c0f58c847c8dddc1f2e91 100644
--- a/grub-core/kern/arm/cache.c
+++ b/grub-core/kern/arm/cache.c
@@ -29,6 +29,8 @@ void grub_arm_clean_dcache_range_armv6 (grub_addr_t start, grub_addr_t end,
 					grub_addr_t dlinesz);
 void grub_arm_clean_dcache_range_armv7 (grub_addr_t start, grub_addr_t end,
 					grub_addr_t dlinesz);
+void grub_arm_clean_dcache_range_poc_armv7 (grub_addr_t start, grub_addr_t end,
+					    grub_addr_t dlinesz);
 void grub_arm_invalidate_icache_range_armv6 (grub_addr_t start, grub_addr_t end,
 					     grub_addr_t dlinesz);
 void grub_arm_invalidate_icache_range_armv7 (grub_addr_t start, grub_addr_t end,
@@ -252,6 +254,38 @@ grub_arch_sync_caches (void *address, grub_size_t len)
     }
 }
 
+void
+grub_arch_sync_dma_caches (volatile void *address, grub_size_t len)
+{
+  grub_addr_t start = (grub_addr_t) address;
+  grub_addr_t end = start + len;
+
+  if (type == ARCH_UNKNOWN)
+    probe_caches ();
+  start = ALIGN_DOWN (start, grub_arch_cache_max_linesz);
+  end = ALIGN_UP (end, grub_arch_cache_max_linesz);
+  switch (type)
+    {
+    case ARCH_ARMV6:
+      grub_arm_clean_dcache_range_armv6 (start, end, grub_arch_cache_dlinesz);
+      grub_arm_invalidate_icache_range_armv6 (start, end,
+					      grub_arch_cache_ilinesz);
+      break;
+    case ARCH_ARMV5_WRITE_THROUGH:
+    case ARCH_ARMV6_UNIFIED:
+      grub_arm_clean_dcache_range_armv6 (start, end, grub_arch_cache_dlinesz);
+      break;
+    case ARCH_ARMV7:
+      grub_arm_clean_dcache_range_poc_armv7 (start, end, grub_arch_cache_dlinesz);
+      grub_arm_invalidate_icache_range_armv7 (start, end,
+					      grub_arch_cache_ilinesz);
+      break;
+      /* Pacify GCC.  */
+    case ARCH_UNKNOWN:
+      break;
+    }
+}
+
 void
 grub_arm_disable_caches_mmu (void)
 {
diff --git a/grub-core/kern/arm/coreboot/cbtable.c b/grub-core/kern/arm/coreboot/cbtable.c
new file mode 100644
index 0000000000000000000000000000000000000000..8a655bb5cc28fb013674dc792531d8a9ba1c4b85
--- /dev/null
+++ b/grub-core/kern/arm/coreboot/cbtable.c
@@ -0,0 +1,40 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2007,2008,2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/coreboot/lbio.h>
+#include <grub/types.h>
+#include <grub/err.h>
+#include <grub/misc.h>
+#include <grub/dl.h>
+#include <grub/arm/startup.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+#pragma GCC diagnostic ignored "-Wcast-align"
+
+grub_linuxbios_table_header_t
+grub_linuxbios_get_tables (void)
+{
+  grub_linuxbios_table_header_t table_header
+    = (grub_linuxbios_table_header_t) grub_arm_saved_registers.r[0];
+
+  if (!grub_linuxbios_check_signature (table_header))
+    return 0;
+
+  return table_header;
+}
diff --git a/grub-core/kern/arm/coreboot/dma.c b/grub-core/kern/arm/coreboot/dma.c
new file mode 100644
index 0000000000000000000000000000000000000000..2c2a6278904631c91bd29b3c4338c606471672fe
--- /dev/null
+++ b/grub-core/kern/arm/coreboot/dma.c
@@ -0,0 +1,59 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2007,2009  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/dl.h>
+#include <grub/dma.h>
+#include <grub/mm.h>
+#include <grub/misc.h>
+#include <grub/mm_private.h>
+#include <grub/cache.h>
+
+struct grub_pci_dma_chunk *
+grub_memalign_dma32 (grub_size_t align, grub_size_t size)
+{
+  void *ret;
+  if (align < 64)
+    align = 64;
+  size = ALIGN_UP (size, align);
+  ret = grub_memalign (align, size);
+  if (!ret)
+    return 0;
+  grub_arch_sync_dma_caches (ret, size);
+  return ret;
+}
+
+void
+grub_dma_free (struct grub_pci_dma_chunk *ch)
+{
+  grub_size_t size = (((struct grub_mm_header *) ch) - 1)->size * GRUB_MM_ALIGN;
+  grub_arch_sync_dma_caches (ch, size);
+  grub_free (ch);
+}
+
+volatile void *
+grub_dma_get_virt (struct grub_pci_dma_chunk *ch)
+{
+  return (void *) ch;
+}
+
+grub_uint32_t
+grub_dma_get_phys (struct grub_pci_dma_chunk *ch)
+{
+  return (grub_uint32_t) (grub_addr_t) ch;
+}
+
diff --git a/grub-core/kern/arm/coreboot/init.c b/grub-core/kern/arm/coreboot/init.c
new file mode 100644
index 0000000000000000000000000000000000000000..8d8c5b8291eff9743b0325b76f851d52509b1f4f
--- /dev/null
+++ b/grub-core/kern/arm/coreboot/init.c
@@ -0,0 +1,151 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2002,2003,2004,2005,2006,2007,2008,2009,2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/kernel.h>
+#include <grub/mm.h>
+#include <grub/memory.h>
+#include <grub/machine/console.h>
+#include <grub/machine/kernel.h>
+#include <grub/offsets.h>
+#include <grub/types.h>
+#include <grub/err.h>
+#include <grub/dl.h>
+#include <grub/misc.h>
+#include <grub/loader.h>
+#include <grub/env.h>
+#include <grub/cache.h>
+#include <grub/time.h>
+#include <grub/symbol.h>
+#include <grub/video.h>
+#include <grub/coreboot/lbio.h>
+#include <grub/fdtbus.h>
+
+extern grub_uint8_t _start[];
+extern grub_uint8_t _end[];
+extern grub_uint8_t _edata[];
+grub_addr_t start_of_ram = ~(grub_addr_t)0;
+
+void  __attribute__ ((noreturn))
+grub_exit (void)
+{
+  /* We can't use grub_fatal() in this function.  This would create an infinite
+     loop, since grub_fatal() calls grub_abort() which in turn calls grub_exit().  */
+  while (1)
+    grub_cpu_idle ();
+}
+
+static grub_uint64_t modend;
+static int have_memory = 0;
+
+/* Helper for grub_machine_init.  */
+static int
+heap_init (grub_uint64_t addr, grub_uint64_t size, grub_memory_type_t type,
+	   void *data __attribute__ ((unused)))
+{
+  grub_uint64_t begin = addr, end = addr + size;
+
+#if GRUB_CPU_SIZEOF_VOID_P == 4
+  /* Restrict ourselves to 32-bit memory space.  */
+  if (begin > GRUB_ULONG_MAX)
+    return 0;
+  if (end > GRUB_ULONG_MAX)
+    end = GRUB_ULONG_MAX;
+#endif
+
+  if (start_of_ram > begin)
+    start_of_ram = begin;
+
+  if (type != GRUB_MEMORY_AVAILABLE)
+    return 0;
+
+  if (modend && begin < modend)
+    {
+      if (begin < (grub_addr_t)_start)
+	{
+	  grub_mm_init_region ((void *) (grub_addr_t) begin, (grub_size_t) ((grub_addr_t)_start - begin));
+	  have_memory = 1;
+	}
+      begin = modend;
+    }
+
+  /* Avoid DMA problems.  */
+  if (end >= 0xfe000000)
+    end = 0xfe000000;
+
+  if (end <= begin)
+    return 0;
+
+  grub_mm_init_region ((void *) (grub_addr_t) begin, (grub_size_t) (end - begin));
+
+  have_memory = 1;
+
+  return 0;
+}
+
+void
+grub_machine_init (void)
+{
+  struct grub_module_header *header;
+  void *dtb = 0;
+  grub_size_t dtb_size = 0;
+
+  modend = grub_modules_get_end ();
+
+  grub_video_coreboot_fb_early_init ();
+
+  grub_machine_mmap_iterate (heap_init, NULL);
+  if (!have_memory)
+    grub_fatal ("No memory found");
+
+  grub_video_coreboot_fb_late_init ();
+
+  grub_font_init ();
+  grub_gfxterm_init ();
+
+  FOR_MODULES (header)
+    if (header->type == OBJ_TYPE_DTB)
+      {
+	char *dtb_orig_addr, *dtb_copy;
+	dtb_orig_addr = (char *) header + sizeof (struct grub_module_header);
+
+	dtb_size = header->size - sizeof (struct grub_module_header);
+	dtb = dtb_copy = grub_malloc (dtb_size);
+	grub_memmove (dtb_copy, dtb_orig_addr, dtb_size);
+	break;
+      }
+  if (!dtb)
+    grub_fatal ("No DTB found");
+  grub_fdtbus_init (dtb, dtb_size);
+
+  grub_rk3288_spi_init ();
+
+  grub_machine_timer_init ();
+  grub_cros_init ();
+  grub_pl050_init ();
+}
+
+void
+grub_machine_get_bootlocation (char **device __attribute__ ((unused)),
+			       char **path __attribute__ ((unused)))
+{
+}
+
+void
+grub_machine_fini (int flags __attribute__ ((unused)))
+{
+}
diff --git a/grub-core/kern/arm/coreboot/timer.c b/grub-core/kern/arm/coreboot/timer.c
new file mode 100644
index 0000000000000000000000000000000000000000..d97b844f8487c064922a552a5ea4d5f220031dba
--- /dev/null
+++ b/grub-core/kern/arm/coreboot/timer.c
@@ -0,0 +1,101 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2016  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/mm.h>
+#include <grub/machine/kernel.h>
+#include <grub/types.h>
+#include <grub/err.h>
+#include <grub/time.h>
+#include <grub/fdtbus.h>
+#include <grub/misc.h>
+
+grub_uint64_t
+grub_armv7_get_timer_value(void);
+
+grub_uint32_t
+grub_armv7_get_timer_frequency(void);
+
+grub_uint32_t
+grub_arm_pfr1(void);
+
+static int have_timer = 0;
+static volatile grub_uint32_t *sp804_regs;
+
+static grub_uint64_t
+sp804_get_time_ms (void)
+{
+  static grub_uint32_t high, last_low;
+  grub_uint32_t low = ~sp804_regs[1];
+  if (last_low > low)
+    high++;
+  last_low = low;
+  return grub_divmod64 ((((grub_uint64_t) high) << 32) | low,
+			1000, 0);
+}
+
+static grub_err_t
+sp804_attach(const struct grub_fdtbus_dev *dev)
+{
+  if (have_timer)
+    return GRUB_ERR_NONE;
+  sp804_regs = grub_fdtbus_map_reg (dev, 0, 0);
+  if (!grub_fdtbus_is_mapping_valid (sp804_regs))
+    return grub_error (GRUB_ERR_IO, "could not map sp804: %p", sp804_regs);
+  grub_install_get_time_ms (sp804_get_time_ms);
+  have_timer = 1;
+  return GRUB_ERR_NONE;
+}
+
+struct grub_fdtbus_driver sp804 =
+{
+  .compatible = "arm,sp804",
+  .attach = sp804_attach
+};
+
+static grub_uint32_t timer_frequency_in_khz;
+
+static grub_uint64_t
+generic_get_time_ms (void)
+{
+  return grub_divmod64 (grub_armv7_get_timer_value(), timer_frequency_in_khz, 0);
+}
+
+static int
+try_generic_timer (void)
+{
+  if (((grub_arm_pfr1 () >> 16) & 0xf) != 1)
+    return 0;
+  grub_printf ("freq = %x\n", grub_armv7_get_timer_frequency());
+  timer_frequency_in_khz = 0x016e3600 / 1000; //grub_armv7_get_timer_frequency() / 1000;
+  if (timer_frequency_in_khz == 0)
+    return 0;
+  grub_install_get_time_ms (generic_get_time_ms);
+  have_timer = 1;
+  return 1;
+}
+
+void
+grub_machine_timer_init (void)
+{
+  grub_fdtbus_register (&sp804);
+
+  if (!have_timer)
+    try_generic_timer ();
+  if (!have_timer)
+    grub_fatal ("No timer found");
+}
diff --git a/grub-core/kern/arm/efi/misc.c b/grub-core/kern/arm/efi/misc.c
index 7cd41842ae7662018c2ce5ff847aeb250572ec85..c95e8299d42fff17ec9ce9e8f4452f499160e13c 100644
--- a/grub-core/kern/arm/efi/misc.c
+++ b/grub-core/kern/arm/efi/misc.c
@@ -146,7 +146,7 @@ grub_efi_allocate_loader_memory (grub_uint32_t min_offset, grub_uint32_t size)
 	continue;
       grub_dprintf("mm", "%s: let's allocate some (0x%x) pages @ 0x%08x...\n",
 		  __FUNCTION__, (size >> PAGE_SHIFT), (grub_addr_t) start);
-      mem = grub_efi_allocate_pages (start, (size >> PAGE_SHIFT) + 1);
+      mem = grub_efi_allocate_fixed (start, (size >> PAGE_SHIFT) + 1);
       grub_dprintf("mm", "%s: retval=0x%08x\n",
 		   __FUNCTION__, (grub_addr_t) mem);
       if (! mem)
@@ -189,7 +189,7 @@ grub_efi_prepare_platform (void)
   mmap_size = find_mmap_size ();
   if (! mmap_size)
     return GRUB_ERR_OUT_OF_MEMORY;
-  mmap_buf = grub_efi_allocate_pages (0, page_align (mmap_size) >> 12);
+  mmap_buf = grub_efi_allocate_any_pages (page_align (mmap_size) >> 12);
   if (! mmap_buf)
     return GRUB_ERR_OUT_OF_MEMORY;
 
diff --git a/grub-core/kern/arm/uboot/init.c b/grub-core/kern/arm/uboot/init.c
new file mode 100644
index 0000000000000000000000000000000000000000..2a6aa3fdd3dd049848015f6c67dfc0f30a79a9c4
--- /dev/null
+++ b/grub-core/kern/arm/uboot/init.c
@@ -0,0 +1,70 @@
+/* init.c - generic U-Boot initialization and finalization */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2016  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/uboot/uboot.h>
+#include <grub/arm/startup.h>
+#include <grub/uboot/api_public.h>
+
+extern int (*grub_uboot_syscall_ptr) (int, int *, ...);
+
+grub_uint32_t
+grub_uboot_get_machine_type (void)
+{
+  return grub_arm_saved_registers.r[1];
+}
+
+grub_addr_t
+grub_uboot_get_boot_data (void)
+{
+  return grub_arm_saved_registers.r[2];
+}
+
+int
+grub_uboot_api_init (void)
+{
+  struct api_signature *start, *end;
+  struct api_signature *p;
+  grub_addr_t grub_uboot_search_hint = grub_arm_saved_registers.sp;
+  if (grub_uboot_search_hint)
+    {
+      /* Extended search range to work around Trim Slice U-Boot issue */
+      start = (struct api_signature *) ((grub_uboot_search_hint & ~0x000fffff)
+					- 0x00500000);
+      end =
+	(struct api_signature *) ((grub_addr_t) start + UBOOT_API_SEARCH_LEN -
+				  API_SIG_MAGLEN + 0x00500000);
+    }
+  else
+    {
+      start = 0;
+      end = (struct api_signature *) (256 * 1024 * 1024);
+    }
+
+  /* Structure alignment is (at least) 8 bytes */
+  for (p = start; p < end; p = (void *) ((grub_addr_t) p + 8))
+    {
+      if (grub_memcmp (&(p->magic), API_SIG_MAGIC, API_SIG_MAGLEN) == 0)
+	{
+	  grub_uboot_syscall_ptr = p->syscall;
+	  return p->version;
+	}
+    }
+
+  return 0;
+}
diff --git a/grub-core/kern/coreboot/cbtable.c b/grub-core/kern/coreboot/cbtable.c
new file mode 100644
index 0000000000000000000000000000000000000000..aec63dbd1209e4c3cbbe165d54a78277ea72f361
--- /dev/null
+++ b/grub-core/kern/coreboot/cbtable.c
@@ -0,0 +1,72 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2007,2008,2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/i386/coreboot/memory.h>
+#include <grub/coreboot/lbio.h>
+#include <grub/types.h>
+#include <grub/err.h>
+#include <grub/misc.h>
+#include <grub/dl.h>
+
+#pragma GCC diagnostic ignored "-Wcast-align"
+
+/* Helper for grub_linuxbios_table_iterate.  */
+int
+grub_linuxbios_check_signature (grub_linuxbios_table_header_t tbl_header)
+{
+  if (! grub_memcmp (tbl_header->signature, "LBIO", 4))
+    return 1;
+
+  return 0;
+}
+
+grub_err_t
+grub_linuxbios_table_iterate (int (*hook) (grub_linuxbios_table_item_t,
+					   void *),
+			      void *hook_data)
+{
+  grub_linuxbios_table_header_t table_header = grub_linuxbios_get_tables ();
+  grub_linuxbios_table_item_t table_item;
+
+  if (!table_header)
+    return 0;
+
+signature_found:
+
+  table_item =
+    (grub_linuxbios_table_item_t) ((char *) table_header +
+				   table_header->header_size);
+  for (; table_item < (grub_linuxbios_table_item_t) ((char *) table_header
+						     + table_header->header_size
+						     + table_header->table_size);
+       table_item = (grub_linuxbios_table_item_t) ((char *) table_item + table_item->size))
+    {
+      if (table_item->tag == GRUB_LINUXBIOS_MEMBER_LINK
+         && grub_linuxbios_check_signature ((grub_linuxbios_table_header_t) (grub_addr_t)
+                             *(grub_uint64_t *) (table_item + 1)))
+       {
+         table_header = (grub_linuxbios_table_header_t) (grub_addr_t)
+           *(grub_uint64_t *) (table_item + 1);
+         goto signature_found;   
+       }
+      if (hook (table_item, hook_data))
+       return 1;
+    }
+
+  return 0;
+}
diff --git a/grub-core/kern/i386/coreboot/mmap.c b/grub-core/kern/coreboot/mmap.c
similarity index 97%
rename from grub-core/kern/i386/coreboot/mmap.c
rename to grub-core/kern/coreboot/mmap.c
index 4d29f6b7d90591939cf5d837b39c5d259a55efb0..caf8f7cef1b4552c720eb3b7ca355eb6cec32955 100644
--- a/grub-core/kern/i386/coreboot/mmap.c
+++ b/grub-core/kern/coreboot/mmap.c
@@ -16,8 +16,8 @@
  *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <grub/machine/memory.h>
-#include <grub/machine/lbio.h>
+#include <grub/memory.h>
+#include <grub/coreboot/lbio.h>
 #include <grub/types.h>
 #include <grub/err.h>
 #include <grub/misc.h>
@@ -49,6 +49,7 @@ iterate_linuxbios_table (grub_linuxbios_table_item_t table_item, void *data)
     {
       grub_uint64_t start = mem_region->addr;
       grub_uint64_t end = mem_region->addr + mem_region->size;
+#ifdef __i386__
       /* Mark region 0xa0000 - 0x100000 as reserved.  */
       if (start < 0x100000 && end >= 0xa0000
 	  && mem_region->type == GRUB_MACHINE_MEMORY_AVAILABLE)
@@ -75,6 +76,7 @@ iterate_linuxbios_table (grub_linuxbios_table_item_t table_item, void *data)
 	  if (end <= start)
 	    continue;
 	}
+#endif
       if (ctx->hook (start, end - start,
 		     /* Multiboot mmaps match with the coreboot mmap
 		        definition.  Therefore, we can just pass type
diff --git a/grub-core/kern/efi/mm.c b/grub-core/kern/efi/mm.c
index 20a47aaf5d0df376090510ddb8337ecc8aa18e98..ac2a4c556b8d4cb21998b112e27b6407fd7126d1 100644
--- a/grub-core/kern/efi/mm.c
+++ b/grub-core/kern/efi/mm.c
@@ -51,36 +51,20 @@ int grub_efi_is_finished = 0;
 
 /* Allocate pages. Return the pointer to the first of allocated pages.  */
 void *
-grub_efi_allocate_pages (grub_efi_physical_address_t address,
-			 grub_efi_uintn_t pages)
+grub_efi_allocate_pages_real (grub_efi_physical_address_t address,
+			      grub_efi_uintn_t pages,
+			      grub_efi_allocate_type_t alloctype,
+			      grub_efi_memory_type_t memtype)
 {
-  grub_efi_allocate_type_t type;
   grub_efi_status_t status;
   grub_efi_boot_services_t *b;
 
-#if 1
   /* Limit the memory access to less than 4GB for 32-bit platforms.  */
   if (address > GRUB_EFI_MAX_USABLE_ADDRESS)
     return 0;
-#endif
-
-#if 1
-  if (address == 0)
-    {
-      type = GRUB_EFI_ALLOCATE_MAX_ADDRESS;
-      address = GRUB_EFI_MAX_USABLE_ADDRESS;
-    }
-  else
-    type = GRUB_EFI_ALLOCATE_ADDRESS;
-#else
-  if (address == 0)
-    type = GRUB_EFI_ALLOCATE_ANY_PAGES;
-  else
-    type = GRUB_EFI_ALLOCATE_ADDRESS;
-#endif
 
   b = grub_efi_system_table->boot_services;
-  status = efi_call_4 (b->allocate_pages, type, GRUB_EFI_LOADER_DATA, pages, &address);
+  status = efi_call_4 (b->allocate_pages, alloctype, memtype, pages, &address);
   if (status != GRUB_EFI_SUCCESS)
     return 0;
 
@@ -89,7 +73,7 @@ grub_efi_allocate_pages (grub_efi_physical_address_t address,
       /* Uggh, the address 0 was allocated... This is too annoying,
 	 so reallocate another one.  */
       address = GRUB_EFI_MAX_USABLE_ADDRESS;
-      status = efi_call_4 (b->allocate_pages, type, GRUB_EFI_LOADER_DATA, pages, &address);
+      status = efi_call_4 (b->allocate_pages, alloctype, memtype, pages, &address);
       grub_efi_free_pages (0, pages);
       if (status != GRUB_EFI_SUCCESS)
 	return 0;
@@ -98,6 +82,23 @@ grub_efi_allocate_pages (grub_efi_physical_address_t address,
   return (void *) ((grub_addr_t) address);
 }
 
+void *
+grub_efi_allocate_any_pages (grub_efi_uintn_t pages)
+{
+  return grub_efi_allocate_pages_real (GRUB_EFI_MAX_USABLE_ADDRESS,
+				       pages, GRUB_EFI_ALLOCATE_MAX_ADDRESS,
+				       GRUB_EFI_LOADER_DATA);
+}
+
+void *
+grub_efi_allocate_fixed (grub_efi_physical_address_t address,
+			 grub_efi_uintn_t pages)
+{
+  return grub_efi_allocate_pages_real (address, pages,
+				       GRUB_EFI_ALLOCATE_ADDRESS,
+				       GRUB_EFI_LOADER_DATA);
+}
+
 /* Free pages starting from ADDRESS.  */
 void
 grub_efi_free_pages (grub_efi_physical_address_t address,
@@ -402,7 +403,9 @@ add_memory_regions (grub_efi_memory_descriptor_t *memory_map,
 	  pages = required_pages;
 	}
 
-      addr = grub_efi_allocate_pages (start, pages);
+      addr = grub_efi_allocate_pages_real (start, pages,
+					   GRUB_EFI_ALLOCATE_ADDRESS,
+					   GRUB_EFI_LOADER_CODE);      
       if (! addr)
 	grub_fatal ("cannot allocate conventional memory %p with %u pages",
 		    (void *) ((grub_addr_t) start),
@@ -454,8 +457,7 @@ grub_efi_mm_init (void)
   int mm_status;
 
   /* Prepare a memory region to store two memory maps.  */
-  memory_map = grub_efi_allocate_pages (0,
-					2 * BYTES_TO_PAGES (MEMORY_MAP_SIZE));
+  memory_map = grub_efi_allocate_any_pages (2 * BYTES_TO_PAGES (MEMORY_MAP_SIZE));
   if (! memory_map)
     grub_fatal ("cannot allocate memory");
 
@@ -473,7 +475,7 @@ grub_efi_mm_init (void)
       /* Freeing/allocating operations may increase memory map size.  */
       map_size += desc_size * 32;
 
-      memory_map = grub_efi_allocate_pages (0, 2 * BYTES_TO_PAGES (map_size));
+      memory_map = grub_efi_allocate_any_pages (2 * BYTES_TO_PAGES (map_size));
       if (! memory_map)
 	grub_fatal ("cannot allocate memory");
 
diff --git a/grub-core/kern/i386/coreboot/cbtable.c b/grub-core/kern/i386/coreboot/cbtable.c
index 1669bc0ca23a2fe5dcfb8e2b6c973ddb5e27e880..34a2b59be1ffa926e9dcc931140695cc82be223c 100644
--- a/grub-core/kern/i386/coreboot/cbtable.c
+++ b/grub-core/kern/i386/coreboot/cbtable.c
@@ -17,7 +17,7 @@
  */
 
 #include <grub/i386/coreboot/memory.h>
-#include <grub/i386/coreboot/lbio.h>
+#include <grub/coreboot/lbio.h>
 #include <grub/types.h>
 #include <grub/err.h>
 #include <grub/misc.h>
@@ -25,59 +25,20 @@
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
-/* Helper for grub_linuxbios_table_iterate.  */
-static int
-check_signature (grub_linuxbios_table_header_t tbl_header)
-{
-  if (! grub_memcmp (tbl_header->signature, "LBIO", 4))
-    return 1;
-
-  return 0;
-}
-
-grub_err_t
-grub_linuxbios_table_iterate (int (*hook) (grub_linuxbios_table_item_t,
-					   void *),
-			      void *hook_data)
+grub_linuxbios_table_header_t
+grub_linuxbios_get_tables (void)
 {
   grub_linuxbios_table_header_t table_header;
-  grub_linuxbios_table_item_t table_item;
-
   /* Assuming table_header is aligned to its size (8 bytes).  */
-
   for (table_header = (grub_linuxbios_table_header_t) 0x500;
        table_header < (grub_linuxbios_table_header_t) 0x1000; table_header++)
-    if (check_signature (table_header))
-      goto signature_found;
+    if (grub_linuxbios_check_signature (table_header))
+      return table_header;
 
   for (table_header = (grub_linuxbios_table_header_t) 0xf0000;
        table_header < (grub_linuxbios_table_header_t) 0x100000; table_header++)
-    if (check_signature (table_header))
-      goto signature_found;
-
-  return 0;
-
-signature_found:
-
-  table_item =
-    (grub_linuxbios_table_item_t) ((char *) table_header +
-				   table_header->header_size);
-  for (; table_item < (grub_linuxbios_table_item_t) ((char *) table_header
-						     + table_header->header_size
-						     + table_header->table_size);
-       table_item = (grub_linuxbios_table_item_t) ((char *) table_item + table_item->size))
-    {
-      if (table_item->tag == GRUB_LINUXBIOS_MEMBER_LINK
-         && check_signature ((grub_linuxbios_table_header_t) (grub_addr_t)
-                             *(grub_uint64_t *) (table_item + 1)))
-       {
-         table_header = (grub_linuxbios_table_header_t) (grub_addr_t)
-           *(grub_uint64_t *) (table_item + 1);
-         goto signature_found;   
-       }
-      if (hook (table_item, hook_data))
-       return 1;
-    }
+    if (grub_linuxbios_check_signature (table_header))
+      return table_header;
 
   return 0;
 }
diff --git a/grub-core/kern/misc.c b/grub-core/kern/misc.c
index d1a54df6c12e3358e07aa86366c65af22ca3af5c..3b633d51f4c63e2983e8b3419dc057437224fb93 100644
--- a/grub-core/kern/misc.c
+++ b/grub-core/kern/misc.c
@@ -391,12 +391,13 @@ grub_strtoull (const char *str, char **end, int base)
       unsigned long digit;
 
       digit = grub_tolower (*str) - '0';
-      if (digit > 9)
-	{
-	  digit += '0' - 'a' + 10;
-	  if (digit >= (unsigned long) base)
-	    break;
-	}
+      if (digit >= 'a' - '0')
+	digit += '0' - 'a' + 10;
+      else if (digit > 9)
+	break;
+
+      if (digit >= (unsigned long) base)
+	break;
 
       found = 1;
 
diff --git a/grub-core/kern/uboot/init.c b/grub-core/kern/uboot/init.c
index 5dcc106ed9bcc1fa2cdbe2ba6cbb9e709420ceb3..3e338645c573aa707343235029d9fc45d515a9dc 100644
--- a/grub-core/kern/uboot/init.c
+++ b/grub-core/kern/uboot/init.c
@@ -36,30 +36,14 @@
 extern char __bss_start[];
 extern char _end[];
 extern grub_size_t grub_total_module_size;
-extern int (*grub_uboot_syscall_ptr) (int, int *, ...);
 static unsigned long timer_start;
 
-extern grub_uint32_t grub_uboot_machine_type;
-extern grub_addr_t grub_uboot_boot_data;
-
 void
 grub_exit (void)
 {
   grub_uboot_return (0);
 }
 
-grub_uint32_t
-grub_uboot_get_machine_type (void)
-{
-  return grub_uboot_machine_type;
-}
-
-grub_addr_t
-grub_uboot_get_boot_data (void)
-{
-  return grub_uboot_boot_data;
-}
-
 static grub_uint64_t
 uboot_timer_ms (void)
 {
diff --git a/grub-core/kern/uboot/uboot.c b/grub-core/kern/uboot/uboot.c
index 6800a4beb1c4e83ef9f4ac5da872d2557d8471e1..cf0168e62ddd26db50efd2351499fa7f74fce26c 100644
--- a/grub-core/kern/uboot/uboot.c
+++ b/grub-core/kern/uboot/uboot.c
@@ -39,48 +39,13 @@
  * returns:	0 if the call not found, 1 if serviced
  */
 
-extern int (*grub_uboot_syscall_ptr) (int, int *, ...);
 extern int grub_uboot_syscall (int, int *, ...);
-extern grub_addr_t grub_uboot_search_hint;
 
 static struct sys_info uboot_sys_info;
 static struct mem_region uboot_mem_info[5];
 static struct device_info * devices;
 static int num_devices;
 
-int
-grub_uboot_api_init (void)
-{
-  struct api_signature *start, *end;
-  struct api_signature *p;
-
-  if (grub_uboot_search_hint)
-    {
-      /* Extended search range to work around Trim Slice U-Boot issue */
-      start = (struct api_signature *) ((grub_uboot_search_hint & ~0x000fffff)
-					- 0x00500000);
-      end =
-	(struct api_signature *) ((grub_addr_t) start + UBOOT_API_SEARCH_LEN -
-				  API_SIG_MAGLEN + 0x00500000);
-    }
-  else
-    {
-      start = 0;
-      end = (struct api_signature *) (256 * 1024 * 1024);
-    }
-
-  /* Structure alignment is (at least) 8 bytes */
-  for (p = start; p < end; p = (void *) ((grub_addr_t) p + 8))
-    {
-      if (grub_memcmp (&(p->magic), API_SIG_MAGIC, API_SIG_MAGLEN) == 0)
-	{
-	  grub_uboot_syscall_ptr = p->syscall;
-	  return p->version;
-	}
-    }
-
-  return 0;
-}
 
 /*
  * All functions below are wrappers around the grub_uboot_syscall() function
diff --git a/grub-core/lib/crypto.c b/grub-core/lib/crypto.c
index 683a8aaa711c4eab0208d116cd7275a6ac678986..ca334d5a40e0716bdc9afbb79135c47d174532da 100644
--- a/grub-core/lib/crypto.c
+++ b/grub-core/lib/crypto.c
@@ -462,7 +462,7 @@ grub_password_get (char buf[], unsigned buf_size)
       if (key == '\n' || key == '\r')
 	break;
 
-      if (key == '\e')
+      if (key == GRUB_TERM_ESC)
 	{
 	  cur_len = 0;
 	  break;
@@ -487,7 +487,7 @@ grub_password_get (char buf[], unsigned buf_size)
   grub_xputs ("\n");
   grub_refresh ();
 
-  return (key != '\e');
+  return (key != GRUB_TERM_ESC);
 }
 #endif
 
diff --git a/grub-core/lib/uboot/datetime.c b/grub-core/lib/dummy/datetime.c
similarity index 91%
rename from grub-core/lib/uboot/datetime.c
rename to grub-core/lib/dummy/datetime.c
index 4be716928a55b789510dfdcdd1833e29e5cd11fe..cf693fc6b621376b5cae0ca0a74b4421799b5a9e 100644
--- a/grub-core/lib/uboot/datetime.c
+++ b/grub-core/lib/dummy/datetime.c
@@ -18,7 +18,6 @@
 
 #include <grub/types.h>
 #include <grub/symbol.h>
-#include <grub/uboot/uboot.h>
 #include <grub/datetime.h>
 #include <grub/dl.h>
 
@@ -30,12 +29,12 @@ grub_err_t
 grub_get_datetime (struct grub_datetime *datetime __attribute__ ((unused)))
 {
   return grub_error (GRUB_ERR_INVALID_COMMAND,
-		     "can\'t get datetime using U-Boot");
+		     "can\'t get datetime on this machine");
 }
 
 grub_err_t
 grub_set_datetime (struct grub_datetime * datetime __attribute__ ((unused)))
 {
   return grub_error (GRUB_ERR_INVALID_COMMAND,
-		     "can\'t set datetime using U-Boot");
+		     "can\'t set datetime on this machine");
 }
diff --git a/grub-core/lib/uboot/halt.c b/grub-core/lib/dummy/halt.c
similarity index 100%
rename from grub-core/lib/uboot/halt.c
rename to grub-core/lib/dummy/halt.c
diff --git a/grub-core/lib/dummy/reboot.c b/grub-core/lib/dummy/reboot.c
new file mode 100644
index 0000000000000000000000000000000000000000..b8cbed8f8117ca9c53cc2087dee87ae68876d64f
--- /dev/null
+++ b/grub-core/lib/dummy/reboot.c
@@ -0,0 +1,32 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/misc.h>
+#include <grub/mm.h>
+#include <grub/kernel.h>
+#include <grub/loader.h>
+
+void
+grub_reboot (void)
+{
+  grub_machine_fini (GRUB_LOADER_FLAG_NORETURN);
+
+  /* Just stop here */
+
+  while (1);
+}
diff --git a/grub-core/lib/fdt.c b/grub-core/lib/fdt.c
index b5d520f208886aa663d4aac36cec9b43a2d0da42..2705f2629b9d4d1d2b53c34fec9022e991b6ac17 100644
--- a/grub-core/lib/fdt.c
+++ b/grub-core/lib/fdt.c
@@ -102,13 +102,13 @@ static grub_uint32_t *get_next_node (const void *fdt, char *node_name)
 static int get_mem_rsvmap_size (const void *fdt)
 {
   int size = 0;
-  grub_uint64_t *ptr = (void *) ((grub_addr_t) fdt
-                                 + grub_fdt_get_off_mem_rsvmap (fdt));
+  grub_unaligned_uint64_t *ptr = (void *) ((grub_addr_t) fdt
+					   + grub_fdt_get_off_mem_rsvmap (fdt));
 
   do
   {
     size += 2 * sizeof(*ptr);
-    if (!*ptr && !*(ptr + 1))
+    if (!ptr[0].val && !ptr[1].val)
       return size;
     ptr += 2;
   } while ((grub_addr_t) ptr <= (grub_addr_t) fdt + grub_fdt_get_totalsize (fdt)
@@ -229,7 +229,7 @@ static int rearrange_blocks (void *fdt, unsigned int clearance)
   return 0;
 }
 
-static grub_uint32_t *find_prop (void *fdt, unsigned int nodeoffset,
+static grub_uint32_t *find_prop (const void *fdt, unsigned int nodeoffset,
 				 const char *name)
 {
   grub_uint32_t *prop = (void *) ((grub_addr_t) fdt
@@ -268,9 +268,9 @@ static grub_uint32_t *find_prop (void *fdt, unsigned int nodeoffset,
    the size allocated for the FDT; if this function is called before the other
    functions in this file and returns success, the other functions are
    guaranteed not to access memory locations outside the allocated memory. */
-int grub_fdt_check_header_nosize (void *fdt)
+int grub_fdt_check_header_nosize (const void *fdt)
 {
-  if (((grub_addr_t) fdt & 0x7) || (grub_fdt_get_magic (fdt) != FDT_MAGIC)
+  if (((grub_addr_t) fdt & 0x3) || (grub_fdt_get_magic (fdt) != FDT_MAGIC)
       || (grub_fdt_get_version (fdt) < FDT_SUPPORTED_VERSION)
       || (grub_fdt_get_last_comp_version (fdt) > FDT_SUPPORTED_VERSION)
       || (grub_fdt_get_off_dt_struct (fdt) & 0x00000003)
@@ -286,7 +286,7 @@ int grub_fdt_check_header_nosize (void *fdt)
   return 0;
 }
 
-int grub_fdt_check_header (void *fdt, unsigned int size)
+int grub_fdt_check_header (const void *fdt, unsigned int size)
 {
   if (size < sizeof (grub_fdt_header_t)
       || (grub_fdt_get_totalsize (fdt) > size)
@@ -295,52 +295,105 @@ int grub_fdt_check_header (void *fdt, unsigned int size)
   return 0;
 }
 
+static const grub_uint32_t *
+advance_token (const void *fdt, const grub_uint32_t *token, const grub_uint32_t *end, int skip_current)
+{
+  for (; token < end; skip_current = 0)
+  {
+    switch (grub_be_to_cpu32 (*token))
+    {
+      case FDT_BEGIN_NODE:
+	if (skip_current)
+	  {
+	    token = get_next_node (fdt, (char *) (token + 1));
+	    continue;
+	  }
+	char *ptr;
+	for (ptr = (char *) (token + 1); *ptr && ptr < (char *) end; ptr++)
+	  ;
+        if (ptr >= (char *) end)
+          return 0;
+	return token;
+      case FDT_PROP:
+        /* Skip property token and following data (len, nameoff and property
+           value). */
+        if (token >= end - 1)
+          return 0;
+        token += prop_entry_size(grub_be_to_cpu32(*(token + 1)))
+                 / sizeof(*token);
+        break;
+      case FDT_NOP:
+        token++;
+        break;
+      default:
+        return 0;
+    }
+  }
+  return 0;
+}
+
+int grub_fdt_next_node (const void *fdt, unsigned int currentoffset)
+{
+  const grub_uint32_t *token = (const grub_uint32_t *) fdt + (currentoffset + grub_fdt_get_off_dt_struct (fdt)) / 4;
+  token = advance_token (fdt, token, (const void *) struct_end (fdt), 1);
+  if (!token)
+    return -1;
+  return (int) ((grub_addr_t) token - (grub_addr_t) fdt
+		- grub_fdt_get_off_dt_struct (fdt));
+}			 
+
+int grub_fdt_first_node (const void *fdt, unsigned int parentoffset)
+{
+  const grub_uint32_t *token, *end;
+  char *node_name;
+
+  if (parentoffset & 0x3)
+    return -1;
+  token = (const void *) ((grub_addr_t) fdt + grub_fdt_get_off_dt_struct(fdt)
+                    + parentoffset);
+  end = (const void *) struct_end (fdt);
+  if ((token >= end) || (grub_be_to_cpu32(*token) != FDT_BEGIN_NODE))
+    return -1;
+  SKIP_NODE_NAME(node_name, token, end);
+  token = advance_token (fdt, token, end, 0);
+  if (!token)
+    return -1;
+  return (int) ((grub_addr_t) token - (grub_addr_t) fdt
+		- grub_fdt_get_off_dt_struct (fdt));
+}			 
+
 /* Find a direct sub-node of a given parent node. */
 int grub_fdt_find_subnode (const void *fdt, unsigned int parentoffset,
 			   const char *name)
 {
-  grub_uint32_t *token, *end;
-  char *node_name;
+  const grub_uint32_t *token, *end;
+  const char *node_name;
+  int skip_current = 0;
 
   if (parentoffset & 0x3)
     return -1;
-  token = (void *) ((grub_addr_t) fdt + grub_fdt_get_off_dt_struct(fdt)
+  token = (const void *) ((grub_addr_t) fdt + grub_fdt_get_off_dt_struct(fdt)
                     + parentoffset);
-  end = (void *) struct_end (fdt);
+  end = (const void *) struct_end (fdt);
   if ((token >= end) || (grub_be_to_cpu32(*token) != FDT_BEGIN_NODE))
     return -1;
   SKIP_NODE_NAME(node_name, token, end);
-  while (token < end)
-  {
-    switch (grub_be_to_cpu32(*token))
-    {
-      case FDT_BEGIN_NODE:
-        node_name = (char *) (token + 1);
-        if (node_name + grub_strlen (name) >= (char *) end)
-          return -1;
-        if (!grub_strcmp (node_name, name))
-          return (int) ((grub_addr_t) token - (grub_addr_t) fdt
-                        - grub_fdt_get_off_dt_struct (fdt));
-        token = get_next_node (fdt, node_name);
-        if (!token)
-          return -1;
-        break;
-      case FDT_PROP:
-        /* Skip property token and following data (len, nameoff and property
-           value). */
-        if (token >= end - 1)
-          return -1;
-        token += prop_entry_size(grub_be_to_cpu32(*(token + 1)))
-                 / sizeof(*token);
-        break;
-      case FDT_NOP:
-        token++;
-        break;
-      default:
-        return -1;
-    }
+  while (1) {
+    token = advance_token (fdt, token, end, skip_current);
+    if (!token)
+      return -1;
+    skip_current = 1;
+    node_name = (const char *) token + 4;
+    if (grub_strcmp (node_name, name) == 0)
+      return (int) ((grub_addr_t) token - (grub_addr_t) fdt
+		    - grub_fdt_get_off_dt_struct (fdt));
   }
-  return -1;
+}
+
+const char *
+grub_fdt_get_nodename (const void *fdt, unsigned int nodeoffset)
+{
+  return (const char *) fdt + grub_fdt_get_off_dt_struct(fdt) + nodeoffset + 4;
 }
 
 int grub_fdt_add_subnode (void *fdt, unsigned int parentoffset,
@@ -359,6 +412,24 @@ int grub_fdt_add_subnode (void *fdt, unsigned int parentoffset,
   return add_subnode (fdt, parentoffset, name);
 }
 
+const void *
+grub_fdt_get_prop (const void *fdt, unsigned int nodeoffset, const char *name,
+		   grub_uint32_t *len)
+{
+  grub_uint32_t *prop;
+  if ((nodeoffset >= grub_fdt_get_size_dt_struct (fdt)) || (nodeoffset & 0x3)
+      || (grub_be_to_cpu32(*(grub_uint32_t *) ((grub_addr_t) fdt
+					       + grub_fdt_get_off_dt_struct (fdt) + nodeoffset))
+          != FDT_BEGIN_NODE))
+    return 0;
+  prop = find_prop (fdt, nodeoffset, name);
+  if (!prop)
+    return 0;
+  if (len)
+    *len = grub_be_to_cpu32 (*(prop + 1));
+  return prop + 3;
+}
+
 int grub_fdt_set_prop (void *fdt, unsigned int nodeoffset, const char *name,
 		       const void *val, grub_uint32_t len)
 {
diff --git a/grub-core/loader/arm/linux.c b/grub-core/loader/arm/linux.c
index 5b39f02bb2e592d85639891db6eb68a97ce12dfa..e64c79a95774e83dfce7a107a288598c77211935 100644
--- a/grub-core/loader/arm/linux.c
+++ b/grub-core/loader/arm/linux.c
@@ -42,7 +42,7 @@ static grub_size_t linux_size;
 static char *linux_args;
 
 static grub_uint32_t machine_type;
-static void *fdt_addr;
+static const void *current_fdt;
 
 typedef void (*kernel_entry_t) (int, unsigned long, void *);
 
@@ -54,9 +54,9 @@ typedef void (*kernel_entry_t) (int, unsigned long, void *);
 #define LINUX_FDT_PHYS_OFFSET    (LINUX_INITRD_PHYS_OFFSET - 0x10000)
 
 static grub_size_t
-get_atag_size (grub_uint32_t *atag)
+get_atag_size (const grub_uint32_t *atag)
 {
-  grub_uint32_t *atag0 = atag;
+  const grub_uint32_t *atag0 = atag;
   while (atag[0] && atag[1])
     atag += atag[0];
   return atag - atag0;
@@ -68,10 +68,11 @@ get_atag_size (grub_uint32_t *atag)
  *   Merges in command line parameters and sets up initrd addresses.
  */
 static grub_err_t
-linux_prepare_atag (void)
+linux_prepare_atag (void *target_atag)
 {
-  grub_uint32_t *atag_orig = (grub_uint32_t *) fdt_addr;
-  grub_uint32_t *tmp_atag, *from, *to;
+  const grub_uint32_t *atag_orig = (const grub_uint32_t *) current_fdt;
+  grub_uint32_t *tmp_atag, *to;
+  const grub_uint32_t *from;
   grub_size_t tmp_size;
   grub_size_t arg_size = grub_strlen (linux_args);
   char *cmdline_orig = NULL;
@@ -142,7 +143,7 @@ linux_prepare_atag (void)
   to += 2;
 
   /* Copy updated FDT to its launch location */
-  grub_memcpy (atag_orig, tmp_atag, sizeof (grub_uint32_t) * (to - tmp_atag));
+  grub_memcpy (target_atag, tmp_atag, sizeof (grub_uint32_t) * (to - tmp_atag));
   grub_free (tmp_atag);
 
   grub_dprintf ("loader", "ATAG updated for Linux boot\n");
@@ -156,19 +157,19 @@ linux_prepare_atag (void)
  *   Merges in command line parameters and sets up initrd addresses.
  */
 static grub_err_t
-linux_prepare_fdt (void)
+linux_prepare_fdt (void *target_fdt)
 {
   int node;
   int retval;
   int tmp_size;
   void *tmp_fdt;
 
-  tmp_size = grub_fdt_get_totalsize (fdt_addr) + 0x100 + grub_strlen (linux_args);
+  tmp_size = grub_fdt_get_totalsize (current_fdt) + 0x100 + grub_strlen (linux_args);
   tmp_fdt = grub_malloc (tmp_size);
   if (!tmp_fdt)
     return grub_errno;
 
-  grub_memcpy (tmp_fdt, fdt_addr, grub_fdt_get_totalsize (fdt_addr));
+  grub_memcpy (tmp_fdt, current_fdt, grub_fdt_get_totalsize (current_fdt));
   grub_fdt_set_totalsize (tmp_fdt, tmp_size);
 
   /* Find or create '/chosen' node */
@@ -209,7 +210,7 @@ linux_prepare_fdt (void)
     }
 
   /* Copy updated FDT to its launch location */
-  grub_memcpy (fdt_addr, tmp_fdt, tmp_size);
+  grub_memcpy (target_fdt, tmp_fdt, tmp_size);
   grub_free (tmp_fdt);
 
   grub_dprintf ("loader", "FDT updated for Linux boot\n");
@@ -226,16 +227,17 @@ linux_boot (void)
 {
   kernel_entry_t linuxmain;
   int fdt_valid, atag_valid;
+  void *target_fdt = 0;
 
-  fdt_valid = (fdt_addr && grub_fdt_check_header_nosize (fdt_addr) == 0);
-  atag_valid = ((((grub_uint16_t *) fdt_addr)[3] & ~3) == 0x5440
-		&& *((grub_uint32_t *) fdt_addr));
+  fdt_valid = (current_fdt && grub_fdt_check_header_nosize (current_fdt) == 0);
+  atag_valid = ((((const grub_uint16_t *) current_fdt)[3] & ~3) == 0x5440
+		&& *((const grub_uint32_t *) current_fdt));
   grub_dprintf ("loader", "atag: %p, %x, %x, %s, %s\n",
-		fdt_addr,
-		((grub_uint16_t *) fdt_addr)[3],
-		*((grub_uint32_t *) fdt_addr),
-		(char *) fdt_addr,
-		(char *) fdt_addr + 1);
+		current_fdt,
+		((const grub_uint16_t *) current_fdt)[3],
+		*((const grub_uint32_t *) current_fdt),
+		(const char *) current_fdt,
+		(const char *) current_fdt + 1);
 
   if (!fdt_valid && machine_type == GRUB_ARM_MACHINE_TYPE_FDT)
     return grub_error (GRUB_ERR_FILE_NOT_FOUND,
@@ -245,23 +247,40 @@ linux_boot (void)
 
   grub_dprintf ("loader", "Kernel at: 0x%x\n", linux_addr);
 
+  if (fdt_valid || atag_valid)
+    {
+#ifdef GRUB_MACHINE_EFI
+      grub_size_t size;
+      if (fdt_valid)
+	size = grub_fdt_get_totalsize (current_fdt);
+      else
+	size = 4 * get_atag_size (current_fdt);
+      size += grub_strlen (linux_args) + 256;
+      target_fdt = grub_efi_allocate_loader_memory (LINUX_FDT_PHYS_OFFSET, size);
+      if (!target_fdt)
+	return grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
+#else
+      target_fdt = (void *) LINUX_FDT_ADDRESS;
+#endif
+    }
+
   if (fdt_valid)
     {
       grub_err_t err;
 
-      err = linux_prepare_fdt ();
+      err = linux_prepare_fdt (target_fdt);
       if (err)
 	return err;
-      grub_dprintf ("loader", "FDT @ 0x%p\n", fdt_addr);
+      grub_dprintf ("loader", "FDT @ %p\n", target_fdt);
     }
   else if (atag_valid)
     {
       grub_err_t err;
 
-      err = linux_prepare_atag ();
+      err = linux_prepare_atag (target_fdt);
       if (err)
 	return err;
-      grub_dprintf ("loader", "ATAG @ 0x%p\n", fdt_addr);
+      grub_dprintf ("loader", "ATAG @ %p\n", target_fdt);
     }
 
   grub_dprintf ("loader", "Jumping to Linux...\n");
@@ -285,7 +304,7 @@ linux_boot (void)
 
   grub_arm_disable_caches_mmu ();
 
-  linuxmain (0, machine_type, fdt_addr);
+  linuxmain (0, machine_type, target_fdt);
 
   return grub_error (GRUB_ERR_BAD_OS, "Linux call returned");
 }
@@ -444,11 +463,26 @@ fail:
 static grub_err_t
 load_dtb (grub_file_t dtb, int size)
 {
-  if ((grub_file_read (dtb, fdt_addr, size) != size)
-      || (grub_fdt_check_header (fdt_addr, size) != 0))
-    return grub_error (GRUB_ERR_BAD_OS, N_("invalid device tree"));
+  void *new_fdt = grub_zalloc (size);
+  if (!new_fdt)
+    return grub_errno;
+  grub_dprintf ("loader", "Loading device tree to %p\n",
+		new_fdt);
+  if ((grub_file_read (dtb, new_fdt, size) != size)
+      || (grub_fdt_check_header (new_fdt, size) != 0))
+    {
+      grub_free (new_fdt);
+      return grub_error (GRUB_ERR_BAD_OS, N_("invalid device tree"));
+    }
+
+  grub_fdt_set_totalsize (new_fdt, size);
+  current_fdt = new_fdt;
+  /* 
+   * We've successfully loaded an FDT, so any machine type passed
+   * from firmware is now obsolete.
+   */
+  machine_type = GRUB_ARM_MACHINE_TYPE_FDT;
 
-  grub_fdt_set_totalsize (fdt_addr, size);
   return GRUB_ERR_NONE;
 }
 
@@ -464,42 +498,13 @@ grub_cmd_devicetree (grub_command_t cmd __attribute__ ((unused)),
 
   dtb = grub_file_open (argv[0]);
   if (!dtb)
-    goto out;
+    return grub_errno;
 
   size = grub_file_size (dtb);
   if (size == 0)
-    {
-      grub_error (GRUB_ERR_BAD_OS, "empty file");
-      goto out;
-    }
-
-#ifdef GRUB_MACHINE_EFI
-  fdt_addr = grub_efi_allocate_loader_memory (LINUX_FDT_PHYS_OFFSET, size);
-  if (!fdt_addr)
-    {
-      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
-      goto out;
-    }
-#else
-  fdt_addr = (void *) LINUX_FDT_ADDRESS;
-#endif
-
-  grub_dprintf ("loader", "Loading device tree to 0x%08x\n",
-		(grub_addr_t) fdt_addr);
-  load_dtb (dtb, size);
-  if (grub_errno != GRUB_ERR_NONE)
-    {
-      fdt_addr = NULL;
-      goto out;
-    }
-
-  /* 
-   * We've successfully loaded an FDT, so any machine type passed
-   * from firmware is now obsolete.
-   */
-  machine_type = GRUB_ARM_MACHINE_TYPE_FDT;
-
- out:
+    grub_error (GRUB_ERR_BAD_OS, "empty file");
+  else
+    load_dtb (dtb, size);
   grub_file_close (dtb);
 
   return grub_errno;
@@ -517,7 +522,7 @@ GRUB_MOD_INIT (linux)
 					  /* TRANSLATORS: DTB stands for device tree blob.  */
 					  0, N_("Load DTB file."));
   my_mod = mod;
-  fdt_addr = (void *) grub_arm_firmware_get_boot_data ();
+  current_fdt = (const void *) grub_arm_firmware_get_boot_data ();
   machine_type = grub_arm_firmware_get_machine_type ();
 }
 
diff --git a/grub-core/loader/arm64/linux.c b/grub-core/loader/arm64/linux.c
index 9519d2e4d3ec1229a76eb4bce773c78c7af24a6e..746edd1041599eb1bc07f27e5fc2c1cdb23b3c1f 100644
--- a/grub-core/loader/arm64/linux.c
+++ b/grub-core/loader/arm64/linux.c
@@ -26,8 +26,8 @@
 #include <grub/mm.h>
 #include <grub/types.h>
 #include <grub/cpu/linux.h>
-#include <grub/cpu/fdtload.h>
 #include <grub/efi/efi.h>
+#include <grub/efi/fdtload.h>
 #include <grub/efi/pe32.h>
 #include <grub/i18n.h>
 #include <grub/lib/cmdline.h>
@@ -52,13 +52,11 @@ grub_arm64_uefi_check_image (struct grub_arm64_linux_kernel_header * lh)
   if (lh->magic != GRUB_ARM64_LINUX_MAGIC)
     return grub_error(GRUB_ERR_BAD_OS, "invalid magic number");
 
-  if ((lh->code0 & 0xffff) != GRUB_EFI_PE_MAGIC)
+  if ((lh->code0 & 0xffff) != GRUB_PE32_MAGIC)
     return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
 		       N_("plain image kernel not supported - rebuild with CONFIG_(U)EFI_STUB enabled"));
 
   grub_dprintf ("linux", "UEFI stub kernel:\n");
-  grub_dprintf ("linux", "text_offset = 0x%012llx\n",
-		(long long unsigned) lh->text_offset);
   grub_dprintf ("linux", "PE/COFF header @ %08x\n", lh->hdr_offset);
 
   return GRUB_ERR_NONE;
@@ -86,8 +84,8 @@ finalize_params_linux (void)
   /* Set initrd info */
   if (initrd_start && initrd_end > initrd_start)
     {
-      grub_dprintf ("linux", "Initrd @ 0x%012lx-0x%012lx\n",
-		    initrd_start, initrd_end);
+      grub_dprintf ("linux", "Initrd @ %p-%p\n",
+		    (void *) initrd_start, (void *) initrd_end);
 
       retval = grub_fdt_set_prop64 (fdt, node, "linux,initrd-start",
 				    initrd_start);
@@ -148,8 +146,7 @@ grub_arm64_uefi_boot_image (grub_addr_t addr, grub_size_t size, char *args)
   loaded_image->load_options_size = len =
     (grub_strlen (args) + 1) * sizeof (grub_efi_char16_t);
   loaded_image->load_options =
-    grub_efi_allocate_pages (0,
-			     GRUB_EFI_BYTES_TO_PAGES (loaded_image->load_options_size));
+    grub_efi_allocate_any_pages (GRUB_EFI_BYTES_TO_PAGES (loaded_image->load_options_size));
   if (!loaded_image->load_options)
     return grub_errno;
 
@@ -162,7 +159,7 @@ grub_arm64_uefi_boot_image (grub_addr_t addr, grub_size_t size, char *args)
 
   /* When successful, not reached */
   b->unload_image (image_handle);
-  grub_efi_free_pages ((grub_efi_physical_address_t) loaded_image->load_options,
+  grub_efi_free_pages ((grub_addr_t) loaded_image->load_options,
 		       GRUB_EFI_BYTES_TO_PAGES (loaded_image->load_options_size));
 
   return grub_errno;
@@ -189,7 +186,7 @@ grub_linux_unload (void)
   initrd_start = initrd_end = 0;
   grub_free (linux_args);
   if (kernel_addr)
-    grub_efi_free_pages ((grub_efi_physical_address_t) kernel_addr,
+    grub_efi_free_pages ((grub_addr_t) kernel_addr,
 			 GRUB_EFI_BYTES_TO_PAGES (kernel_size));
   grub_fdt_unload ();
   return GRUB_ERR_NONE;
@@ -223,7 +220,7 @@ grub_cmd_initrd (grub_command_t cmd __attribute__ ((unused)),
   grub_dprintf ("linux", "Loading initrd\n");
 
   initrd_pages = (GRUB_EFI_BYTES_TO_PAGES (initrd_size));
-  initrd_mem = grub_efi_allocate_pages (0, initrd_pages);
+  initrd_mem = grub_efi_allocate_any_pages (initrd_pages);
   if (!initrd_mem)
     {
       grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
@@ -241,8 +238,7 @@ grub_cmd_initrd (grub_command_t cmd __attribute__ ((unused)),
  fail:
   grub_initrd_close (&initrd_ctx);
   if (initrd_mem && !initrd_start)
-    grub_efi_free_pages ((grub_efi_physical_address_t) initrd_mem,
-			 initrd_pages);
+    grub_efi_free_pages ((grub_addr_t) initrd_mem, initrd_pages);
 
   return grub_errno;
 }
@@ -277,7 +273,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
   grub_loader_unset();
 
   grub_dprintf ("linux", "kernel file size: %lld\n", (long long) kernel_size);
-  kernel_addr = grub_efi_allocate_pages (0, GRUB_EFI_BYTES_TO_PAGES (kernel_size));
+  kernel_addr = grub_efi_allocate_any_pages (GRUB_EFI_BYTES_TO_PAGES (kernel_size));
   grub_dprintf ("linux", "kernel numpages: %lld\n",
 		(long long) GRUB_EFI_BYTES_TO_PAGES (kernel_size));
   if (!kernel_addr)
@@ -329,7 +325,7 @@ fail:
     grub_free (linux_args);
 
   if (kernel_addr && !loaded)
-    grub_efi_free_pages ((grub_efi_physical_address_t) kernel_addr,
+    grub_efi_free_pages ((grub_addr_t) kernel_addr,
 			 GRUB_EFI_BYTES_TO_PAGES (kernel_size));
 
   return grub_errno;
diff --git a/grub-core/loader/arm64/xen_boot.c b/grub-core/loader/arm64/xen_boot.c
index a914eb8e2df24ebaab41a2eb0ed205bcebafcf5d..c95d6c5a868e37d4cbc923630d154b5422b37525 100644
--- a/grub-core/loader/arm64/xen_boot.c
+++ b/grub-core/loader/arm64/xen_boot.c
@@ -27,9 +27,9 @@
 #include <grub/misc.h>
 #include <grub/mm.h>
 #include <grub/types.h>
-#include <grub/cpu/fdtload.h>
 #include <grub/cpu/linux.h>
 #include <grub/efi/efi.h>
+#include <grub/efi/fdtload.h>
 #include <grub/efi/pe32.h>	/* required by struct xen_hypervisor_header */
 #include <grub/i18n.h>
 #include <grub/lib/cmdline.h>
@@ -156,7 +156,7 @@ prepare_xen_module_params (struct xen_boot_binary *module, void *xen_boot_fdt)
       grub_fdt_add_subnode (xen_boot_fdt, chosen_node, module_name);
 
   retval = grub_fdt_set_prop (xen_boot_fdt, module_node, "compatible",
-			      MODULE_CUSTOM_COMPATIBLE, sizeof(MODULE_CUSTOM_COMPATIBLE) - 1);
+			      MODULE_CUSTOM_COMPATIBLE, sizeof(MODULE_CUSTOM_COMPATIBLE));
   if (retval)
     return grub_error (GRUB_ERR_IO, "failed to update FDT");
 
@@ -324,10 +324,9 @@ xen_boot_binary_load (struct xen_boot_binary *binary, grub_file_t file,
   grub_dprintf ("xen_loader", "Xen_boot file size: 0x%lx\n", binary->size);
 
   binary->start
-    = (grub_addr_t) grub_efi_allocate_pages (0,
-					     GRUB_EFI_BYTES_TO_PAGES
-					     (binary->size +
-					      binary->align));
+    = (grub_addr_t) grub_efi_allocate_any_pages (GRUB_EFI_BYTES_TO_PAGES
+						 (binary->size +
+						  binary->align));
   if (!binary->start)
     {
       grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
@@ -379,6 +378,20 @@ grub_cmd_xen_module (grub_command_t cmd __attribute__((unused)),
 
   struct xen_boot_binary *module = NULL;
   grub_file_t file = 0;
+  int nounzip = 0;
+
+  if (!argc)
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+      goto fail;
+    }
+
+  if (grub_strcmp (argv[0], "--nounzip") == 0)
+    {
+      argv++;
+      argc--;
+      nounzip = 1;
+    }
 
   if (!argc)
     {
@@ -403,6 +416,8 @@ grub_cmd_xen_module (grub_command_t cmd __attribute__((unused)),
 
   grub_dprintf ("xen_loader", "Init module and node info\n");
 
+  if (nounzip)
+    grub_file_filter_disable_compression ();
   file = grub_file_open (argv[0]);
   if (!file)
     goto fail;
diff --git a/grub-core/loader/arm64/fdt.c b/grub-core/loader/efi/fdt.c
similarity index 91%
rename from grub-core/loader/arm64/fdt.c
rename to grub-core/loader/efi/fdt.c
index db49cf64991764686c3f643e5289abbd4874a559..17212c38d0b7496743e0bfc2e081f10cd1a2831f 100644
--- a/grub-core/loader/arm64/fdt.c
+++ b/grub-core/loader/efi/fdt.c
@@ -18,12 +18,12 @@
 
 #include <grub/fdt.h>
 #include <grub/mm.h>
-#include <grub/cpu/fdtload.h>
 #include <grub/err.h>
 #include <grub/dl.h>
 #include <grub/command.h>
 #include <grub/file.h>
 #include <grub/efi/efi.h>
+#include <grub/efi/fdtload.h>
 
 static void *loaded_fdt;
 static void *fdt;
@@ -32,12 +32,12 @@ void *
 grub_fdt_load (grub_size_t additional_size)
 {
   void *raw_fdt;
-  grub_size_t size;
+  unsigned int size;
 
   if (fdt)
     {
       size = GRUB_EFI_BYTES_TO_PAGES (grub_fdt_get_totalsize (fdt));
-      grub_efi_free_pages ((grub_efi_physical_address_t) fdt, size);
+      grub_efi_free_pages ((grub_addr_t) fdt, size);
     }
 
   if (loaded_fdt)
@@ -49,8 +49,8 @@ grub_fdt_load (grub_size_t additional_size)
     raw_fdt ? grub_fdt_get_totalsize (raw_fdt) : GRUB_FDT_EMPTY_TREE_SZ;
   size += additional_size;
 
-  grub_dprintf ("linux", "allocating %ld bytes for fdt\n", size);
-  fdt = grub_efi_allocate_pages (0, GRUB_EFI_BYTES_TO_PAGES (size));
+  grub_dprintf ("linux", "allocating %d bytes for fdt\n", size);
+  fdt = grub_efi_allocate_any_pages (GRUB_EFI_BYTES_TO_PAGES (size));
   if (!fdt)
     return NULL;
 
@@ -88,7 +88,7 @@ grub_fdt_unload (void) {
   if (!fdt) {
     return;
   }
-  grub_efi_free_pages ((grub_efi_physical_address_t) fdt,
+  grub_efi_free_pages ((grub_addr_t) fdt,
 		       GRUB_EFI_BYTES_TO_PAGES (grub_fdt_get_totalsize (fdt)));
   fdt = NULL;
 }
diff --git a/grub-core/loader/ia64/efi/linux.c b/grub-core/loader/ia64/efi/linux.c
index efaa42ccdd2bf74321de20cf5033a80676cc7dc3..750330d4572d0dcd09d02b4b75c1f03045fa897b 100644
--- a/grub-core/loader/ia64/efi/linux.c
+++ b/grub-core/loader/ia64/efi/linux.c
@@ -252,7 +252,7 @@ allocate_pages (grub_uint64_t align, grub_uint64_t size_pages,
 	aligned_start += align;
       if (aligned_start + size > end)
 	continue;
-      mem = grub_efi_allocate_pages (aligned_start, size_pages);
+      mem = grub_efi_allocate_fixed (aligned_start, size_pages);
       if (! mem)
 	{
 	  grub_error (GRUB_ERR_OUT_OF_MEMORY, "cannot allocate memory");
@@ -326,7 +326,7 @@ grub_linux_boot (void)
   mmap_size = find_mmap_size ();
   if (! mmap_size)
     return grub_errno;
-  mmap_buf = grub_efi_allocate_pages (0, page_align (mmap_size) >> 12);
+  mmap_buf = grub_efi_allocate_any_pages (page_align (mmap_size) >> 12);
   if (! mmap_buf)
     return grub_error (GRUB_ERR_IO, "cannot allocate memory map");
   err = grub_efi_finish_boot_services (&mmap_size, mmap_buf, &map_key,
@@ -422,7 +422,7 @@ grub_load_elf64 (grub_file_t file, void *buffer, const char *filename)
   relocate = grub_env_get ("linux_relocate");
   if (!relocate || grub_strcmp (relocate, "force") != 0)
     {
-      kernel_mem = grub_efi_allocate_pages (low_addr, kernel_pages);
+      kernel_mem = grub_efi_allocate_fixed (low_addr, kernel_pages);
       reloc_offset = 0;
     }
   /* Try to relocate.  */
@@ -524,7 +524,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
     len += grub_strlen (argv[i]) + 1;
   len += sizeof (struct ia64_boot_param) + 512; /* Room for extensions.  */
   boot_param_pages = page_align (len) >> 12;
-  boot_param = grub_efi_allocate_pages (0, boot_param_pages);
+  boot_param = grub_efi_allocate_any_pages (boot_param_pages);
   if (boot_param == 0)
     {
       grub_error (GRUB_ERR_OUT_OF_MEMORY,
@@ -589,7 +589,7 @@ grub_cmd_initrd (grub_command_t cmd __attribute__ ((unused)),
   grub_dprintf ("linux", "Loading initrd\n");
 
   initrd_pages = (page_align (initrd_size) >> 12);
-  initrd_mem = grub_efi_allocate_pages (0, initrd_pages);
+  initrd_mem = grub_efi_allocate_any_pages (initrd_pages);
   if (! initrd_mem)
     {
       grub_error (GRUB_ERR_OUT_OF_MEMORY, "cannot allocate pages");
diff --git a/grub-core/net/arp.c b/grub-core/net/arp.c
index 4b68c4151a11db214602f74e111e7552801d8450..54306e3b16d25fe5d3bdf9502683822237be488d 100644
--- a/grub-core/net/arp.c
+++ b/grub-core/net/arp.c
@@ -111,8 +111,8 @@ grub_net_arp_send_request (struct grub_net_network_level_interface *inf,
 }
 
 grub_err_t
-grub_net_arp_receive (struct grub_net_buff *nb,
-		      struct grub_net_card *card)
+grub_net_arp_receive (struct grub_net_buff *nb, struct grub_net_card *card,
+                      grub_uint16_t *vlantag)
 {
   struct arppkt *arp_packet = (struct arppkt *) nb->data;
   grub_net_network_level_address_t sender_addr, target_addr;
@@ -138,6 +138,14 @@ grub_net_arp_receive (struct grub_net_buff *nb,
 
   FOR_NET_NETWORK_LEVEL_INTERFACES (inf)
   {
+    /* Verify vlantag id */
+    if (inf->card == card && inf->vlantag != *vlantag)
+      {
+        grub_dprintf ("net", "invalid vlantag! %x != %x\n",
+                      inf->vlantag, *vlantag);
+        break;
+      }
+
     /* Am I the protocol address target? */
     if (grub_net_addr_cmp (&inf->address, &target_addr) == 0
 	&& arp_packet->op == grub_cpu_to_be16_compile_time (ARP_REQUEST))
diff --git a/grub-core/net/drivers/ieee1275/ofnet.c b/grub-core/net/drivers/ieee1275/ofnet.c
index a78d164db1a0abbaf0417f70dc7180b9b2c4df76..002446be1c385934762824a965806ffb75f422a0 100644
--- a/grub-core/net/drivers/ieee1275/ofnet.c
+++ b/grub-core/net/drivers/ieee1275/ofnet.c
@@ -153,11 +153,11 @@ grub_ieee1275_parse_bootpath (const char *devpath, char *bootpath,
   char *comma_char = 0;
   char *equal_char = 0;
   grub_size_t field_counter = 0;
-
   grub_net_network_level_address_t client_addr, gateway_addr, subnet_mask;
   grub_net_link_level_address_t hw_addr;
   grub_net_interface_flags_t flags = 0;
   struct grub_net_network_level_interface *inter = NULL;
+  grub_uint16_t vlantag = 0;
 
   hw_addr.type = GRUB_NET_LINK_LEVEL_PROTOCOL_ETHERNET;
 
@@ -175,6 +175,11 @@ grub_ieee1275_parse_bootpath (const char *devpath, char *bootpath,
           *equal_char = 0;
           grub_env_set_net_property ((*card)->name, args, equal_char + 1,
                                      grub_strlen(equal_char + 1));
+
+          if ((grub_strcmp (args, "vtag") == 0) &&
+              (grub_strlen (equal_char + 1) == 8))
+            vlantag = grub_strtoul (equal_char + 1 + 4, 0, 16);
+
           *equal_char = '=';
         }
       else
@@ -213,8 +218,10 @@ grub_ieee1275_parse_bootpath (const char *devpath, char *bootpath,
                                   hw_addr.mac, sizeof(hw_addr.mac), 0);
       inter = grub_net_add_addr ((*card)->name, *card, &client_addr, &hw_addr,
                                  flags);
+      inter->vlantag = vlantag;
       grub_net_add_ipv4_local (inter,
                           __builtin_ctz (~grub_le_to_cpu32 (subnet_mask.ipv4)));
+
     }
 
   if (gateway_addr.ipv4 != 0)
diff --git a/grub-core/net/ethernet.c b/grub-core/net/ethernet.c
index c397b1b348ce559070cabe1e0b6e28e4dbf254d8..4d7ceed6f93c7e87019546b544a4365a504f5f9f 100644
--- a/grub-core/net/ethernet.c
+++ b/grub-core/net/ethernet.c
@@ -18,6 +18,7 @@
 
 #include <grub/misc.h>
 #include <grub/mm.h>
+#include <grub/env.h>
 #include <grub/net/ethernet.h>
 #include <grub/net/ip.h>
 #include <grub/net/arp.h>
@@ -56,10 +57,17 @@ send_ethernet_packet (struct grub_net_network_level_interface *inf,
 {
   struct etherhdr *eth;
   grub_err_t err;
+  grub_uint8_t etherhdr_size;
+  grub_uint16_t vlantag_id = VLANTAG_IDENTIFIER;
 
-  COMPILE_TIME_ASSERT (sizeof (*eth) < GRUB_NET_MAX_LINK_HEADER_SIZE);
+  etherhdr_size = sizeof (*eth);
+  COMPILE_TIME_ASSERT (sizeof (*eth) + 4 < GRUB_NET_MAX_LINK_HEADER_SIZE);
 
-  err = grub_netbuff_push (nb, sizeof (*eth));
+  /* Increase ethernet header in case of vlantag */
+  if (inf->vlantag != 0)
+    etherhdr_size += 4;
+
+  err = grub_netbuff_push (nb, etherhdr_size);
   if (err)
     return err;
   eth = (struct etherhdr *) nb->data;
@@ -76,6 +84,19 @@ send_ethernet_packet (struct grub_net_network_level_interface *inf,
 	return err;
       inf->card->opened = 1;
     }
+
+  /* Check and add a vlan-tag if needed. */
+  if (inf->vlantag != 0)
+    {
+      /* Move eth type to the right */
+      grub_memcpy ((char *) nb->data + etherhdr_size - 2,
+                   (char *) nb->data + etherhdr_size - 6, 2);
+
+      /* Add the tag in the middle */
+      grub_memcpy ((char *) nb->data + etherhdr_size - 6, &vlantag_id, 2);
+      grub_memcpy ((char *) nb->data + etherhdr_size - 4, (char *) &(inf->vlantag), 2);
+    }
+
   return inf->card->driver->send (inf->card, nb);
 }
 
@@ -90,10 +111,25 @@ grub_net_recv_ethernet_packet (struct grub_net_buff *nb,
   grub_net_link_level_address_t hwaddress;
   grub_net_link_level_address_t src_hwaddress;
   grub_err_t err;
+  grub_uint8_t etherhdr_size = sizeof (*eth);
+  grub_uint16_t vlantag = 0;
+
+
+  /* Check if a vlan-tag is present. If so, the ethernet header is 4 bytes */
+  /* longer than the original one. The vlantag id is extracted and the header */
+  /* is reseted to the original size. */
+  if (grub_get_unaligned16 (nb->data + etherhdr_size - 2) == VLANTAG_IDENTIFIER)
+    {
+      vlantag = grub_get_unaligned16 (nb->data + etherhdr_size);
+      etherhdr_size += 4;
+      /* Move eth type to the original position */
+      grub_memcpy((char *) nb->data + etherhdr_size - 6,
+                  (char *) nb->data + etherhdr_size - 2, 2);
+    }
 
   eth = (struct etherhdr *) nb->data;
   type = grub_be_to_cpu16 (eth->type);
-  err = grub_netbuff_pull (nb, sizeof (*eth));
+  err = grub_netbuff_pull (nb, etherhdr_size);
   if (err)
     return err;
 
@@ -121,13 +157,14 @@ grub_net_recv_ethernet_packet (struct grub_net_buff *nb,
     {
       /* ARP packet. */
     case GRUB_NET_ETHERTYPE_ARP:
-      grub_net_arp_receive (nb, card);
+      grub_net_arp_receive (nb, card, &vlantag);
       grub_netbuff_free (nb);
       return GRUB_ERR_NONE;
       /* IP packet.  */
     case GRUB_NET_ETHERTYPE_IP:
     case GRUB_NET_ETHERTYPE_IP6:
-      return grub_net_recv_ip_packets (nb, card, &hwaddress, &src_hwaddress);
+      return grub_net_recv_ip_packets (nb, card, &hwaddress, &src_hwaddress,
+                                       &vlantag);
     }
   grub_netbuff_free (nb);
   return GRUB_ERR_NONE;
diff --git a/grub-core/net/ip.c b/grub-core/net/ip.c
index aba4f89087bc14b1fe28a77794dd6792beb0bf36..7c95cc7464a09af4b223c94d6653a03f0dbee062 100644
--- a/grub-core/net/ip.c
+++ b/grub-core/net/ip.c
@@ -228,12 +228,13 @@ handle_dgram (struct grub_net_buff *nb,
 	      grub_net_ip_protocol_t proto,
 	      const grub_net_network_level_address_t *source,
 	      const grub_net_network_level_address_t *dest,
+              grub_uint16_t *vlantag,
 	      grub_uint8_t ttl)
 {
   struct grub_net_network_level_interface *inf = NULL;
   grub_err_t err;
   int multicast = 0;
-  
+
   /* DHCP needs special treatment since we don't know IP yet.  */
   {
     struct udphdr *udph;
@@ -293,6 +294,15 @@ handle_dgram (struct grub_net_buff *nb,
 	&& grub_net_addr_cmp (&inf->address, dest) == 0
 	&& grub_net_hwaddr_cmp (&inf->hwaddress, hwaddress) == 0)
       break;
+
+    /* Verify vlantag id */
+    if (inf->card == card && inf->vlantag != *vlantag)
+      {
+        grub_dprintf ("net", "invalid vlantag! %x != %x\n",
+                      inf->vlantag, *vlantag);
+        break;
+      }
+
     /* Solicited node multicast.  */
     if (inf->card == card
 	&& inf->address.type == GRUB_NET_NETWORK_LEVEL_PROTOCOL_IPV6
@@ -383,7 +393,8 @@ static grub_err_t
 grub_net_recv_ip4_packets (struct grub_net_buff *nb,
 			   struct grub_net_card *card,
 			   const grub_net_link_level_address_t *hwaddress,
-			   const grub_net_link_level_address_t *src_hwaddress)
+			   const grub_net_link_level_address_t *src_hwaddress,
+                           grub_uint16_t *vlantag)
 {
   struct iphdr *iph = (struct iphdr *) nb->data;
   grub_err_t err;
@@ -458,7 +469,7 @@ grub_net_recv_ip4_packets (struct grub_net_buff *nb,
       dest.ipv4 = iph->dest;
 
       return handle_dgram (nb, card, src_hwaddress, hwaddress, iph->protocol,
-			   &source, &dest, iph->ttl);
+			   &source, &dest, vlantag, iph->ttl);
     }
 
   for (prev = &reassembles, rsm = *prev; rsm; prev = &rsm->next, rsm = *prev)
@@ -594,7 +605,7 @@ grub_net_recv_ip4_packets (struct grub_net_buff *nb,
       dest.ipv4 = dst;
 
       return handle_dgram (ret, card, src_hwaddress,
-			   hwaddress, proto, &source, &dest,
+			   hwaddress, proto, &source, &dest, vlantag,
 			   ttl);
     }
 }
@@ -652,7 +663,8 @@ static grub_err_t
 grub_net_recv_ip6_packets (struct grub_net_buff *nb,
 			   struct grub_net_card *card,
 			   const grub_net_link_level_address_t *hwaddress,
-			   const grub_net_link_level_address_t *src_hwaddress)
+			   const grub_net_link_level_address_t *src_hwaddress,
+                           grub_uint16_t *vlantag)
 {
   struct ip6hdr *iph = (struct ip6hdr *) nb->data;
   grub_err_t err;
@@ -703,21 +715,24 @@ grub_net_recv_ip6_packets (struct grub_net_buff *nb,
   grub_memcpy (dest.ipv6, &iph->dest, sizeof (dest.ipv6));
 
   return handle_dgram (nb, card, src_hwaddress, hwaddress, iph->protocol,
-		       &source, &dest, iph->ttl);
+		       &source, &dest, vlantag, iph->ttl);
 }
 
 grub_err_t
 grub_net_recv_ip_packets (struct grub_net_buff *nb,
 			  struct grub_net_card *card,
 			  const grub_net_link_level_address_t *hwaddress,
-			  const grub_net_link_level_address_t *src_hwaddress)
+			  const grub_net_link_level_address_t *src_hwaddress,
+                          grub_uint16_t *vlantag)
 {
   struct iphdr *iph = (struct iphdr *) nb->data;
 
   if ((iph->verhdrlen >> 4) == 4)
-    return grub_net_recv_ip4_packets (nb, card, hwaddress, src_hwaddress);
+    return grub_net_recv_ip4_packets (nb, card, hwaddress, src_hwaddress,
+                                      vlantag);
   if ((iph->verhdrlen >> 4) == 6)
-    return grub_net_recv_ip6_packets (nb, card, hwaddress, src_hwaddress);
+    return grub_net_recv_ip6_packets (nb, card, hwaddress, src_hwaddress,
+                                      vlantag);
   grub_dprintf ("net", "Bad IP version: %d\n", (iph->verhdrlen >> 4));
   grub_netbuff_free (nb);
   return GRUB_ERR_NONE;
diff --git a/grub-core/normal/auth.c b/grub-core/normal/auth.c
index 7338f8245e3a9bbe47e821fb43c2b699b9527ffb..6be678c0de1ac236b60f765e767ae43d113b1117 100644
--- a/grub-core/normal/auth.c
+++ b/grub-core/normal/auth.c
@@ -166,13 +166,13 @@ grub_username_get (char buf[], unsigned buf_size)
       if (key == '\n' || key == '\r')
 	break;
 
-      if (key == '\e')
+      if (key == GRUB_TERM_ESC)
 	{
 	  cur_len = 0;
 	  break;
 	}
 
-      if (key == '\b')
+      if (key == GRUB_TERM_BACKSPACE)
 	{
 	  if (cur_len)
 	    {
@@ -197,7 +197,7 @@ grub_username_get (char buf[], unsigned buf_size)
   grub_xputs ("\n");
   grub_refresh ();
 
-  return (key != '\e');
+  return (key != GRUB_TERM_ESC);
 }
 
 grub_err_t
diff --git a/grub-core/normal/cmdline.c b/grub-core/normal/cmdline.c
index a36180d75305f421e96903a46acb9dd99af06572..c037d5050ed2b34fa3b2ac0c7564e4208ca143c4 100644
--- a/grub-core/normal/cmdline.c
+++ b/grub-core/normal/cmdline.c
@@ -626,12 +626,12 @@ grub_cmdline_get (const char *prompt_translated)
 	    cl_insert (cl_terms, nterms, &lpos, &llen, &max_len, &buf, kill_buf);
 	  break;
 
-	case '\e':
+	case GRUB_TERM_ESC:
 	  grub_free (cl_terms);
 	  grub_free (buf);
 	  return 0;
 
-	case '\b':
+	case GRUB_TERM_BACKSPACE:
 	  if (lpos > 0)
 	    {
 	      lpos--;
diff --git a/grub-core/normal/crypto.c b/grub-core/normal/crypto.c
index 2bfd67c8ef388097701a7415df3cd7321c6a1e57..e6d345f33458a167e703235d611afdd8c2a245b0 100644
--- a/grub-core/normal/crypto.c
+++ b/grub-core/normal/crypto.c
@@ -147,8 +147,8 @@ read_crypto_list (const char *prefix)
       if (! cur->modname)
 	{
 	  grub_errno = GRUB_ERR_NONE;
-	  grub_free (cur);
 	  grub_free (cur->name);
+	  grub_free (cur);
 	  continue;
 	}
       cur->next = crypto_specs;
diff --git a/grub-core/normal/menu.c b/grub-core/normal/menu.c
index 719e2fb1c260b16d96cea2b787d7f7e592b428b7..e7a83c2d6e2aaa8248ed739b28f2c6be76622eb4 100644
--- a/grub-core/normal/menu.c
+++ b/grub-core/normal/menu.c
@@ -763,7 +763,7 @@ run_menu (grub_menu_t menu, int nested, int *auto_boot)
               *auto_boot = 0;
 	      return current_entry;
 
-	    case '\e':
+	    case GRUB_TERM_ESC:
 	      if (nested)
 		{
 		  menu_fini ();
diff --git a/grub-core/normal/menu_entry.c b/grub-core/normal/menu_entry.c
index eeeee5580abea9798278ef85cf417366cf4f0e0a..cdf3590a3646ce4be0caf99cafedcbc38cbe51e4 100644
--- a/grub-core/normal/menu_entry.c
+++ b/grub-core/normal/menu_entry.c
@@ -1403,7 +1403,7 @@ grub_menu_entry_run (grub_menu_entry_t entry)
 	    goto fail;
 	  break;
 
-	case '\e':
+	case GRUB_TERM_ESC:
 	  destroy_screen (screen);
 	  return;
 
diff --git a/grub-core/osdep/linux/ofpath.c b/grub-core/osdep/linux/ofpath.c
index a79682a5e31e1b4e77d9b99f55cc5a1fca9e159b..dce4e59d08184b4d712f38423612df1ff200b1d6 100644
--- a/grub-core/osdep/linux/ofpath.c
+++ b/grub-core/osdep/linux/ofpath.c
@@ -120,6 +120,8 @@ find_obppath (const char *sysfs_path_orig)
 #endif
 
       fd = open(path, O_RDONLY);
+
+#ifndef __sparc__
       if (fd < 0 || fstat (fd, &st) < 0)
 	{
 	  if (fd >= 0)
@@ -127,6 +129,7 @@ find_obppath (const char *sysfs_path_orig)
 	  snprintf(path, path_size, "%s/devspec", sysfs_path);
 	  fd = open(path, O_RDONLY);
 	}
+#endif
 
       if (fd < 0 || fstat (fd, &st) < 0)
 	{
diff --git a/grub-core/osdep/unix/hostdisk.c b/grub-core/osdep/unix/hostdisk.c
index 2a8c5882e3d10b98bc305a116f8cca06acfe89f5..5450cf4166e04c2cfab806e93dfa63c6abdb9698 100644
--- a/grub-core/osdep/unix/hostdisk.c
+++ b/grub-core/osdep/unix/hostdisk.c
@@ -77,11 +77,19 @@ grub_util_get_fd_size (grub_util_fd_t fd, const char *name, unsigned *log_secsiz
 int
 grub_util_fd_seek (grub_util_fd_t fd, grub_uint64_t off)
 {
+#if SIZEOF_OFF_T == 8
   off_t offset = (off_t) off;
 
   if (lseek (fd, offset, SEEK_SET) != offset)
     return -1;
+#elif SIZEOF_OFF64_T == 8
+  off64_t offset = (off64_t) off;
 
+  if (lseek64 (fd, offset, SEEK_SET) != offset)
+    return -1;
+#else
+#error "No large file support"
+#endif
   return 0;
 }
 
diff --git a/grub-core/term/arm/cros.c b/grub-core/term/arm/cros.c
new file mode 100644
index 0000000000000000000000000000000000000000..1ff9f8ccfb8270884ba962a05ca99df4c6ed1f41
--- /dev/null
+++ b/grub-core/term/arm/cros.c
@@ -0,0 +1,125 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *
+ *  Copyright (C) 2012  Google Inc.
+ *  Copyright (C) 2016  Free Software Foundation, Inc.
+ *
+ *  This is based on depthcharge code.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/ps2.h>
+#include <grub/fdtbus.h>
+#include <grub/err.h>
+#include <grub/machine/kernel.h>
+#include <grub/misc.h>
+#include <grub/term.h>
+#include <grub/time.h>
+#include <grub/fdtbus.h>
+#include <grub/arm/cros_ec.h>
+
+struct grub_ps2_state ps2_state;
+
+struct grub_cros_ec_keyscan old_scan;
+
+static const struct grub_fdtbus_dev *cros_ec;
+
+static grub_uint8_t map_code[GRUB_CROS_EC_KEYSCAN_COLS][GRUB_CROS_EC_KEYSCAN_ROWS];
+
+static grub_uint8_t e0_translate[16] =
+  {
+    0x1c, 0x1d, 0x35, 0x00,
+    0x38, 0x00, 0x47, 0x48,
+    0x49, 0x4b, 0x4d, 0x4f,
+    0x50, 0x51, 0x52, 0x53,
+  };
+
+/* If there is a character pending, return it;
+   otherwise return GRUB_TERM_NO_KEY.  */
+static int
+grub_cros_keyboard_getkey (struct grub_term_input *term __attribute__ ((unused)))
+{
+  struct grub_cros_ec_keyscan scan;
+  int i, j;
+  if (grub_cros_ec_scan_keyboard (cros_ec, &scan) < 0)
+    return GRUB_TERM_NO_KEY;
+  for (i = 0; i < GRUB_CROS_EC_KEYSCAN_COLS; i++)
+    if (scan.data[i] ^ old_scan.data[i])
+      for (j = 0; j < GRUB_CROS_EC_KEYSCAN_ROWS; j++)
+	if ((scan.data[i] ^ old_scan.data[i]) & (1 << j))
+	  {
+	    grub_uint8_t code = map_code[i][j];
+	    int ret;
+	    grub_uint8_t brk = 0;
+	    if (!(scan.data[i] & (1 << j)))
+	      brk = 0x80;
+	    grub_dprintf ("cros_keyboard", "key <%d, %d> code %x\n", i, j, code);
+	    if (code < 0x60)
+	      ret = grub_ps2_process_incoming_byte (&ps2_state, code | brk);
+	    else if (code >= 0x60 && code < 0x70 && e0_translate[code - 0x60])
+	      {
+		grub_ps2_process_incoming_byte (&ps2_state, 0xe0);
+		ret = grub_ps2_process_incoming_byte (&ps2_state, e0_translate[code - 0x60] | brk);
+	      }
+	    else
+	      ret = GRUB_TERM_NO_KEY;
+	    old_scan.data[i] ^= (1 << j);
+	    if (ret != GRUB_TERM_NO_KEY)
+	      return ret;
+	  }
+  return GRUB_TERM_NO_KEY;
+}
+
+static struct grub_term_input grub_cros_keyboard_term =
+  {
+    .name = "cros_keyboard",
+    .getkey = grub_cros_keyboard_getkey
+  };
+
+static grub_err_t
+cros_attach (const struct grub_fdtbus_dev *dev)
+{
+  grub_size_t keymap_size, i;
+  const grub_uint8_t *keymap = grub_fdtbus_get_prop (dev, "linux,keymap", &keymap_size);
+
+  if (!dev->parent || !grub_cros_ec_validate (dev->parent))
+    return GRUB_ERR_IO;
+
+  if (keymap)
+    {
+      for (i = 0; i + 3 < keymap_size; i += 4)
+	if (keymap[i+1] < GRUB_CROS_EC_KEYSCAN_COLS && keymap[i] < GRUB_CROS_EC_KEYSCAN_ROWS
+	    && keymap[i+2] == 0 && keymap[i+3] < 0x80)
+	  map_code[keymap[i+1]][keymap[i]] = keymap[i+3];
+    }
+
+  cros_ec = dev->parent;
+  ps2_state.current_set = 1;
+  ps2_state.at_keyboard_status = 0;
+  grub_term_register_input ("cros_keyboard", &grub_cros_keyboard_term);
+  return GRUB_ERR_NONE;
+}
+
+static struct grub_fdtbus_driver cros =
+{
+  .compatible = "google,cros-ec-keyb",
+  .attach = cros_attach
+};
+
+void
+grub_cros_init (void)
+{
+  grub_fdtbus_register (&cros);
+}
diff --git a/grub-core/term/arm/cros_ec.c b/grub-core/term/arm/cros_ec.c
new file mode 100644
index 0000000000000000000000000000000000000000..f4144818b5bfdb9a512316ccc321586d539653ac
--- /dev/null
+++ b/grub-core/term/arm/cros_ec.c
@@ -0,0 +1,238 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *
+ *  Copyright (C) 2012  Google Inc.
+ *  Copyright (C) 2016  Free Software Foundation, Inc.
+ *
+ *  This is based on depthcharge code.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/mm.h>
+#include <grub/time.h>
+#include <grub/misc.h>
+#include <grub/arm/cros_ec.h>
+#include <grub/fdtbus.h>
+
+static const grub_uint64_t FRAMING_TIMEOUT_MS = 300;
+
+static const grub_uint8_t EC_FRAMING_BYTE = 0xec;
+
+#define EC_CMD_MKBP_STATE 0x60
+#define EC_CMD_VERSION0 0xdc
+
+static grub_uint64_t last_transfer;
+
+static void
+stop_bus (const struct grub_fdtbus_dev *spi)
+{
+  spi->driver->stop (spi);
+  last_transfer = grub_get_time_ms ();
+}
+
+static int
+wait_for_frame (const struct grub_fdtbus_dev *spi)
+{
+  grub_uint64_t start = grub_get_time_ms ();
+  grub_uint8_t byte;
+  do
+    {
+      if (spi->driver->receive (spi, &byte, 1))
+	return -1;
+      if (byte != EC_FRAMING_BYTE &&
+	  grub_get_time_ms () - start > FRAMING_TIMEOUT_MS)
+	{
+	  grub_dprintf ("cros", "Timeout waiting for framing byte.\n");
+	  return -1;
+	}
+    }
+  while (byte != EC_FRAMING_BYTE);
+  return 0;
+}
+
+/*
+ * Calculate a simple 8-bit checksum of a data block
+ *
+ * @param data	Data block to checksum
+ * @param size	Size of data block in bytes
+ * @return checksum value (0 to 255)
+ */
+static grub_uint8_t
+cros_ec_calc_checksum (const void *data, int size)
+{
+  grub_uint8_t csum;
+  const grub_uint8_t *bytes = data;
+  int i;
+
+  for (i = csum = 0; i < size; i++)
+    csum += bytes[i];
+  return csum & 0xff;
+}
+
+enum
+{
+  /* response, arglen */
+  CROS_EC_SPI_IN_HDR_SIZE = 2,
+  /* version, cmd, arglen */
+  CROS_EC_SPI_OUT_HDR_SIZE = 3
+};
+
+static grub_uint8_t busbuf[256];
+#define MSG_BYTES ((int)sizeof (busbuf))
+
+static int
+ec_command (const struct grub_fdtbus_dev *dev, int cmd, int cmd_version,
+	    const void *dout, int dout_len, void *din, int din_len)
+{
+  const struct grub_fdtbus_dev *spi = dev->parent;
+  grub_uint8_t *bytes;
+
+  /* Header + data + checksum. */
+  grub_uint32_t out_bytes = CROS_EC_SPI_OUT_HDR_SIZE + dout_len + 1;
+  grub_uint32_t in_bytes = CROS_EC_SPI_IN_HDR_SIZE + din_len + 1;
+
+  /*
+   * Sanity-check I/O sizes given transaction overhead in internal
+   * buffers.
+   */
+  if (out_bytes > MSG_BYTES)
+    {
+      grub_dprintf ("cros", "Cannot send %d bytes\n", dout_len);
+      return -1;
+    }
+  if (in_bytes > MSG_BYTES)
+    {
+      grub_dprintf ("cros", "Cannot receive %d bytes\n", din_len);
+      return -1;
+    }
+
+  /* Prepare the output. */
+  bytes = busbuf;
+  *bytes++ = EC_CMD_VERSION0 + cmd_version;
+  *bytes++ = cmd;
+  *bytes++ = dout_len;
+  grub_memcpy (bytes, dout, dout_len);
+  bytes += dout_len;
+
+  *bytes++ = cros_ec_calc_checksum (busbuf,
+				    CROS_EC_SPI_OUT_HDR_SIZE + dout_len);
+
+  /* Depthcharge uses 200 us here but GRUB timer resolution is only 1ms,
+     decrease this when we increase timer resolution.  */
+  while (grub_get_time_ms () - last_transfer < 1)
+    ;
+
+  if (spi->driver->start (spi))
+    return -1;
+
+  /* Allow EC to ramp up clock after being awoken. */
+  /* Depthcharge only waits 100 us here but GRUB timer resolution is only 1ms,
+     decrease this when we increase timer resolution.  */
+  grub_millisleep (1);
+
+  if (spi->driver->send (spi, busbuf, out_bytes))
+    {
+      stop_bus (spi);
+      return -1;
+    }
+
+  /* Wait until the EC is ready. */
+  if (wait_for_frame (spi))
+    {
+      stop_bus (spi);
+      return -1;
+    }
+
+  /* Read the response code and the data length. */
+  bytes = busbuf;
+  if (spi->driver->receive (spi, bytes, 2))
+    {
+      stop_bus (spi);
+      return -1;
+    }
+  grub_uint8_t result = *bytes++;
+  grub_uint8_t length = *bytes++;
+
+  /* Make sure there's enough room for the data. */
+  if (CROS_EC_SPI_IN_HDR_SIZE + length + 1 > MSG_BYTES)
+    {
+      grub_dprintf ("cros", "Received length %#02x too large\n", length);
+      stop_bus (spi);
+      return -1;
+    }
+
+  /* Read the data and the checksum, and finish up. */
+  if (spi->driver->receive (spi, bytes, length + 1))
+    {
+      stop_bus (spi);
+      return -1;
+    }
+  bytes += length;
+  int expected = *bytes++;
+  stop_bus (spi);
+
+  /* Check the integrity of the response. */
+  if (result != 0)
+    {
+      grub_dprintf ("cros", "Received bad result code %d\n", result);
+      return -result;
+    }
+
+  int csum = cros_ec_calc_checksum (busbuf,
+				    CROS_EC_SPI_IN_HDR_SIZE + length);
+
+  if (csum != expected)
+    {
+      grub_dprintf ("cros", "Invalid checksum rx %#02x, calced %#02x\n",
+		    expected, csum);
+      return -1;
+    }
+
+  /* If the caller wants the response, copy it out for them. */
+  if (length < din_len)
+    din_len = length;
+  if (din)
+    {
+      grub_memcpy (din, (grub_uint8_t *) busbuf + CROS_EC_SPI_IN_HDR_SIZE, din_len);
+    }
+
+  return din_len;
+}
+
+int
+grub_cros_ec_scan_keyboard (const struct grub_fdtbus_dev *dev, struct grub_cros_ec_keyscan *scan)
+{
+  if (ec_command (dev, EC_CMD_MKBP_STATE, 0, NULL, 0, scan,
+		  sizeof (*scan)) < (int) sizeof (*scan))
+    return -1;
+
+  return 0;
+}
+
+int
+grub_cros_ec_validate (const struct grub_fdtbus_dev *dev)
+{
+  if (!grub_fdtbus_is_compatible("google,cros-ec-spi", dev))
+    return 0;
+  if (!dev->parent)
+    return 0;
+  if (!dev->parent->driver)
+    return 0;
+  if (!dev->parent->driver->send
+      || !dev->parent->driver->receive)
+    return 0;
+  return 1;
+}
+
diff --git a/grub-core/term/arm/pl050.c b/grub-core/term/arm/pl050.c
new file mode 100644
index 0000000000000000000000000000000000000000..e4cda305666df20eba26e10d74b879361e83d6ea
--- /dev/null
+++ b/grub-core/term/arm/pl050.c
@@ -0,0 +1,189 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2007,2008,2009  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/ps2.h>
+#include <grub/fdtbus.h>
+#include <grub/err.h>
+#include <grub/machine/kernel.h>
+#include <grub/at_keyboard.h>
+#include <grub/misc.h>
+#include <grub/term.h>
+#include <grub/time.h>
+#include <grub/ps2.h>
+#include <grub/fdtbus.h>
+
+static volatile grub_uint32_t *pl050_regs;
+
+struct grub_ps2_state ps2_state;
+
+static void
+keyboard_controller_wait_until_ready (void)
+{
+  while (! (pl050_regs[1] & 0x40));
+}
+
+static grub_uint8_t
+wait_ack (void)
+{
+  grub_uint64_t endtime;
+  grub_uint8_t ack;
+
+  endtime = grub_get_time_ms () + 20;
+  do
+    ack = pl050_regs[2];
+  while (ack != GRUB_AT_ACK && ack != GRUB_AT_NACK
+	 && grub_get_time_ms () < endtime);
+  return ack;
+}
+
+
+static int
+write_mode (int mode)
+{
+  unsigned i;
+  for (i = 0; i < GRUB_AT_TRIES; i++)
+    {
+      grub_uint8_t ack;
+      keyboard_controller_wait_until_ready ();
+      pl050_regs[2] = 0xf0;
+      keyboard_controller_wait_until_ready ();
+      pl050_regs[2] = mode;
+      keyboard_controller_wait_until_ready ();
+      ack = wait_ack ();
+      if (ack == GRUB_AT_NACK)
+	continue;
+      if (ack == GRUB_AT_ACK)
+	break;
+      return 0;
+    }
+
+  return (i != GRUB_AT_TRIES);
+}
+
+static int
+query_mode (void)
+{
+  grub_uint8_t ret;
+  int e;
+
+  e = write_mode (0);
+  if (!e)
+    return 0;
+
+  keyboard_controller_wait_until_ready ();
+
+  do
+    ret = pl050_regs[2];
+  while (ret == GRUB_AT_ACK);
+
+  /* QEMU translates the set even in no-translate mode.  */
+  if (ret == 0x43 || ret == 1)
+    return 1;
+  if (ret == 0x41 || ret == 2)
+    return 2;
+  if (ret == 0x3f || ret == 3)
+    return 3;
+  return 0;
+}
+
+static void
+set_scancodes (void)
+{
+  write_mode (2);
+  ps2_state.current_set = query_mode ();
+  grub_dprintf ("atkeyb", "returned set %d\n", ps2_state.current_set);
+  if (ps2_state.current_set == 2)
+    return;
+
+  write_mode (1);
+  ps2_state.current_set = query_mode ();
+  grub_dprintf ("atkeyb", "returned set %d\n", ps2_state.current_set);
+  if (ps2_state.current_set == 1)
+    return;
+  grub_dprintf ("atkeyb", "no supported scancode set found\n");
+}
+
+static void
+keyboard_controller_led (grub_uint8_t leds)
+{
+  keyboard_controller_wait_until_ready ();
+  pl050_regs[2] = 0xed;
+  keyboard_controller_wait_until_ready ();
+  pl050_regs[2] = leds & 0x7;
+}
+
+/* If there is a character pending, return it;
+   otherwise return GRUB_TERM_NO_KEY.  */
+static int
+grub_pl050_keyboard_getkey (struct grub_term_input *term __attribute__ ((unused)))
+{
+  grub_uint8_t at_key;
+  int ret;
+  grub_uint8_t old_led;
+
+  if (!(pl050_regs[1] & 0x10))
+    return -1;
+  at_key = pl050_regs[2];
+  old_led = ps2_state.led_status;
+
+  ret = grub_ps2_process_incoming_byte (&ps2_state, at_key);
+  if (old_led != ps2_state.led_status)
+    keyboard_controller_led (ps2_state.led_status);
+  return ret;
+}
+
+static struct grub_term_input grub_pl050_keyboard_term =
+  {
+    .name = "pl050_keyboard",
+    .getkey = grub_pl050_keyboard_getkey
+  };
+
+static grub_err_t
+pl050_attach(const struct grub_fdtbus_dev *dev)
+{
+  const grub_uint32_t *reg;
+  reg = grub_fdtbus_get_prop (dev, "reg", 0);
+
+  /* Mouse.  Nothing to do.  */
+  if (grub_be_to_cpu32 (*reg) == 0x7000)
+    return 0;
+
+  pl050_regs = grub_fdtbus_map_reg (dev, 0, 0);
+
+  if (!grub_fdtbus_is_mapping_valid (pl050_regs))
+    return grub_error (GRUB_ERR_IO, "could not map pl050");
+
+  ps2_state.at_keyboard_status = 0;
+  set_scancodes ();
+  keyboard_controller_led (ps2_state.led_status);
+
+  grub_term_register_input ("pl050_keyboard", &grub_pl050_keyboard_term);
+  return GRUB_ERR_NONE;
+}
+
+struct grub_fdtbus_driver pl050 =
+{
+  .compatible = "arm,pl050",
+  .attach = pl050_attach
+};
+
+void
+grub_pl050_init (void)
+{
+  grub_fdtbus_register (&pl050);
+}
diff --git a/grub-core/term/at_keyboard.c b/grub-core/term/at_keyboard.c
index b4ea9ff7e637f59c653b86cea79d4d664c78af84..f0a986eb176aef6c4fe3f5a65c646756e5bbde56 100644
--- a/grub-core/term/at_keyboard.c
+++ b/grub-core/term/at_keyboard.c
@@ -22,215 +22,26 @@
 #include <grub/cpu/io.h>
 #include <grub/misc.h>
 #include <grub/term.h>
-#include <grub/keyboard_layouts.h>
 #include <grub/time.h>
 #include <grub/loader.h>
+#include <grub/ps2.h>
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
-static short at_keyboard_status = 0;
-static int e0_received = 0;
-static int f0_received = 0;
-
-static grub_uint8_t led_status;
-
-#define KEYBOARD_LED_SCROLL		(1 << 0)
-#define KEYBOARD_LED_NUM		(1 << 1)
-#define KEYBOARD_LED_CAPS		(1 << 2)
-
 static grub_uint8_t grub_keyboard_controller_orig;
 static grub_uint8_t grub_keyboard_orig_set;
-static grub_uint8_t current_set; 
-
-static void
-grub_keyboard_controller_init (void);
-
-static const grub_uint8_t set1_mapping[128] =
-  {
-    /* 0x00 */ 0 /* Unused  */,               GRUB_KEYBOARD_KEY_ESCAPE, 
-    /* 0x02 */ GRUB_KEYBOARD_KEY_1,           GRUB_KEYBOARD_KEY_2, 
-    /* 0x04 */ GRUB_KEYBOARD_KEY_3,           GRUB_KEYBOARD_KEY_4, 
-    /* 0x06 */ GRUB_KEYBOARD_KEY_5,           GRUB_KEYBOARD_KEY_6, 
-    /* 0x08 */ GRUB_KEYBOARD_KEY_7,           GRUB_KEYBOARD_KEY_8, 
-    /* 0x0a */ GRUB_KEYBOARD_KEY_9,           GRUB_KEYBOARD_KEY_0, 
-    /* 0x0c */ GRUB_KEYBOARD_KEY_DASH,        GRUB_KEYBOARD_KEY_EQUAL, 
-    /* 0x0e */ GRUB_KEYBOARD_KEY_BACKSPACE,   GRUB_KEYBOARD_KEY_TAB, 
-    /* 0x10 */ GRUB_KEYBOARD_KEY_Q,           GRUB_KEYBOARD_KEY_W, 
-    /* 0x12 */ GRUB_KEYBOARD_KEY_E,           GRUB_KEYBOARD_KEY_R, 
-    /* 0x14 */ GRUB_KEYBOARD_KEY_T,           GRUB_KEYBOARD_KEY_Y, 
-    /* 0x16 */ GRUB_KEYBOARD_KEY_U,           GRUB_KEYBOARD_KEY_I, 
-    /* 0x18 */ GRUB_KEYBOARD_KEY_O,           GRUB_KEYBOARD_KEY_P, 
-    /* 0x1a */ GRUB_KEYBOARD_KEY_LBRACKET,    GRUB_KEYBOARD_KEY_RBRACKET, 
-    /* 0x1c */ GRUB_KEYBOARD_KEY_ENTER,       GRUB_KEYBOARD_KEY_LEFT_CTRL, 
-    /* 0x1e */ GRUB_KEYBOARD_KEY_A,           GRUB_KEYBOARD_KEY_S, 
-    /* 0x20 */ GRUB_KEYBOARD_KEY_D,           GRUB_KEYBOARD_KEY_F, 
-    /* 0x22 */ GRUB_KEYBOARD_KEY_G,           GRUB_KEYBOARD_KEY_H, 
-    /* 0x24 */ GRUB_KEYBOARD_KEY_J,           GRUB_KEYBOARD_KEY_K, 
-    /* 0x26 */ GRUB_KEYBOARD_KEY_L,           GRUB_KEYBOARD_KEY_SEMICOLON, 
-    /* 0x28 */ GRUB_KEYBOARD_KEY_DQUOTE,      GRUB_KEYBOARD_KEY_RQUOTE, 
-    /* 0x2a */ GRUB_KEYBOARD_KEY_LEFT_SHIFT,  GRUB_KEYBOARD_KEY_BACKSLASH, 
-    /* 0x2c */ GRUB_KEYBOARD_KEY_Z,           GRUB_KEYBOARD_KEY_X, 
-    /* 0x2e */ GRUB_KEYBOARD_KEY_C,           GRUB_KEYBOARD_KEY_V, 
-    /* 0x30 */ GRUB_KEYBOARD_KEY_B,           GRUB_KEYBOARD_KEY_N, 
-    /* 0x32 */ GRUB_KEYBOARD_KEY_M,           GRUB_KEYBOARD_KEY_COMMA, 
-    /* 0x34 */ GRUB_KEYBOARD_KEY_DOT,         GRUB_KEYBOARD_KEY_SLASH, 
-    /* 0x36 */ GRUB_KEYBOARD_KEY_RIGHT_SHIFT, GRUB_KEYBOARD_KEY_NUMMUL, 
-    /* 0x38 */ GRUB_KEYBOARD_KEY_LEFT_ALT,    GRUB_KEYBOARD_KEY_SPACE, 
-    /* 0x3a */ GRUB_KEYBOARD_KEY_CAPS_LOCK,   GRUB_KEYBOARD_KEY_F1, 
-    /* 0x3c */ GRUB_KEYBOARD_KEY_F2,          GRUB_KEYBOARD_KEY_F3, 
-    /* 0x3e */ GRUB_KEYBOARD_KEY_F4,          GRUB_KEYBOARD_KEY_F5, 
-    /* 0x40 */ GRUB_KEYBOARD_KEY_F6,          GRUB_KEYBOARD_KEY_F7, 
-    /* 0x42 */ GRUB_KEYBOARD_KEY_F8,          GRUB_KEYBOARD_KEY_F9, 
-    /* 0x44 */ GRUB_KEYBOARD_KEY_F10,         GRUB_KEYBOARD_KEY_NUM_LOCK, 
-    /* 0x46 */ GRUB_KEYBOARD_KEY_SCROLL_LOCK, GRUB_KEYBOARD_KEY_NUM7, 
-    /* 0x48 */ GRUB_KEYBOARD_KEY_NUM8,        GRUB_KEYBOARD_KEY_NUM9, 
-    /* 0x4a */ GRUB_KEYBOARD_KEY_NUMMINUS,    GRUB_KEYBOARD_KEY_NUM4, 
-    /* 0x4c */ GRUB_KEYBOARD_KEY_NUM5,        GRUB_KEYBOARD_KEY_NUM6, 
-    /* 0x4e */ GRUB_KEYBOARD_KEY_NUMPLUS,     GRUB_KEYBOARD_KEY_NUM1, 
-    /* 0x50 */ GRUB_KEYBOARD_KEY_NUM2,        GRUB_KEYBOARD_KEY_NUM3, 
-    /* 0x52 */ GRUB_KEYBOARD_KEY_NUM0,        GRUB_KEYBOARD_KEY_NUMDOT, 
-    /* 0x54 */ 0,                             0, 
-    /* 0x56 */ GRUB_KEYBOARD_KEY_102ND,       GRUB_KEYBOARD_KEY_F11, 
-    /* 0x58 */ GRUB_KEYBOARD_KEY_F12,         0,
-    /* 0x5a */ 0,                             0,
-    /* 0x5c */ 0,                             0,
-    /* 0x5e */ 0,                             0,
-    /* 0x60 */ 0,                             0,
-    /* 0x62 */ 0,                             0,
-    /* OLPC keys. Just mapped to normal keys.  */
-    /* 0x64 */ 0,                             GRUB_KEYBOARD_KEY_UP,
-    /* 0x66 */ GRUB_KEYBOARD_KEY_DOWN,        GRUB_KEYBOARD_KEY_LEFT,
-    /* 0x68 */ GRUB_KEYBOARD_KEY_RIGHT,       0,
-    /* 0x6a */ 0,                             0,
-    /* 0x6c */ 0,                             0,
-    /* 0x6e */ 0,                             0,
-    /* 0x70 */ 0,                             0,
-    /* 0x72 */ 0,                             GRUB_KEYBOARD_KEY_JP_RO,
-    /* 0x74 */ 0,                             0,
-    /* 0x76 */ 0,                             0,
-    /* 0x78 */ 0,                             0,
-    /* 0x7a */ 0,                             0,
-    /* 0x7c */ 0,                             GRUB_KEYBOARD_KEY_JP_YEN,
-    /* 0x7e */ GRUB_KEYBOARD_KEY_KPCOMMA
-  };
-
-static const struct
-{
-  grub_uint8_t from, to;
-} set1_e0_mapping[] = 
-  {
-    {0x1c, GRUB_KEYBOARD_KEY_NUMENTER},
-    {0x1d, GRUB_KEYBOARD_KEY_RIGHT_CTRL},
-    {0x35, GRUB_KEYBOARD_KEY_NUMSLASH }, 
-    {0x38, GRUB_KEYBOARD_KEY_RIGHT_ALT},
-    {0x47, GRUB_KEYBOARD_KEY_HOME}, 
-    {0x48, GRUB_KEYBOARD_KEY_UP},
-    {0x49, GRUB_KEYBOARD_KEY_PPAGE}, 
-    {0x4b, GRUB_KEYBOARD_KEY_LEFT},
-    {0x4d, GRUB_KEYBOARD_KEY_RIGHT},
-    {0x4f, GRUB_KEYBOARD_KEY_END}, 
-    {0x50, GRUB_KEYBOARD_KEY_DOWN},
-    {0x51, GRUB_KEYBOARD_KEY_NPAGE},
-    {0x52, GRUB_KEYBOARD_KEY_INSERT},
-    {0x53, GRUB_KEYBOARD_KEY_DELETE}, 
-  };
-
-static const grub_uint8_t set2_mapping[256] =
-  {
-    /* 0x00 */ 0,                             GRUB_KEYBOARD_KEY_F9,
-    /* 0x02 */ 0,                             GRUB_KEYBOARD_KEY_F5,
-    /* 0x04 */ GRUB_KEYBOARD_KEY_F3,          GRUB_KEYBOARD_KEY_F1,
-    /* 0x06 */ GRUB_KEYBOARD_KEY_F2,          GRUB_KEYBOARD_KEY_F12,
-    /* 0x08 */ 0,                             GRUB_KEYBOARD_KEY_F10,
-    /* 0x0a */ GRUB_KEYBOARD_KEY_F8,          GRUB_KEYBOARD_KEY_F6,
-    /* 0x0c */ GRUB_KEYBOARD_KEY_F4,          GRUB_KEYBOARD_KEY_TAB,
-    /* 0x0e */ GRUB_KEYBOARD_KEY_RQUOTE,      0,
-    /* 0x10 */ 0,                             GRUB_KEYBOARD_KEY_LEFT_ALT,
-    /* 0x12 */ GRUB_KEYBOARD_KEY_LEFT_SHIFT,  0,
-    /* 0x14 */ GRUB_KEYBOARD_KEY_LEFT_CTRL,   GRUB_KEYBOARD_KEY_Q,
-    /* 0x16 */ GRUB_KEYBOARD_KEY_1,           0,
-    /* 0x18 */ 0,                             0,
-    /* 0x1a */ GRUB_KEYBOARD_KEY_Z,           GRUB_KEYBOARD_KEY_S,
-    /* 0x1c */ GRUB_KEYBOARD_KEY_A,           GRUB_KEYBOARD_KEY_W,
-    /* 0x1e */ GRUB_KEYBOARD_KEY_2,           0,
-    /* 0x20 */ 0,                             GRUB_KEYBOARD_KEY_C,
-    /* 0x22 */ GRUB_KEYBOARD_KEY_X,           GRUB_KEYBOARD_KEY_D,
-    /* 0x24 */ GRUB_KEYBOARD_KEY_E,           GRUB_KEYBOARD_KEY_4,
-    /* 0x26 */ GRUB_KEYBOARD_KEY_3,           0,
-    /* 0x28 */ 0,                             GRUB_KEYBOARD_KEY_SPACE,
-    /* 0x2a */ GRUB_KEYBOARD_KEY_V,           GRUB_KEYBOARD_KEY_F,
-    /* 0x2c */ GRUB_KEYBOARD_KEY_T,           GRUB_KEYBOARD_KEY_R,
-    /* 0x2e */ GRUB_KEYBOARD_KEY_5,           0,
-    /* 0x30 */ 0,                             GRUB_KEYBOARD_KEY_N,
-    /* 0x32 */ GRUB_KEYBOARD_KEY_B,           GRUB_KEYBOARD_KEY_H,
-    /* 0x34 */ GRUB_KEYBOARD_KEY_G,           GRUB_KEYBOARD_KEY_Y,
-    /* 0x36 */ GRUB_KEYBOARD_KEY_6,           0,
-    /* 0x38 */ 0,                             0,
-    /* 0x3a */ GRUB_KEYBOARD_KEY_M,           GRUB_KEYBOARD_KEY_J,
-    /* 0x3c */ GRUB_KEYBOARD_KEY_U,           GRUB_KEYBOARD_KEY_7,
-    /* 0x3e */ GRUB_KEYBOARD_KEY_8,           0,
-    /* 0x40 */ 0,                             GRUB_KEYBOARD_KEY_COMMA,
-    /* 0x42 */ GRUB_KEYBOARD_KEY_K,           GRUB_KEYBOARD_KEY_I,
-    /* 0x44 */ GRUB_KEYBOARD_KEY_O,           GRUB_KEYBOARD_KEY_0,
-    /* 0x46 */ GRUB_KEYBOARD_KEY_9,           0,
-    /* 0x48 */ 0,                             GRUB_KEYBOARD_KEY_DOT,
-    /* 0x4a */ GRUB_KEYBOARD_KEY_SLASH,       GRUB_KEYBOARD_KEY_L,
-    /* 0x4c */ GRUB_KEYBOARD_KEY_SEMICOLON,   GRUB_KEYBOARD_KEY_P,
-    /* 0x4e */ GRUB_KEYBOARD_KEY_DASH,        0,
-    /* 0x50 */ 0,                             GRUB_KEYBOARD_KEY_JP_RO,
-    /* 0x52 */ GRUB_KEYBOARD_KEY_DQUOTE,      0,
-    /* 0x54 */ GRUB_KEYBOARD_KEY_LBRACKET,    GRUB_KEYBOARD_KEY_EQUAL,
-    /* 0x56 */ 0,                             0,
-    /* 0x58 */ GRUB_KEYBOARD_KEY_CAPS_LOCK,   GRUB_KEYBOARD_KEY_RIGHT_SHIFT,
-    /* 0x5a */ GRUB_KEYBOARD_KEY_ENTER,       GRUB_KEYBOARD_KEY_RBRACKET,
-    /* 0x5c */ 0,                             GRUB_KEYBOARD_KEY_BACKSLASH,
-    /* 0x5e */ 0,                             0,
-    /* 0x60 */ 0,                             GRUB_KEYBOARD_KEY_102ND,
-    /* 0x62 */ 0,                             0,
-    /* 0x64 */ 0,                             0,
-    /* 0x66 */ GRUB_KEYBOARD_KEY_BACKSPACE,   0,
-    /* 0x68 */ 0,                             GRUB_KEYBOARD_KEY_NUM1,
-    /* 0x6a */ GRUB_KEYBOARD_KEY_JP_YEN,      GRUB_KEYBOARD_KEY_NUM4,
-    /* 0x6c */ GRUB_KEYBOARD_KEY_NUM7,        GRUB_KEYBOARD_KEY_KPCOMMA,
-    /* 0x6e */ 0,                             0,
-    /* 0x70 */ GRUB_KEYBOARD_KEY_NUM0,        GRUB_KEYBOARD_KEY_NUMDOT,
-    /* 0x72 */ GRUB_KEYBOARD_KEY_NUM2,        GRUB_KEYBOARD_KEY_NUM5,
-    /* 0x74 */ GRUB_KEYBOARD_KEY_NUM6,        GRUB_KEYBOARD_KEY_NUM8,
-    /* 0x76 */ GRUB_KEYBOARD_KEY_ESCAPE,      GRUB_KEYBOARD_KEY_NUM_LOCK,
-    /* 0x78 */ GRUB_KEYBOARD_KEY_F11,         GRUB_KEYBOARD_KEY_NUMPLUS,
-    /* 0x7a */ GRUB_KEYBOARD_KEY_NUM3,        GRUB_KEYBOARD_KEY_NUMMINUS,
-    /* 0x7c */ GRUB_KEYBOARD_KEY_NUMMUL,      GRUB_KEYBOARD_KEY_NUM9,
-    /* 0x7e */ GRUB_KEYBOARD_KEY_SCROLL_LOCK, 0,
-    /* 0x80 */ 0,                             0, 
-    /* 0x82 */ 0,                             GRUB_KEYBOARD_KEY_F7,
-  };
-
-static const struct
-{
-  grub_uint8_t from, to;
-} set2_e0_mapping[] = 
-  {
-    {0x11, GRUB_KEYBOARD_KEY_RIGHT_ALT},
-    {0x14, GRUB_KEYBOARD_KEY_RIGHT_CTRL},
-    {0x4a, GRUB_KEYBOARD_KEY_NUMSLASH},
-    {0x5a, GRUB_KEYBOARD_KEY_NUMENTER},
-    {0x69, GRUB_KEYBOARD_KEY_END},
-    {0x6b, GRUB_KEYBOARD_KEY_LEFT},
-    {0x6c, GRUB_KEYBOARD_KEY_HOME},
-    {0x70, GRUB_KEYBOARD_KEY_INSERT},
-    {0x71, GRUB_KEYBOARD_KEY_DELETE},
-    {0x72, GRUB_KEYBOARD_KEY_DOWN},
-    {0x74, GRUB_KEYBOARD_KEY_RIGHT},
-    {0x75, GRUB_KEYBOARD_KEY_UP},
-    {0x7a, GRUB_KEYBOARD_KEY_NPAGE},
-    {0x7d, GRUB_KEYBOARD_KEY_PPAGE},
-  };
+struct grub_ps2_state ps2_state;
 
 static int ping_sent;
 
+static void
+grub_keyboard_controller_init (void);
+
 static void
 keyboard_controller_wait_until_ready (void)
 {
+  /* 50 us would be enough but our current time resolution is 1ms.  */
+  grub_millisleep (1);
   while (! KEYBOARD_COMMAND_ISREADY (grub_inb (KEYBOARD_REG_STATUS)));
 }
 
@@ -241,10 +52,11 @@ wait_ack (void)
   grub_uint8_t ack;
 
   endtime = grub_get_time_ms () + 20;
-  do
+  do {
+    keyboard_controller_wait_until_ready ();
     ack = grub_inb (KEYBOARD_REG_DATA);
-  while (ack != GRUB_AT_ACK && ack != GRUB_AT_NACK
-	 && grub_get_time_ms () < endtime);
+  } while (ack != GRUB_AT_ACK && ack != GRUB_AT_NACK
+	   && grub_get_time_ms () < endtime);
   return ack;
 }
 
@@ -326,12 +138,10 @@ query_mode (void)
   if (!e)
     return 0;
 
-  keyboard_controller_wait_until_ready ();
-
-  do
+  do {
+    keyboard_controller_wait_until_ready ();
     ret = grub_inb (KEYBOARD_REG_DATA);
-  while (ret == GRUB_AT_ACK);
-
+  } while (ret == GRUB_AT_ACK);
   /* QEMU translates the set even in no-translate mode.  */
   if (ret == 0x43 || ret == 1)
     return 1;
@@ -350,28 +160,32 @@ set_scancodes (void)
   if (!grub_keyboard_orig_set)
     {
       grub_dprintf ("atkeyb", "No sets support assumed\n");
-      current_set = 1;
+      ps2_state.current_set = 1;
       return;
     }
 
 #if !USE_SCANCODE_SET
-  current_set = 1;
+  ps2_state.current_set = 1;
   return;
 #else
 
   grub_keyboard_controller_write (grub_keyboard_controller_orig
-				  & ~KEYBOARD_AT_TRANSLATE);
+				  & ~KEYBOARD_AT_TRANSLATE
+				  & ~KEYBOARD_AT_DISABLE);
+
+  keyboard_controller_wait_until_ready ();
+  grub_outb (KEYBOARD_COMMAND_ENABLE, KEYBOARD_REG_DATA);
 
   write_mode (2);
-  current_set = query_mode ();
-  grub_dprintf ("atkeyb", "returned set %d\n", current_set);
-  if (current_set == 2)
+  ps2_state.current_set = query_mode ();
+  grub_dprintf ("atkeyb", "returned set %d\n", ps2_state.current_set);
+  if (ps2_state.current_set == 2)
     return;
 
   write_mode (1);
-  current_set = query_mode ();
-  grub_dprintf ("atkeyb", "returned set %d\n", current_set);
-  if (current_set == 1)
+  ps2_state.current_set = query_mode ();
+  grub_dprintf ("atkeyb", "returned set %d\n", ps2_state.current_set);
+  if (ps2_state.current_set == 1)
     return;
   grub_dprintf ("atkeyb", "no supported scancode set found\n");
 #endif
@@ -386,164 +200,10 @@ keyboard_controller_led (grub_uint8_t leds)
   grub_outb (leds & 0x7, KEYBOARD_REG_DATA);
 }
 
-static int
-fetch_key (int *is_break)
-{
-  int was_ext = 0;
-  grub_uint8_t at_key;
-  int ret = 0;
-
-  if (! KEYBOARD_ISREADY (grub_inb (KEYBOARD_REG_STATUS)))
-    return -1;
-  at_key = grub_inb (KEYBOARD_REG_DATA);
-  /* May happen if no keyboard is connected. Just ignore this.  */
-  if (at_key == 0xff)
-    return -1;
-  if (at_key == 0xe0)
-    {
-      e0_received = 1;
-      return -1;
-    }
-
-  if ((current_set == 2 || current_set == 3) && at_key == 0xf0)
-    {
-      f0_received = 1;
-      return -1;
-    }
-
-  /* Setting LEDs may generate ACKs.  */
-  if (at_key == GRUB_AT_ACK)
-    return -1;
-
-  was_ext = e0_received;
-  e0_received = 0;
-
-  switch (current_set)
-    {
-    case 1:
-      *is_break = !!(at_key & 0x80);
-      if (!was_ext)
-	ret = set1_mapping[at_key & 0x7f];
-      else
-	{
-	  unsigned i;
-	  for (i = 0; i < ARRAY_SIZE (set1_e0_mapping); i++)
-	    if (set1_e0_mapping[i].from == (at_key & 0x7f))
-	      {
-		ret = set1_e0_mapping[i].to;
-		break;
-	      }
-	}
-      break;
-    case 2:
-      *is_break = f0_received;
-      f0_received = 0;
-      if (!was_ext)
-	ret = set2_mapping[at_key];
-      else
-	{
-	  unsigned i;
-	  for (i = 0; i < ARRAY_SIZE (set2_e0_mapping); i++)
-	    if (set2_e0_mapping[i].from == at_key)
-	      {
-		ret = set2_e0_mapping[i].to;
-		break;
-	      }
-	}	
-      break;
-    default:
-      return -1;
-    }
-  if (!ret)
-    {
-      if (was_ext)
-	grub_dprintf ("atkeyb", "Unknown key 0xe0+0x%02x from set %d\n",
-		      at_key, current_set);
-      else
-	grub_dprintf ("atkeyb", "Unknown key 0x%02x from set %d\n",
-		      at_key, current_set);
-      return -1;
-    }
-  return ret;
-}
-
-/* FIXME: This should become an interrupt service routine.  For now
-   it's just used to catch events from control keys.  */
-static int
-grub_keyboard_isr (grub_keyboard_key_t key, int is_break)
-{
-  if (!is_break)
-    switch (key)
-      {
-      case GRUB_KEYBOARD_KEY_LEFT_SHIFT:
-	at_keyboard_status |= GRUB_TERM_STATUS_LSHIFT;
-	return 1;
-      case GRUB_KEYBOARD_KEY_RIGHT_SHIFT:
-	at_keyboard_status |= GRUB_TERM_STATUS_RSHIFT;
-	return 1;
-      case GRUB_KEYBOARD_KEY_LEFT_CTRL:
-	at_keyboard_status |= GRUB_TERM_STATUS_LCTRL;
-	return 1;
-      case GRUB_KEYBOARD_KEY_RIGHT_CTRL:
-	at_keyboard_status |= GRUB_TERM_STATUS_RCTRL;
-	return 1;
-      case GRUB_KEYBOARD_KEY_RIGHT_ALT:
-	at_keyboard_status |= GRUB_TERM_STATUS_RALT;
-	return 1;
-      case GRUB_KEYBOARD_KEY_LEFT_ALT:
-	at_keyboard_status |= GRUB_TERM_STATUS_LALT;
-	return 1;
-      default:
-	return 0;
-      }
-  else
-    switch (key)
-      {
-      case GRUB_KEYBOARD_KEY_LEFT_SHIFT:
-	at_keyboard_status &= ~GRUB_TERM_STATUS_LSHIFT;
-	return 1;
-      case GRUB_KEYBOARD_KEY_RIGHT_SHIFT:
-	at_keyboard_status &= ~GRUB_TERM_STATUS_RSHIFT;
-	return 1;
-      case GRUB_KEYBOARD_KEY_LEFT_CTRL:
-	at_keyboard_status &= ~GRUB_TERM_STATUS_LCTRL;
-	return 1;
-      case GRUB_KEYBOARD_KEY_RIGHT_CTRL:
-	at_keyboard_status &= ~GRUB_TERM_STATUS_RCTRL;
-	return 1;
-      case GRUB_KEYBOARD_KEY_RIGHT_ALT:
-	at_keyboard_status &= ~GRUB_TERM_STATUS_RALT;
-	return 1;
-      case GRUB_KEYBOARD_KEY_LEFT_ALT:
-	at_keyboard_status &= ~GRUB_TERM_STATUS_LALT;
-	return 1;
-      default:
-	return 0;
-      }
-}
-
-/* If there is a raw key pending, return it; otherwise return -1.  */
-static int
-grub_keyboard_getkey (void)
-{
-  int key;
-  int is_break = 0;
-
-  key = fetch_key (&is_break);
-  if (key == -1)
-    return -1;
-
-  if (grub_keyboard_isr (key, is_break))
-    return -1;
-  if (is_break)
-    return -1;
-  return key;
-}
-
 int
 grub_at_keyboard_is_alive (void)
 {
-  if (current_set != 0)
+  if (ps2_state.current_set != 0)
     return 1;
   if (ping_sent
       && KEYBOARD_COMMAND_ISREADY (grub_inb (KEYBOARD_REG_STATUS))
@@ -566,51 +226,28 @@ grub_at_keyboard_is_alive (void)
 static int
 grub_at_keyboard_getkey (struct grub_term_input *term __attribute__ ((unused)))
 {
-  int code;
+  grub_uint8_t at_key;
+  int ret;
+  grub_uint8_t old_led;
 
   if (!grub_at_keyboard_is_alive ())
     return GRUB_TERM_NO_KEY;
 
-  code = grub_keyboard_getkey ();
-  if (code == -1)
-    return GRUB_TERM_NO_KEY;
-#ifdef DEBUG_AT_KEYBOARD
-  grub_dprintf ("atkeyb", "Detected key 0x%x\n", code);
-#endif
-  switch (code)
-    {
-      case GRUB_KEYBOARD_KEY_CAPS_LOCK:
-	at_keyboard_status ^= GRUB_TERM_STATUS_CAPS;
-	led_status ^= KEYBOARD_LED_CAPS;
-	keyboard_controller_led (led_status);
+  if (! KEYBOARD_ISREADY (grub_inb (KEYBOARD_REG_STATUS)))
+    return -1;
+  at_key = grub_inb (KEYBOARD_REG_DATA);
+  old_led = ps2_state.led_status;
 
-#ifdef DEBUG_AT_KEYBOARD
-	grub_dprintf ("atkeyb", "caps_lock = %d\n", !!(at_keyboard_status & GRUB_KEYBOARD_STATUS_CAPS_LOCK));
-#endif
-	return GRUB_TERM_NO_KEY;
-      case GRUB_KEYBOARD_KEY_NUM_LOCK:
-	at_keyboard_status ^= GRUB_TERM_STATUS_NUM;
-	led_status ^= KEYBOARD_LED_NUM;
-	keyboard_controller_led (led_status);
-
-#ifdef DEBUG_AT_KEYBOARD
-	grub_dprintf ("atkeyb", "num_lock = %d\n", !!(at_keyboard_status & GRUB_KEYBOARD_STATUS_NUM_LOCK));
-#endif
-	return GRUB_TERM_NO_KEY;
-      case GRUB_KEYBOARD_KEY_SCROLL_LOCK:
-	at_keyboard_status ^= GRUB_TERM_STATUS_SCROLL;
-	led_status ^= KEYBOARD_LED_SCROLL;
-	keyboard_controller_led (led_status);
-	return GRUB_TERM_NO_KEY;
-      default:
-	return grub_term_map_key (code, at_keyboard_status);
-    }
+  ret = grub_ps2_process_incoming_byte (&ps2_state, at_key);
+  if (old_led != ps2_state.led_status)
+    keyboard_controller_led (ps2_state.led_status);
+  return ret;
 }
 
 static void
 grub_keyboard_controller_init (void)
 {
-  at_keyboard_status = 0;
+  ps2_state.at_keyboard_status = 0;
   /* Drain input buffer. */
   while (1)
     {
@@ -632,13 +269,13 @@ grub_keyboard_controller_init (void)
   grub_keyboard_orig_set = query_mode ();
 #endif
   set_scancodes ();
-  keyboard_controller_led (led_status);
+  keyboard_controller_led (ps2_state.led_status);
 }
 
 static grub_err_t
 grub_keyboard_controller_fini (struct grub_term_input *term __attribute__ ((unused)))
 {
-  if (current_set == 0)
+  if (ps2_state.current_set == 0)
     return GRUB_ERR_NONE;
   if (grub_keyboard_orig_set)
     write_mode (grub_keyboard_orig_set);
@@ -655,7 +292,7 @@ grub_at_fini_hw (int noreturn __attribute__ ((unused)))
 static grub_err_t
 grub_at_restore_hw (void)
 {
-  if (current_set == 0)
+  if (ps2_state.current_set == 0)
     return GRUB_ERR_NONE;
 
   /* Drain input buffer. */
@@ -668,7 +305,7 @@ grub_at_restore_hw (void)
       grub_inb (KEYBOARD_REG_DATA);
     }
   set_scancodes ();
-  keyboard_controller_led (led_status);
+  keyboard_controller_led (ps2_state.led_status);
 
   return GRUB_ERR_NONE;
 }
diff --git a/grub-core/term/efi/console.c b/grub-core/term/efi/console.c
index 7d31095b1ef8d01886a0516343f2e5c5601265dd..02f64ea744107fbca662c2fab1fd15555f2d7724 100644
--- a/grub-core/term/efi/console.c
+++ b/grub-core/term/efi/console.c
@@ -104,7 +104,7 @@ const unsigned efi_codes[] =
     GRUB_TERM_KEY_DC, GRUB_TERM_KEY_PPAGE, GRUB_TERM_KEY_NPAGE, GRUB_TERM_KEY_F1,
     GRUB_TERM_KEY_F2, GRUB_TERM_KEY_F3, GRUB_TERM_KEY_F4, GRUB_TERM_KEY_F5,
     GRUB_TERM_KEY_F6, GRUB_TERM_KEY_F7, GRUB_TERM_KEY_F8, GRUB_TERM_KEY_F9,
-    GRUB_TERM_KEY_F10, GRUB_TERM_KEY_F11, GRUB_TERM_KEY_F12, '\e'
+    GRUB_TERM_KEY_F10, GRUB_TERM_KEY_F11, GRUB_TERM_KEY_F12, GRUB_TERM_ESC
   };
 
 static int
diff --git a/grub-core/term/i386/coreboot/cbmemc.c b/grub-core/term/i386/coreboot/cbmemc.c
index 25e64a05c03286f644b39398e9e68cbdde333510..cea9b84315bdaf3b1238acc915f35ba6148ffbcf 100644
--- a/grub-core/term/i386/coreboot/cbmemc.c
+++ b/grub-core/term/i386/coreboot/cbmemc.c
@@ -23,17 +23,20 @@
 #include <grub/time.h>
 #include <grub/terminfo.h>
 #include <grub/dl.h>
-#include <grub/i386/coreboot/lbio.h>
+#include <grub/coreboot/lbio.h>
 #include <grub/command.h>
 #include <grub/normal.h>
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
+#define CURSOR_MASK ((1 << 28) - 1)
+#define OVERFLOW (1 << 31)
+
 struct grub_linuxbios_cbmemc
 {
   grub_uint32_t size;
-  grub_uint32_t pointer;
-  char data[0];
+  grub_uint32_t cursor;
+  char body[0];
 };
 
 static struct grub_linuxbios_cbmemc *cbmemc;
@@ -41,11 +44,20 @@ static struct grub_linuxbios_cbmemc *cbmemc;
 static void
 put (struct grub_term_output *term __attribute__ ((unused)), const int c)
 {
+  grub_uint32_t flags, cursor;
   if (!cbmemc)
     return;
-  if (cbmemc->pointer < cbmemc->size)
-    cbmemc->data[cbmemc->pointer] = c;
-  cbmemc->pointer++;
+  flags = cbmemc->cursor & ~CURSOR_MASK;
+  cursor = cbmemc->cursor & CURSOR_MASK;
+  if (cursor >= cbmemc->size)
+    return;
+  cbmemc->body[cursor++] = c;
+  if (cursor >= cbmemc->size)
+    {
+      cursor = 0;
+      flags |= OVERFLOW;
+    }
+  cbmemc->cursor = flags | cursor;
 }
 
 struct grub_terminfo_output_state grub_cbmemc_terminfo_output =
@@ -87,21 +99,29 @@ grub_cmd_cbmemc (struct grub_command *cmd __attribute__ ((unused)),
 		 int argc __attribute__ ((unused)),
 		 char *argv[] __attribute__ ((unused)))
 {
-  grub_size_t len;
-  char *str;
-  struct grub_linuxbios_cbmemc *cbmemc_saved;
+  grub_size_t size, cursor;
+  struct grub_linuxbios_cbmemc *real_cbmemc;
 
   if (!cbmemc)
     return grub_error (GRUB_ERR_IO, "no CBMEM console found");
 
-  len = cbmemc->pointer;
-  if (len > cbmemc->size)
-    len = cbmemc->size;
-  str = cbmemc->data;
-  cbmemc_saved = cbmemc;
+  real_cbmemc = cbmemc;
   cbmemc = 0;
-  grub_xnputs (str, len);
-  cbmemc = cbmemc_saved;
+  cursor = real_cbmemc->cursor & CURSOR_MASK;
+  if (!(real_cbmemc->cursor & OVERFLOW) && cursor < real_cbmemc->size)
+    size = cursor;
+  else
+    size = real_cbmemc->size;
+  if (real_cbmemc->cursor & OVERFLOW)
+    {
+      if (cursor > size)
+        cursor = 0;
+      grub_xnputs(real_cbmemc->body + cursor, size - cursor);
+      grub_xnputs(real_cbmemc->body, cursor);
+    }
+  else
+    grub_xnputs(real_cbmemc->body, size);
+  cbmemc = real_cbmemc;
   return 0;
 }
 
diff --git a/grub-core/term/i386/pc/console.c b/grub-core/term/i386/pc/console.c
index 28de46b576a667fd40c5852b16a4bcc3ea681849..f6142a2dea8036f5301c81a9e2fbd5ddbff5fd90 100644
--- a/grub-core/term/i386/pc/console.c
+++ b/grub-core/term/i386/pc/console.c
@@ -204,7 +204,7 @@ static int
 grub_console_getkey (struct grub_term_input *term __attribute__ ((unused)))
 {
   const grub_uint16_t bypass_table[] = {
-    0x0100 | '\e', 0x0f00 | '\t', 0x0e00 | '\b', 0x1c00 | '\r', 0x1c00 | '\n'
+    0x0100 | GRUB_TERM_ESC, 0x0f00 | GRUB_TERM_TAB, 0x0e00 | GRUB_TERM_BACKSPACE, 0x1c00 | '\r', 0x1c00 | '\n'
   };
   struct grub_bios_int_registers regs;
   unsigned i;
diff --git a/grub-core/term/ps2.c b/grub-core/term/ps2.c
new file mode 100644
index 0000000000000000000000000000000000000000..7ae4e9f2f8cd4a0ba4405c21581f906f7b458379
--- /dev/null
+++ b/grub-core/term/ps2.c
@@ -0,0 +1,387 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2007,2008,2009  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/dl.h>
+#include <grub/misc.h>
+#include <grub/term.h>
+#include <grub/keyboard_layouts.h>
+#include <grub/ps2.h>
+
+#define KEYBOARD_LED_SCROLL		(1 << 0)
+#define KEYBOARD_LED_NUM		(1 << 1)
+#define KEYBOARD_LED_CAPS		(1 << 2)
+
+static const grub_uint8_t set1_mapping[128] =
+  {
+    /* 0x00 */ 0 /* Unused  */,               GRUB_KEYBOARD_KEY_ESCAPE, 
+    /* 0x02 */ GRUB_KEYBOARD_KEY_1,           GRUB_KEYBOARD_KEY_2, 
+    /* 0x04 */ GRUB_KEYBOARD_KEY_3,           GRUB_KEYBOARD_KEY_4, 
+    /* 0x06 */ GRUB_KEYBOARD_KEY_5,           GRUB_KEYBOARD_KEY_6, 
+    /* 0x08 */ GRUB_KEYBOARD_KEY_7,           GRUB_KEYBOARD_KEY_8, 
+    /* 0x0a */ GRUB_KEYBOARD_KEY_9,           GRUB_KEYBOARD_KEY_0, 
+    /* 0x0c */ GRUB_KEYBOARD_KEY_DASH,        GRUB_KEYBOARD_KEY_EQUAL, 
+    /* 0x0e */ GRUB_KEYBOARD_KEY_BACKSPACE,   GRUB_KEYBOARD_KEY_TAB, 
+    /* 0x10 */ GRUB_KEYBOARD_KEY_Q,           GRUB_KEYBOARD_KEY_W, 
+    /* 0x12 */ GRUB_KEYBOARD_KEY_E,           GRUB_KEYBOARD_KEY_R, 
+    /* 0x14 */ GRUB_KEYBOARD_KEY_T,           GRUB_KEYBOARD_KEY_Y, 
+    /* 0x16 */ GRUB_KEYBOARD_KEY_U,           GRUB_KEYBOARD_KEY_I, 
+    /* 0x18 */ GRUB_KEYBOARD_KEY_O,           GRUB_KEYBOARD_KEY_P, 
+    /* 0x1a */ GRUB_KEYBOARD_KEY_LBRACKET,    GRUB_KEYBOARD_KEY_RBRACKET, 
+    /* 0x1c */ GRUB_KEYBOARD_KEY_ENTER,       GRUB_KEYBOARD_KEY_LEFT_CTRL, 
+    /* 0x1e */ GRUB_KEYBOARD_KEY_A,           GRUB_KEYBOARD_KEY_S, 
+    /* 0x20 */ GRUB_KEYBOARD_KEY_D,           GRUB_KEYBOARD_KEY_F, 
+    /* 0x22 */ GRUB_KEYBOARD_KEY_G,           GRUB_KEYBOARD_KEY_H, 
+    /* 0x24 */ GRUB_KEYBOARD_KEY_J,           GRUB_KEYBOARD_KEY_K, 
+    /* 0x26 */ GRUB_KEYBOARD_KEY_L,           GRUB_KEYBOARD_KEY_SEMICOLON, 
+    /* 0x28 */ GRUB_KEYBOARD_KEY_DQUOTE,      GRUB_KEYBOARD_KEY_RQUOTE, 
+    /* 0x2a */ GRUB_KEYBOARD_KEY_LEFT_SHIFT,  GRUB_KEYBOARD_KEY_BACKSLASH, 
+    /* 0x2c */ GRUB_KEYBOARD_KEY_Z,           GRUB_KEYBOARD_KEY_X, 
+    /* 0x2e */ GRUB_KEYBOARD_KEY_C,           GRUB_KEYBOARD_KEY_V, 
+    /* 0x30 */ GRUB_KEYBOARD_KEY_B,           GRUB_KEYBOARD_KEY_N, 
+    /* 0x32 */ GRUB_KEYBOARD_KEY_M,           GRUB_KEYBOARD_KEY_COMMA, 
+    /* 0x34 */ GRUB_KEYBOARD_KEY_DOT,         GRUB_KEYBOARD_KEY_SLASH, 
+    /* 0x36 */ GRUB_KEYBOARD_KEY_RIGHT_SHIFT, GRUB_KEYBOARD_KEY_NUMMUL, 
+    /* 0x38 */ GRUB_KEYBOARD_KEY_LEFT_ALT,    GRUB_KEYBOARD_KEY_SPACE, 
+    /* 0x3a */ GRUB_KEYBOARD_KEY_CAPS_LOCK,   GRUB_KEYBOARD_KEY_F1, 
+    /* 0x3c */ GRUB_KEYBOARD_KEY_F2,          GRUB_KEYBOARD_KEY_F3, 
+    /* 0x3e */ GRUB_KEYBOARD_KEY_F4,          GRUB_KEYBOARD_KEY_F5, 
+    /* 0x40 */ GRUB_KEYBOARD_KEY_F6,          GRUB_KEYBOARD_KEY_F7, 
+    /* 0x42 */ GRUB_KEYBOARD_KEY_F8,          GRUB_KEYBOARD_KEY_F9, 
+    /* 0x44 */ GRUB_KEYBOARD_KEY_F10,         GRUB_KEYBOARD_KEY_NUM_LOCK, 
+    /* 0x46 */ GRUB_KEYBOARD_KEY_SCROLL_LOCK, GRUB_KEYBOARD_KEY_NUM7, 
+    /* 0x48 */ GRUB_KEYBOARD_KEY_NUM8,        GRUB_KEYBOARD_KEY_NUM9, 
+    /* 0x4a */ GRUB_KEYBOARD_KEY_NUMMINUS,    GRUB_KEYBOARD_KEY_NUM4, 
+    /* 0x4c */ GRUB_KEYBOARD_KEY_NUM5,        GRUB_KEYBOARD_KEY_NUM6, 
+    /* 0x4e */ GRUB_KEYBOARD_KEY_NUMPLUS,     GRUB_KEYBOARD_KEY_NUM1, 
+    /* 0x50 */ GRUB_KEYBOARD_KEY_NUM2,        GRUB_KEYBOARD_KEY_NUM3, 
+    /* 0x52 */ GRUB_KEYBOARD_KEY_NUM0,        GRUB_KEYBOARD_KEY_NUMDOT, 
+    /* 0x54 */ 0,                             0, 
+    /* 0x56 */ GRUB_KEYBOARD_KEY_102ND,       GRUB_KEYBOARD_KEY_F11, 
+    /* 0x58 */ GRUB_KEYBOARD_KEY_F12,         0,
+    /* 0x5a */ 0,                             0,
+    /* 0x5c */ 0,                             0,
+    /* 0x5e */ 0,                             0,
+    /* 0x60 */ 0,                             0,
+    /* 0x62 */ 0,                             0,
+    /* OLPC keys. Just mapped to normal keys.  */
+    /* 0x64 */ 0,                             GRUB_KEYBOARD_KEY_UP,
+    /* 0x66 */ GRUB_KEYBOARD_KEY_DOWN,        GRUB_KEYBOARD_KEY_LEFT,
+    /* 0x68 */ GRUB_KEYBOARD_KEY_RIGHT,       0,
+    /* 0x6a */ 0,                             0,
+    /* 0x6c */ 0,                             0,
+    /* 0x6e */ 0,                             0,
+    /* 0x70 */ 0,                             0,
+    /* 0x72 */ 0,                             GRUB_KEYBOARD_KEY_JP_RO,
+    /* 0x74 */ 0,                             0,
+    /* 0x76 */ 0,                             0,
+    /* 0x78 */ 0,                             0,
+    /* 0x7a */ 0,                             0,
+    /* 0x7c */ 0,                             GRUB_KEYBOARD_KEY_JP_YEN,
+    /* 0x7e */ GRUB_KEYBOARD_KEY_KPCOMMA
+  };
+
+static const struct
+{
+  grub_uint8_t from, to;
+} set1_e0_mapping[] = 
+  {
+    {0x1c, GRUB_KEYBOARD_KEY_NUMENTER},
+    {0x1d, GRUB_KEYBOARD_KEY_RIGHT_CTRL},
+    {0x35, GRUB_KEYBOARD_KEY_NUMSLASH }, 
+    {0x38, GRUB_KEYBOARD_KEY_RIGHT_ALT},
+    {0x47, GRUB_KEYBOARD_KEY_HOME}, 
+    {0x48, GRUB_KEYBOARD_KEY_UP},
+    {0x49, GRUB_KEYBOARD_KEY_PPAGE}, 
+    {0x4b, GRUB_KEYBOARD_KEY_LEFT},
+    {0x4d, GRUB_KEYBOARD_KEY_RIGHT},
+    {0x4f, GRUB_KEYBOARD_KEY_END}, 
+    {0x50, GRUB_KEYBOARD_KEY_DOWN},
+    {0x51, GRUB_KEYBOARD_KEY_NPAGE},
+    {0x52, GRUB_KEYBOARD_KEY_INSERT},
+    {0x53, GRUB_KEYBOARD_KEY_DELETE}, 
+  };
+
+static const grub_uint8_t set2_mapping[256] =
+  {
+    /* 0x00 */ 0,                             GRUB_KEYBOARD_KEY_F9,
+    /* 0x02 */ 0,                             GRUB_KEYBOARD_KEY_F5,
+    /* 0x04 */ GRUB_KEYBOARD_KEY_F3,          GRUB_KEYBOARD_KEY_F1,
+    /* 0x06 */ GRUB_KEYBOARD_KEY_F2,          GRUB_KEYBOARD_KEY_F12,
+    /* 0x08 */ 0,                             GRUB_KEYBOARD_KEY_F10,
+    /* 0x0a */ GRUB_KEYBOARD_KEY_F8,          GRUB_KEYBOARD_KEY_F6,
+    /* 0x0c */ GRUB_KEYBOARD_KEY_F4,          GRUB_KEYBOARD_KEY_TAB,
+    /* 0x0e */ GRUB_KEYBOARD_KEY_RQUOTE,      0,
+    /* 0x10 */ 0,                             GRUB_KEYBOARD_KEY_LEFT_ALT,
+    /* 0x12 */ GRUB_KEYBOARD_KEY_LEFT_SHIFT,  0,
+    /* 0x14 */ GRUB_KEYBOARD_KEY_LEFT_CTRL,   GRUB_KEYBOARD_KEY_Q,
+    /* 0x16 */ GRUB_KEYBOARD_KEY_1,           0,
+    /* 0x18 */ 0,                             0,
+    /* 0x1a */ GRUB_KEYBOARD_KEY_Z,           GRUB_KEYBOARD_KEY_S,
+    /* 0x1c */ GRUB_KEYBOARD_KEY_A,           GRUB_KEYBOARD_KEY_W,
+    /* 0x1e */ GRUB_KEYBOARD_KEY_2,           0,
+    /* 0x20 */ 0,                             GRUB_KEYBOARD_KEY_C,
+    /* 0x22 */ GRUB_KEYBOARD_KEY_X,           GRUB_KEYBOARD_KEY_D,
+    /* 0x24 */ GRUB_KEYBOARD_KEY_E,           GRUB_KEYBOARD_KEY_4,
+    /* 0x26 */ GRUB_KEYBOARD_KEY_3,           0,
+    /* 0x28 */ 0,                             GRUB_KEYBOARD_KEY_SPACE,
+    /* 0x2a */ GRUB_KEYBOARD_KEY_V,           GRUB_KEYBOARD_KEY_F,
+    /* 0x2c */ GRUB_KEYBOARD_KEY_T,           GRUB_KEYBOARD_KEY_R,
+    /* 0x2e */ GRUB_KEYBOARD_KEY_5,           0,
+    /* 0x30 */ 0,                             GRUB_KEYBOARD_KEY_N,
+    /* 0x32 */ GRUB_KEYBOARD_KEY_B,           GRUB_KEYBOARD_KEY_H,
+    /* 0x34 */ GRUB_KEYBOARD_KEY_G,           GRUB_KEYBOARD_KEY_Y,
+    /* 0x36 */ GRUB_KEYBOARD_KEY_6,           0,
+    /* 0x38 */ 0,                             0,
+    /* 0x3a */ GRUB_KEYBOARD_KEY_M,           GRUB_KEYBOARD_KEY_J,
+    /* 0x3c */ GRUB_KEYBOARD_KEY_U,           GRUB_KEYBOARD_KEY_7,
+    /* 0x3e */ GRUB_KEYBOARD_KEY_8,           0,
+    /* 0x40 */ 0,                             GRUB_KEYBOARD_KEY_COMMA,
+    /* 0x42 */ GRUB_KEYBOARD_KEY_K,           GRUB_KEYBOARD_KEY_I,
+    /* 0x44 */ GRUB_KEYBOARD_KEY_O,           GRUB_KEYBOARD_KEY_0,
+    /* 0x46 */ GRUB_KEYBOARD_KEY_9,           0,
+    /* 0x48 */ 0,                             GRUB_KEYBOARD_KEY_DOT,
+    /* 0x4a */ GRUB_KEYBOARD_KEY_SLASH,       GRUB_KEYBOARD_KEY_L,
+    /* 0x4c */ GRUB_KEYBOARD_KEY_SEMICOLON,   GRUB_KEYBOARD_KEY_P,
+    /* 0x4e */ GRUB_KEYBOARD_KEY_DASH,        0,
+    /* 0x50 */ 0,                             GRUB_KEYBOARD_KEY_JP_RO,
+    /* 0x52 */ GRUB_KEYBOARD_KEY_DQUOTE,      0,
+    /* 0x54 */ GRUB_KEYBOARD_KEY_LBRACKET,    GRUB_KEYBOARD_KEY_EQUAL,
+    /* 0x56 */ 0,                             0,
+    /* 0x58 */ GRUB_KEYBOARD_KEY_CAPS_LOCK,   GRUB_KEYBOARD_KEY_RIGHT_SHIFT,
+    /* 0x5a */ GRUB_KEYBOARD_KEY_ENTER,       GRUB_KEYBOARD_KEY_RBRACKET,
+    /* 0x5c */ 0,                             GRUB_KEYBOARD_KEY_BACKSLASH,
+    /* 0x5e */ 0,                             0,
+    /* 0x60 */ 0,                             GRUB_KEYBOARD_KEY_102ND,
+    /* 0x62 */ 0,                             0,
+    /* 0x64 */ 0,                             0,
+    /* 0x66 */ GRUB_KEYBOARD_KEY_BACKSPACE,   0,
+    /* 0x68 */ 0,                             GRUB_KEYBOARD_KEY_NUM1,
+    /* 0x6a */ GRUB_KEYBOARD_KEY_JP_YEN,      GRUB_KEYBOARD_KEY_NUM4,
+    /* 0x6c */ GRUB_KEYBOARD_KEY_NUM7,        GRUB_KEYBOARD_KEY_KPCOMMA,
+    /* 0x6e */ 0,                             0,
+    /* 0x70 */ GRUB_KEYBOARD_KEY_NUM0,        GRUB_KEYBOARD_KEY_NUMDOT,
+    /* 0x72 */ GRUB_KEYBOARD_KEY_NUM2,        GRUB_KEYBOARD_KEY_NUM5,
+    /* 0x74 */ GRUB_KEYBOARD_KEY_NUM6,        GRUB_KEYBOARD_KEY_NUM8,
+    /* 0x76 */ GRUB_KEYBOARD_KEY_ESCAPE,      GRUB_KEYBOARD_KEY_NUM_LOCK,
+    /* 0x78 */ GRUB_KEYBOARD_KEY_F11,         GRUB_KEYBOARD_KEY_NUMPLUS,
+    /* 0x7a */ GRUB_KEYBOARD_KEY_NUM3,        GRUB_KEYBOARD_KEY_NUMMINUS,
+    /* 0x7c */ GRUB_KEYBOARD_KEY_NUMMUL,      GRUB_KEYBOARD_KEY_NUM9,
+    /* 0x7e */ GRUB_KEYBOARD_KEY_SCROLL_LOCK, 0,
+    /* 0x80 */ 0,                             0, 
+    /* 0x82 */ 0,                             GRUB_KEYBOARD_KEY_F7,
+  };
+
+static const struct
+{
+  grub_uint8_t from, to;
+} set2_e0_mapping[] = 
+  {
+    {0x11, GRUB_KEYBOARD_KEY_RIGHT_ALT},
+    {0x14, GRUB_KEYBOARD_KEY_RIGHT_CTRL},
+    {0x4a, GRUB_KEYBOARD_KEY_NUMSLASH},
+    {0x5a, GRUB_KEYBOARD_KEY_NUMENTER},
+    {0x69, GRUB_KEYBOARD_KEY_END},
+    {0x6b, GRUB_KEYBOARD_KEY_LEFT},
+    {0x6c, GRUB_KEYBOARD_KEY_HOME},
+    {0x70, GRUB_KEYBOARD_KEY_INSERT},
+    {0x71, GRUB_KEYBOARD_KEY_DELETE},
+    {0x72, GRUB_KEYBOARD_KEY_DOWN},
+    {0x74, GRUB_KEYBOARD_KEY_RIGHT},
+    {0x75, GRUB_KEYBOARD_KEY_UP},
+    {0x7a, GRUB_KEYBOARD_KEY_NPAGE},
+    {0x7d, GRUB_KEYBOARD_KEY_PPAGE},
+  };
+
+static int
+fetch_key (struct grub_ps2_state *ps2_state, grub_uint8_t at_key, int *is_break)
+{
+  int was_ext = 0;
+  int ret = 0;
+
+  /* May happen if no keyboard is connected. Just ignore this.  */
+  if (at_key == 0xff)
+    return -1;
+  if (at_key == 0xe0)
+    {
+      ps2_state->e0_received = 1;
+      return -1;
+    }
+
+  if ((ps2_state->current_set == 2 || ps2_state->current_set == 3) && at_key == 0xf0)
+    {
+      ps2_state->f0_received = 1;
+      return -1;
+    }
+
+  /* Setting LEDs may generate ACKs.  */
+  if (at_key == GRUB_AT_ACK)
+    return -1;
+
+  was_ext = ps2_state->e0_received;
+  ps2_state->e0_received = 0;
+
+  switch (ps2_state->current_set)
+    {
+    case 1:
+      *is_break = !!(at_key & 0x80);
+      if (!was_ext)
+	ret = set1_mapping[at_key & 0x7f];
+      else
+	{
+	  unsigned i;
+	  for (i = 0; i < ARRAY_SIZE (set1_e0_mapping); i++)
+	    if (set1_e0_mapping[i].from == (at_key & 0x7f))
+	      {
+		ret = set1_e0_mapping[i].to;
+		break;
+	      }
+	}
+      break;
+    case 2:
+      *is_break = ps2_state->f0_received;
+      ps2_state->f0_received = 0;
+      if (!was_ext)
+	ret = set2_mapping[at_key];
+      else
+	{
+	  unsigned i;
+	  for (i = 0; i < ARRAY_SIZE (set2_e0_mapping); i++)
+	    if (set2_e0_mapping[i].from == at_key)
+	      {
+		ret = set2_e0_mapping[i].to;
+		break;
+	      }
+	}	
+      break;
+    default:
+      return -1;
+    }
+  if (!ret)
+    {
+      if (was_ext)
+	grub_dprintf ("atkeyb", "Unknown key 0xe0+0x%02x from set %d\n",
+		      at_key, ps2_state->current_set);
+      else
+	grub_dprintf ("atkeyb", "Unknown key 0x%02x from set %d\n",
+		      at_key, ps2_state->current_set);
+      return -1;
+    }
+  return ret;
+}
+
+/* FIXME: This should become an interrupt service routine.  For now
+   it's just used to catch events from control keys.  */
+static int
+grub_keyboard_isr (struct grub_ps2_state *ps2_state,
+		   grub_keyboard_key_t key, int is_break)
+{
+  if (!is_break)
+    switch (key)
+      {
+      case GRUB_KEYBOARD_KEY_LEFT_SHIFT:
+	ps2_state->at_keyboard_status |= GRUB_TERM_STATUS_LSHIFT;
+	return 1;
+      case GRUB_KEYBOARD_KEY_RIGHT_SHIFT:
+	ps2_state->at_keyboard_status |= GRUB_TERM_STATUS_RSHIFT;
+	return 1;
+      case GRUB_KEYBOARD_KEY_LEFT_CTRL:
+	ps2_state->at_keyboard_status |= GRUB_TERM_STATUS_LCTRL;
+	return 1;
+      case GRUB_KEYBOARD_KEY_RIGHT_CTRL:
+	ps2_state->at_keyboard_status |= GRUB_TERM_STATUS_RCTRL;
+	return 1;
+      case GRUB_KEYBOARD_KEY_RIGHT_ALT:
+	ps2_state->at_keyboard_status |= GRUB_TERM_STATUS_RALT;
+	return 1;
+      case GRUB_KEYBOARD_KEY_LEFT_ALT:
+	ps2_state->at_keyboard_status |= GRUB_TERM_STATUS_LALT;
+	return 1;
+      default:
+	return 0;
+      }
+  else
+    switch (key)
+      {
+      case GRUB_KEYBOARD_KEY_LEFT_SHIFT:
+	ps2_state->at_keyboard_status &= ~GRUB_TERM_STATUS_LSHIFT;
+	return 1;
+      case GRUB_KEYBOARD_KEY_RIGHT_SHIFT:
+	ps2_state->at_keyboard_status &= ~GRUB_TERM_STATUS_RSHIFT;
+	return 1;
+      case GRUB_KEYBOARD_KEY_LEFT_CTRL:
+	ps2_state->at_keyboard_status &= ~GRUB_TERM_STATUS_LCTRL;
+	return 1;
+      case GRUB_KEYBOARD_KEY_RIGHT_CTRL:
+	ps2_state->at_keyboard_status &= ~GRUB_TERM_STATUS_RCTRL;
+	return 1;
+      case GRUB_KEYBOARD_KEY_RIGHT_ALT:
+	ps2_state->at_keyboard_status &= ~GRUB_TERM_STATUS_RALT;
+	return 1;
+      case GRUB_KEYBOARD_KEY_LEFT_ALT:
+	ps2_state->at_keyboard_status &= ~GRUB_TERM_STATUS_LALT;
+	return 1;
+      default:
+	return 0;
+      }
+}
+
+/* If there is a key pending, return it; otherwise return GRUB_TERM_NO_KEY.  */
+int
+grub_ps2_process_incoming_byte (struct grub_ps2_state *ps2_state,
+				grub_uint8_t at_key)
+{
+  int code;
+  int is_break = 0;
+
+  code = fetch_key (ps2_state, at_key, &is_break);
+  if (code == -1)
+    return GRUB_TERM_NO_KEY;
+
+  if (grub_keyboard_isr (ps2_state, code, is_break))
+    return GRUB_TERM_NO_KEY;
+  if (is_break)
+    return GRUB_TERM_NO_KEY;
+#ifdef DEBUG_AT_KEYBOARD
+  grub_dprintf ("atkeyb", "Detected key 0x%x\n", code);
+#endif
+  switch (code)
+    {
+      case GRUB_KEYBOARD_KEY_CAPS_LOCK:
+	ps2_state->at_keyboard_status ^= GRUB_TERM_STATUS_CAPS;
+	ps2_state->led_status ^= KEYBOARD_LED_CAPS;
+
+#ifdef DEBUG_AT_KEYBOARD
+	grub_dprintf ("atkeyb", "caps_lock = %d\n", !!(ps2_state->at_keyboard_status & GRUB_KEYBOARD_STATUS_CAPS_LOCK));
+#endif
+	return GRUB_TERM_NO_KEY;
+      case GRUB_KEYBOARD_KEY_NUM_LOCK:
+	ps2_state->at_keyboard_status ^= GRUB_TERM_STATUS_NUM;
+	ps2_state->led_status ^= KEYBOARD_LED_NUM;
+
+#ifdef DEBUG_AT_KEYBOARD
+	grub_dprintf ("atkeyb", "num_lock = %d\n", !!(ps2_state->at_keyboard_status & GRUB_KEYBOARD_STATUS_NUM_LOCK));
+#endif
+	return GRUB_TERM_NO_KEY;
+      case GRUB_KEYBOARD_KEY_SCROLL_LOCK:
+	ps2_state->at_keyboard_status ^= GRUB_TERM_STATUS_SCROLL;
+	ps2_state->led_status ^= KEYBOARD_LED_SCROLL;
+	return GRUB_TERM_NO_KEY;
+      default:
+	return grub_term_map_key (code, ps2_state->at_keyboard_status);
+    }
+}
diff --git a/grub-core/term/terminfo.c b/grub-core/term/terminfo.c
index f0d3e3debc60aa8dd04a5643a8a0537ffb88ec26..d317efa368d846963743a243fd672026a2221933 100644
--- a/grub-core/term/terminfo.c
+++ b/grub-core/term/terminfo.c
@@ -426,12 +426,12 @@ grub_terminfo_readkey (struct grub_term_input *term, int *keys, int *len,
     }
   *len = 1;
   keys[0] = c;
-  if (c != ANSI_CSI && c != '\e')
+  if (c != ANSI_CSI && c != GRUB_TERM_ESC)
     {
       /* Backspace: Ctrl-h.  */
       if (c == 0x7f)
-	c = '\b'; 
-      if (c < 0x20 && c != '\t' && c!= '\b' && c != '\n' && c != '\r')
+	c = GRUB_TERM_BACKSPACE;
+      if (c < 0x20 && c != GRUB_TERM_TAB && c!= GRUB_TERM_BACKSPACE && c != '\n' && c != '\r')
 	c = GRUB_TERM_CTRL | (c - 1 + 'a');
       *len = 1;
       keys[0] = c;
@@ -487,7 +487,7 @@ grub_terminfo_readkey (struct grub_term_input *term, int *keys, int *len,
 	  GRUB_TERM_KEY_HOME, GRUB_TERM_KEY_END };
     unsigned i;
 
-    if (c == '\e')
+    if (c == GRUB_TERM_ESC)
       {
 	CONTINUE_READ;
 
@@ -606,7 +606,7 @@ grub_terminfo_getkey (struct grub_term_input *termi)
 			 &data->npending, data->readkey);
 
 #if defined(__powerpc__) && defined(GRUB_MACHINE_IEEE1275)
-  if (data->npending == 1 && data->input_buf[0] == '\e'
+  if (data->npending == 1 && data->input_buf[0] == GRUB_TERM_ESC
       && grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_BROKEN_REPEAT)
       && grub_get_time_ms () - data->last_key_time < 1000
       && (data->last_key & GRUB_TERM_EXTENDED))
diff --git a/grub-core/tests/cmdline_cat_test.c b/grub-core/tests/cmdline_cat_test.c
index f1e21439e2be229d386cb310d62164fc9a5f4f92..baea7688a1d3c49d37a2c03e585109ccd04328f8 100644
--- a/grub-core/tests/cmdline_cat_test.c
+++ b/grub-core/tests/cmdline_cat_test.c
@@ -103,7 +103,7 @@ cmdline_cat_test (void)
 					     '/', 't', 'e', 's', 't', '.',
 					     't', 'x', 't', '\n',
 					     GRUB_TERM_NO_KEY,
-					     GRUB_TERM_NO_KEY, '\e'},
+					     GRUB_TERM_NO_KEY, GRUB_TERM_ESC},
 					 23);
 
       grub_video_checksum ("cmdline_cat");
diff --git a/grub-core/tests/gfxterm_menu.c b/grub-core/tests/gfxterm_menu.c
index 8f63dc27a35bd769ecb5d94599de3ba9e97cf5dc..12836fb96598d98b5cbf371a953e6ec702eb50de 100644
--- a/grub-core/tests/gfxterm_menu.c
+++ b/grub-core/tests/gfxterm_menu.c
@@ -146,7 +146,7 @@ gfxterm_menu (void)
 	    return;
 	  }
 	grub_terminal_input_fake_sequence ((int []) { -1, -1, -1, GRUB_TERM_KEY_DOWN, -1, 'e',
-	      -1, GRUB_TERM_KEY_RIGHT, -1, 'x', -1,  '\e', -1, '\e' }, 14);
+	      -1, GRUB_TERM_KEY_RIGHT, -1, 'x', -1,  GRUB_TERM_ESC, -1, GRUB_TERM_ESC }, 14);
 
 	grub_video_checksum (tests[j].name);
 
diff --git a/grub-core/tests/lib/functional_test.c b/grub-core/tests/lib/functional_test.c
index d4822a12456525e4abc5f587bc897364db4e52b7..96781fb39b5f37b201345f60fe4297629bb672cf 100644
--- a/grub-core/tests/lib/functional_test.c
+++ b/grub-core/tests/lib/functional_test.c
@@ -26,14 +26,23 @@ GRUB_MOD_LICENSE ("GPLv3+");
 
 static grub_err_t
 grub_functional_test (grub_extcmd_context_t ctxt __attribute__ ((unused)),
-		      int argc __attribute__ ((unused)),
-		      char **args __attribute__ ((unused)))
+		      int argc,
+		      char **args)
 {
   grub_test_t test;
   int ok = 1;
+  int i;
 
   FOR_LIST_ELEMENTS (test, grub_test_list)
     {
+      if (argc != 0)
+	{
+	  for (i = 0; i < argc; i++)
+	    if (grub_strcmp(args[i], test->name) == 0)
+	      break;
+	  if (i == argc)
+	    continue;
+	}
       grub_errno = 0;
       ok = ok && !grub_test_run (test);
       grub_errno = 0;
diff --git a/grub-core/video/i386/coreboot/cbfb.c b/grub-core/video/coreboot/cbfb.c
similarity index 99%
rename from grub-core/video/i386/coreboot/cbfb.c
rename to grub-core/video/coreboot/cbfb.c
index dede0c37ea3e8a8948cd6535d26d008e117206bc..9af81fa5b01b63677d97ba9a242e60080df84e5a 100644
--- a/grub-core/video/i386/coreboot/cbfb.c
+++ b/grub-core/video/coreboot/cbfb.c
@@ -25,7 +25,7 @@
 #include <grub/mm.h>
 #include <grub/video.h>
 #include <grub/video_fb.h>
-#include <grub/machine/lbio.h>
+#include <grub/coreboot/lbio.h>
 #include <grub/machine/console.h>
 
 struct grub_linuxbios_table_framebuffer *grub_video_coreboot_fbtable;
diff --git a/util/grub-install-common.c b/util/grub-install-common.c
index 452b230daedc3db0296cab014e89ddacf1c21347..9e3e358c96ae20f2fecb3d70645a081d8ffd12de 100644
--- a/util/grub-install-common.c
+++ b/util/grub-install-common.c
@@ -73,6 +73,7 @@ grub_install_help_filter (int key, const char *text,
 
 static int (*compress_func) (const char *src, const char *dest) = NULL;
 char *grub_install_copy_buffer;
+static char *dtb;
 
 int
 grub_install_copy_file (const char *src,
@@ -364,6 +365,11 @@ grub_install_parse (int key, char *arg)
     case GRUB_INSTALL_OPTIONS_INSTALL_FONTS:
       handle_install_list (&install_fonts, arg, 0);
       return 1;
+    case GRUB_INSTALL_OPTIONS_DTB:
+      if (dtb)
+	free (dtb);
+      dtb = xstrdup (arg);
+      return 1;
     case GRUB_INSTALL_OPTIONS_INSTALL_COMPRESS:
       if (strcmp (arg, "no") == 0
 	  || strcmp (arg, "none") == 0)
@@ -486,9 +492,10 @@ grub_install_make_image_wrap_file (const char *dir, const char *prefix,
 
   grub_util_info ("grub-mkimage --directory '%s' --prefix '%s'"
 		  " --output '%s' "
+		  " --dtb '%s' "
 		  "--format '%s' --compression '%s' %s %s\n",
 		  dir, prefix,
-		  outname, mkimage_target,
+		  outname, dtb ? : "", mkimage_target,
 		  compnames[compression], note ? "--note" : "", s);
   free (s);
 
@@ -499,7 +506,7 @@ grub_install_make_image_wrap_file (const char *dir, const char *prefix,
   grub_install_generate_image (dir, prefix, fp, outname,
 			       modules.entries, memdisk_path,
 			       pubkeys, npubkeys, config_path, tgt,
-			       note, compression);
+			       note, compression, dtb);
   while (dc--)
     grub_install_pop_module ();
 }
@@ -666,6 +673,7 @@ static struct
     [GRUB_INSTALL_PLATFORM_ARM_EFI] =          { "arm",     "efi"       },
     [GRUB_INSTALL_PLATFORM_ARM64_EFI] =        { "arm64",   "efi"       },
     [GRUB_INSTALL_PLATFORM_ARM_UBOOT] =        { "arm",     "uboot"     },
+    [GRUB_INSTALL_PLATFORM_ARM_COREBOOT] =     { "arm",     "coreboot"  },
   }; 
 
 char *
diff --git a/util/grub-install.c b/util/grub-install.c
index 9074d3e9e52d2a2e215a10b2f8b3cf627ca80db3..75e3e5ba6f0738c89b4ee490d4ec630ce97fea4f 100644
--- a/util/grub-install.c
+++ b/util/grub-install.c
@@ -486,6 +486,7 @@ have_bootdev (enum grub_install_plat pl)
 
     case GRUB_INSTALL_PLATFORM_I386_QEMU:
     case GRUB_INSTALL_PLATFORM_I386_COREBOOT:
+    case GRUB_INSTALL_PLATFORM_ARM_COREBOOT:
     case GRUB_INSTALL_PLATFORM_I386_MULTIBOOT:
     case GRUB_INSTALL_PLATFORM_MIPSEL_QEMU_MIPS:
     case GRUB_INSTALL_PLATFORM_MIPS_QEMU_MIPS:
@@ -911,6 +912,7 @@ main (int argc, char *argv[])
 
     case GRUB_INSTALL_PLATFORM_I386_QEMU:
     case GRUB_INSTALL_PLATFORM_I386_COREBOOT:
+    case GRUB_INSTALL_PLATFORM_ARM_COREBOOT:
     case GRUB_INSTALL_PLATFORM_I386_MULTIBOOT:
     case GRUB_INSTALL_PLATFORM_MIPSEL_LOONGSON:
     case GRUB_INSTALL_PLATFORM_MIPSEL_QEMU_MIPS:
@@ -946,6 +948,7 @@ main (int argc, char *argv[])
     case GRUB_INSTALL_PLATFORM_ARM_UBOOT:
     case GRUB_INSTALL_PLATFORM_I386_QEMU:
     case GRUB_INSTALL_PLATFORM_I386_COREBOOT:
+    case GRUB_INSTALL_PLATFORM_ARM_COREBOOT:
     case GRUB_INSTALL_PLATFORM_I386_MULTIBOOT:
     case GRUB_INSTALL_PLATFORM_MIPSEL_LOONGSON:
     case GRUB_INSTALL_PLATFORM_MIPSEL_QEMU_MIPS:
@@ -1448,6 +1451,7 @@ main (int argc, char *argv[])
 		  case GRUB_INSTALL_PLATFORM_MIPSEL_LOONGSON:
 		  case GRUB_INSTALL_PLATFORM_I386_QEMU:
 		  case GRUB_INSTALL_PLATFORM_I386_COREBOOT:
+		  case GRUB_INSTALL_PLATFORM_ARM_COREBOOT:
 		  case GRUB_INSTALL_PLATFORM_I386_MULTIBOOT:
 		  case GRUB_INSTALL_PLATFORM_MIPSEL_QEMU_MIPS:
 		  case GRUB_INSTALL_PLATFORM_MIPS_QEMU_MIPS:
@@ -1542,6 +1546,7 @@ main (int argc, char *argv[])
       break;
 
     case GRUB_INSTALL_PLATFORM_I386_COREBOOT:
+    case GRUB_INSTALL_PLATFORM_ARM_COREBOOT:
     case GRUB_INSTALL_PLATFORM_I386_MULTIBOOT:
     case GRUB_INSTALL_PLATFORM_I386_IEEE1275:
     case GRUB_INSTALL_PLATFORM_POWERPC_IEEE1275:
@@ -1629,6 +1634,7 @@ main (int argc, char *argv[])
     case GRUB_INSTALL_PLATFORM_MIPSEL_QEMU_MIPS:
     case GRUB_INSTALL_PLATFORM_MIPS_QEMU_MIPS:
     case GRUB_INSTALL_PLATFORM_I386_COREBOOT:
+    case GRUB_INSTALL_PLATFORM_ARM_COREBOOT:
     case GRUB_INSTALL_PLATFORM_I386_MULTIBOOT:
     case GRUB_INSTALL_PLATFORM_I386_PC:
     case GRUB_INSTALL_PLATFORM_MIPSEL_ARC:
@@ -1889,6 +1895,7 @@ main (int argc, char *argv[])
     case GRUB_INSTALL_PLATFORM_MIPSEL_QEMU_MIPS:
     case GRUB_INSTALL_PLATFORM_MIPS_QEMU_MIPS:
     case GRUB_INSTALL_PLATFORM_I386_COREBOOT:
+    case GRUB_INSTALL_PLATFORM_ARM_COREBOOT:
     case GRUB_INSTALL_PLATFORM_I386_MULTIBOOT:
     case GRUB_INSTALL_PLATFORM_MIPSEL_ARC:
     case GRUB_INSTALL_PLATFORM_ARM_UBOOT:
diff --git a/util/grub-mkimage.c b/util/grub-mkimage.c
index aba19d21b9a774e63ad49f166554d90f8c667e36..98d24cc06ea57b88a4f02f38f177f44ec4f38f3f 100644
--- a/util/grub-mkimage.c
+++ b/util/grub-mkimage.c
@@ -71,6 +71,7 @@ static struct argp_option options[] = {
    N_("embed FILE as a memdisk image\n"
       "Implies `-p (memdisk)/boot/grub' and overrides any prefix supplied previously,"
       " but the prefix itself can be overridden by later options"), 0},
+  {"dtb",  'D', N_("FILE"), 0, N_("embed FILE as a device tree (DTB)\n"), 0},
    /* TRANSLATORS: "embed" is a verb (command description).  "*/
   {"config",   'c', N_("FILE"), 0, N_("embed FILE as an early config"), 0},
    /* TRANSLATORS: "embed" is a verb (command description).  "*/
@@ -117,6 +118,7 @@ struct arguments
   char *dir;
   char *prefix;
   char *memdisk;
+  char *dtb;
   char **pubkeys;
   size_t npubkeys;
   char *font;
@@ -176,6 +178,13 @@ argp_parser (int key, char *arg, struct argp_state *state)
       arguments->prefix = xstrdup ("(memdisk)/boot/grub");
       break;
 
+    case 'D':
+      if (arguments->dtb)
+	free (arguments->dtb);
+
+      arguments->dtb = xstrdup (arg);
+      break;
+
     case 'k':
       arguments->pubkeys = xrealloc (arguments->pubkeys,
 				     sizeof (arguments->pubkeys[0])
@@ -300,7 +309,7 @@ main (int argc, char *argv[])
 			       arguments.memdisk, arguments.pubkeys,
 			       arguments.npubkeys, arguments.config,
 			       arguments.image_target, arguments.note,
-			       arguments.comp);
+			       arguments.comp, arguments.dtb);
 
   grub_util_file_sync  (fp);
   fclose (fp);
diff --git a/util/grub-mkimagexx.c b/util/grub-mkimagexx.c
index e63f148e48cf6f66852b15063405f81371d95ae9..a2bb05439f0c5e8dcebc241f38e787ab1fdf4fb7 100644
--- a/util/grub-mkimagexx.c
+++ b/util/grub-mkimagexx.c
@@ -87,7 +87,8 @@ struct fixup_block_list
 static int
 is_relocatable (const struct grub_install_image_target_desc *image_target)
 {
-  return image_target->id == IMAGE_EFI || image_target->id == IMAGE_UBOOT;
+  return image_target->id == IMAGE_EFI || image_target->id == IMAGE_UBOOT
+    || (image_target->id == IMAGE_COREBOOT && image_target->elf_target == EM_ARM);
 }
 
 #ifdef MKIMAGE_ELF32
@@ -185,8 +186,8 @@ grub_arm_reloc_jump24 (grub_uint32_t *target, Elf32_Addr sym_addr)
 void
 SUFFIX (grub_mkimage_generate_elf) (const struct grub_install_image_target_desc *image_target,
 				    int note, char **core_img, size_t *core_size,
-				    Elf_Addr target_addr, grub_size_t align,
-				    size_t kernel_size, size_t bss_size)
+				    Elf_Addr target_addr,
+				    struct grub_mkimage_layout *layout)
 {
   char *elf_img;
   size_t program_size;
@@ -214,7 +215,7 @@ SUFFIX (grub_mkimage_generate_elf) (const struct grub_install_image_target_desc
       footer_size += XEN_NOTE_SIZE;
     }
   header_size = ALIGN_UP (sizeof (*ehdr) + phnum * sizeof (*phdr)
-			  + shnum * sizeof (*shdr) + string_size, align);
+			  + shnum * sizeof (*shdr) + string_size, layout->align);
 
   program_size = ALIGN_ADDR (*core_size);
 
@@ -258,7 +259,8 @@ SUFFIX (grub_mkimage_generate_elf) (const struct grub_install_image_target_desc
   ehdr->e_entry = grub_host_to_target32 (target_addr);
   phdr->p_vaddr = grub_host_to_target32 (target_addr);
   phdr->p_paddr = grub_host_to_target32 (target_addr);
-  phdr->p_align = grub_host_to_target32 (align > image_target->link_align ? align : image_target->link_align);
+  phdr->p_align = grub_host_to_target32 (layout->align > image_target->link_align ?
+					 layout->align : image_target->link_align);
   if (image_target->id == IMAGE_LOONGSON_ELF)
     ehdr->e_flags = grub_host_to_target32 (0x1000 | EF_MIPS_NOREORDER 
 					   | EF_MIPS_PIC | EF_MIPS_CPIC);
@@ -272,27 +274,34 @@ SUFFIX (grub_mkimage_generate_elf) (const struct grub_install_image_target_desc
   else
     {
       grub_uint32_t target_addr_mods;
-      phdr->p_filesz = grub_host_to_target32 (kernel_size);
-      phdr->p_memsz = grub_host_to_target32 (kernel_size + bss_size);
+      phdr->p_filesz = grub_host_to_target32 (layout->kernel_size);
+      if (image_target->id == IMAGE_COREBOOT && image_target->elf_target == EM_ARM)
+	phdr->p_memsz = grub_host_to_target32 (layout->kernel_size);
+      else
+	phdr->p_memsz = grub_host_to_target32 (layout->kernel_size + layout->bss_size);
 
       phdr++;
       phdr->p_type = grub_host_to_target32 (PT_GNU_STACK);
-      phdr->p_offset = grub_host_to_target32 (header_size + kernel_size);
+      phdr->p_offset = grub_host_to_target32 (header_size + layout->kernel_size);
       phdr->p_paddr = phdr->p_vaddr = phdr->p_filesz = phdr->p_memsz = 0;
       phdr->p_flags = grub_host_to_target32 (PF_R | PF_W | PF_X);
       phdr->p_align = grub_host_to_target32 (image_target->link_align);
 
       phdr++;
       phdr->p_type = grub_host_to_target32 (PT_LOAD);
-      phdr->p_offset = grub_host_to_target32 (header_size + kernel_size);
+      phdr->p_offset = grub_host_to_target32 (header_size + layout->kernel_size);
       phdr->p_flags = grub_host_to_target32 (PF_R | PF_W | PF_X);
       phdr->p_filesz = phdr->p_memsz
-	= grub_host_to_target32 (*core_size - kernel_size);
+	= grub_host_to_target32 (*core_size - layout->kernel_size);
 
-      if (image_target->id == IMAGE_COREBOOT)
+      if (image_target->id == IMAGE_COREBOOT && image_target->elf_target == EM_386)
 	target_addr_mods = GRUB_KERNEL_I386_COREBOOT_MODULES_ADDR;
+      else if (image_target->id == IMAGE_COREBOOT && image_target->elf_target == EM_ARM)
+	target_addr_mods = ALIGN_UP (target_addr + layout->end
+				     + image_target->mod_gap,
+				     image_target->mod_align);
       else
-	target_addr_mods = ALIGN_UP (target_addr + kernel_size + bss_size
+	target_addr_mods = ALIGN_UP (target_addr + layout->kernel_size + layout->bss_size
 				     + image_target->mod_gap,
 				     image_target->mod_align);
       phdr->p_vaddr = grub_host_to_target_addr (target_addr_mods);
@@ -434,7 +443,7 @@ SUFFIX (grub_mkimage_generate_elf) (const struct grub_install_image_target_desc
     shdr->sh_size = grub_host_to_target32 (string_size);
     shdr->sh_link = grub_host_to_target32 (0);
     shdr->sh_info = grub_host_to_target32 (0);
-    shdr->sh_addralign = grub_host_to_target32 (align);
+    shdr->sh_addralign = grub_host_to_target32 (layout->align);
     shdr->sh_entsize = grub_host_to_target32 (0);
     shdr++;
 
@@ -445,10 +454,10 @@ SUFFIX (grub_mkimage_generate_elf) (const struct grub_install_image_target_desc
     shdr->sh_type = grub_host_to_target32 (SHT_PROGBITS);
     shdr->sh_addr = grub_host_to_target_addr (target_addr);
     shdr->sh_offset = grub_host_to_target_addr (header_size);
-    shdr->sh_size = grub_host_to_target32 (kernel_size);
+    shdr->sh_size = grub_host_to_target32 (layout->kernel_size);
     shdr->sh_link = grub_host_to_target32 (0);
     shdr->sh_info = grub_host_to_target32 (0);
-    shdr->sh_addralign = grub_host_to_target32 (align);
+    shdr->sh_addralign = grub_host_to_target32 (layout->align);
     shdr->sh_entsize = grub_host_to_target32 (0);
     shdr++;
 
@@ -456,9 +465,9 @@ SUFFIX (grub_mkimage_generate_elf) (const struct grub_install_image_target_desc
     shdr->sh_name = grub_host_to_target32 (ptr - str_start);
     ptr += sizeof ("mods");
     shdr->sh_type = grub_host_to_target32 (SHT_PROGBITS);
-    shdr->sh_addr = grub_host_to_target_addr (target_addr + kernel_size);
-    shdr->sh_offset = grub_host_to_target_addr (header_size + kernel_size);
-    shdr->sh_size = grub_host_to_target32 (*core_size - kernel_size);
+    shdr->sh_addr = grub_host_to_target_addr (target_addr + layout->kernel_size);
+    shdr->sh_offset = grub_host_to_target_addr (header_size + layout->kernel_size);
+    shdr->sh_size = grub_host_to_target32 (*core_size - layout->kernel_size);
     shdr->sh_link = grub_host_to_target32 (0);
     shdr->sh_info = grub_host_to_target32 (0);
     shdr->sh_addralign = grub_host_to_target32 (image_target->voidp_sizeof);
@@ -471,7 +480,7 @@ SUFFIX (grub_mkimage_generate_elf) (const struct grub_install_image_target_desc
 	shdr->sh_name = grub_host_to_target32 (ptr - str_start);
 	ptr += sizeof (".xen");
 	shdr->sh_type = grub_host_to_target32 (SHT_PROGBITS);
-	shdr->sh_addr = grub_host_to_target_addr (target_addr + kernel_size);
+	shdr->sh_addr = grub_host_to_target_addr (target_addr + layout->kernel_size);
 	shdr->sh_offset = grub_host_to_target_addr (program_size + header_size);
 	shdr->sh_size = grub_host_to_target32 (XEN_NOTE_SIZE);
 	shdr->sh_link = grub_host_to_target32 (0);
@@ -1875,7 +1884,7 @@ SUFFIX (locate_sections) (Elf_Ehdr *e, const char *kernel_path,
      Platforms other than EFI and U-boot shouldn't have .bss in
      their binaries as we build with -Wl,-Ttext.
   */
-  if (image_target->id != IMAGE_UBOOT)
+  if (image_target->id == IMAGE_EFI || !is_relocatable (image_target))
     layout->kernel_size = layout->end;
 
   return section_addresses;
@@ -1978,6 +1987,7 @@ SUFFIX (grub_mkimage_load_image) (const char *kernel_path,
   if (image_target->id == IMAGE_SPARC64_AOUT
       || image_target->id == IMAGE_SPARC64_RAW
       || image_target->id == IMAGE_UBOOT
+      || image_target->id == IMAGE_COREBOOT
       || image_target->id == IMAGE_SPARC64_CDCORE)
     layout->kernel_size = ALIGN_UP (layout->kernel_size, image_target->mod_align);
 
@@ -2083,7 +2093,7 @@ SUFFIX (grub_mkimage_load_image) (const char *kernel_path,
 	   Platforms other than EFI and U-boot shouldn't have .bss in
 	   their binaries as we build with -Wl,-Ttext.
 	*/
-	|| (SUFFIX (is_bss_section) (s, image_target) && (image_target->id != IMAGE_UBOOT))
+	|| (SUFFIX (is_bss_section) (s, image_target) && (image_target->id == IMAGE_EFI || !is_relocatable (image_target)))
 	|| SUFFIX (is_text_section) (s, image_target))
       {
 	if (grub_target_to_host32 (s->sh_type) == SHT_NOBITS)
diff --git a/util/grub-mkrescue.c b/util/grub-mkrescue.c
index 238d4840e2f9613c6392e16cb88e7f413cae41c4..9545945d8f3b1a85dea8404fe1a0c9b3a3b84ba1 100644
--- a/util/grub-mkrescue.c
+++ b/util/grub-mkrescue.c
@@ -323,6 +323,7 @@ check_xorriso (const char *val)
   char *buf = NULL;
   size_t len = 0;
   int ret = 0;
+  int wstatus = 0;
 
   argv[0] = xorriso;
   argv[1] = "-as";
@@ -347,8 +348,10 @@ check_xorriso (const char *val)
     }
 
   close (fd);
-  waitpid (pid, NULL, 0);
+  waitpid (pid, &wstatus, 0);
   free (buf);
+  if (!WIFEXITED (wstatus) || WEXITSTATUS(wstatus) != 0)
+    return 0;
   return ret;
 }
 
@@ -426,6 +429,7 @@ main (int argc, char *argv[])
   char **argp_argv;
   int xorriso_tail_argc;
   char **xorriso_tail_argv;
+  int rv;
 
   grub_util_host_init (&argc, &argv);
   grub_util_disable_fd_syncs ();
@@ -478,6 +482,10 @@ main (int argc, char *argv[])
   if (!output_image)
     grub_util_error ("%s", _("output file must be specified"));
 
+  if (!check_xorriso ("graft-points")) {
+    grub_util_error ("%s", _("xorriso not found"));
+  }
+
   grub_init_all ();
   grub_hostfs_init ();
   grub_host_init ();
@@ -787,7 +795,6 @@ main (int argc, char *argv[])
       free (efidir_efi_boot);
 
       efiimgfat = grub_util_path_concat (2, iso9660_dir, "efi.img");
-      int rv;
       rv = grub_util_exec ((const char * []) { "mformat", "-C", "-f", "2880", "-L", "16", "-i",
 	    efiimgfat, "::", NULL });
       if (rv != 0)
@@ -960,7 +967,9 @@ main (int argc, char *argv[])
 
   xorriso_argv[xorriso_argc] = NULL;
 
-  grub_util_exec ((const char *const *)xorriso_argv);
+  rv = grub_util_exec ((const char *const *)xorriso_argv);
+  if (rv != 0)
+    grub_util_error ("`%s` invocation failed\n", "xorriso");
 
   grub_util_unlink_recursive (iso9660_dir);
 
diff --git a/util/mkimage.c b/util/mkimage.c
index 9ad4cfe4223b661c11ab9d3783cb13c88100631c..e22d82afa61a6aa4209c7ab6d2aa5b58f95e1bfe 100644
--- a/util/mkimage.c
+++ b/util/mkimage.c
@@ -533,6 +533,45 @@ static const struct grub_install_image_target_desc image_targets[] =
       .mod_align = GRUB_KERNEL_ARM_UBOOT_MOD_ALIGN,
       .link_align = 4
     },
+    /* For coreboot versions that don't support self-relocating images. */
+    {
+      .dirname = "arm-coreboot-vexpress",
+      .names = { "arm-coreboot-vexpress", NULL },
+      .voidp_sizeof = 4,
+      .bigendian = 0,
+      .id = IMAGE_COREBOOT,
+      .flags = PLATFORM_FLAGS_NONE,
+      .total_module_size = GRUB_KERNEL_ARM_COREBOOT_TOTAL_MODULE_SIZE,
+      .decompressor_compressed_size = TARGET_NO_FIELD,
+      .decompressor_uncompressed_size = TARGET_NO_FIELD,
+      .decompressor_uncompressed_addr = TARGET_NO_FIELD,
+      .section_align = GRUB_KERNEL_ARM_COREBOOT_MOD_ALIGN,
+      .vaddr_offset = 0,
+      .elf_target = EM_ARM,
+      .mod_gap = GRUB_KERNEL_ARM_COREBOOT_MOD_GAP,
+      .mod_align = GRUB_KERNEL_ARM_COREBOOT_MOD_ALIGN,
+      .link_align = 4,
+      .link_addr = 0x62000000,
+    },
+    {
+      .dirname = "arm-coreboot-veyron",
+      .names = { "arm-coreboot-veyron", NULL },
+      .voidp_sizeof = 4,
+      .bigendian = 0,
+      .id = IMAGE_COREBOOT,
+      .flags = PLATFORM_FLAGS_NONE,
+      .total_module_size = GRUB_KERNEL_ARM_COREBOOT_TOTAL_MODULE_SIZE,
+      .decompressor_compressed_size = TARGET_NO_FIELD,
+      .decompressor_uncompressed_size = TARGET_NO_FIELD,
+      .decompressor_uncompressed_addr = TARGET_NO_FIELD,
+      .section_align = GRUB_KERNEL_ARM_COREBOOT_MOD_ALIGN,
+      .vaddr_offset = 0,
+      .elf_target = EM_ARM,
+      .mod_gap = GRUB_KERNEL_ARM_COREBOOT_MOD_GAP,
+      .mod_align = GRUB_KERNEL_ARM_COREBOOT_MOD_ALIGN,
+      .link_align = 4,
+      .link_addr = 0x43000000,
+    },
     {
       .dirname = "arm-efi",
       .names = { "arm-efi", NULL },
@@ -738,13 +777,12 @@ grub_install_generate_image (const char *dir, const char *prefix,
 			     char *memdisk_path, char **pubkey_paths,
 			     size_t npubkeys, char *config_path,
 			     const struct grub_install_image_target_desc *image_target,
-			     int note,
-			     grub_compression_t comp)
+			     int note, grub_compression_t comp, const char *dtb_path)
 {
   char *kernel_img, *core_img;
   size_t total_module_size, core_size;
   size_t memdisk_size = 0, config_size = 0;
-  size_t prefix_size = 0;
+  size_t prefix_size = 0, dtb_size = 0;
   char *kernel_path;
   size_t offset;
   struct grub_util_path_list *path_list, *p;
@@ -789,6 +827,12 @@ grub_install_generate_image (const char *dir, const char *prefix,
       total_module_size += memdisk_size + sizeof (struct grub_module_header);
     }
 
+  if (dtb_path)
+    {
+      dtb_size = ALIGN_UP(grub_util_get_image_size (dtb_path), 4);
+      total_module_size += dtb_size + sizeof (struct grub_module_header);
+    }
+
   if (config_path)
     {
       config_size = ALIGN_ADDR (grub_util_get_image_size (config_path) + 1);
@@ -911,6 +955,19 @@ grub_install_generate_image (const char *dir, const char *prefix,
       offset += memdisk_size;
     }
 
+  if (dtb_path)
+    {
+      struct grub_module_header *header;
+
+      header = (struct grub_module_header *) (kernel_img + offset);
+      header->type = grub_host_to_target32 (OBJ_TYPE_DTB);
+      header->size = grub_host_to_target32 (dtb_size + sizeof (*header));
+      offset += sizeof (*header);
+
+      grub_util_load_image (dtb_path, kernel_img + offset);
+      offset += dtb_size;
+    }
+
   if (config_path)
     {
       struct grub_module_header *header;
@@ -1033,7 +1090,7 @@ grub_install_generate_image (const char *dir, const char *prefix,
 	/* fallthrough */
     case IMAGE_COREBOOT:
     case IMAGE_QEMU:
-	if (layout.kernel_size + layout.bss_size + GRUB_KERNEL_I386_PC_LINK_ADDR > 0x68000)
+	if (image_target->elf_target != EM_ARM && layout.kernel_size + layout.bss_size + GRUB_KERNEL_I386_PC_LINK_ADDR > 0x68000)
 	  grub_util_error (_("kernel image is too big (0x%x > 0x%x)"),
 			   (unsigned) layout.kernel_size + (unsigned) layout.bss_size
 			   + GRUB_KERNEL_I386_PC_LINK_ADDR,
@@ -1638,10 +1695,10 @@ grub_install_generate_image (const char *dir, const char *prefix,
 	  target_addr = image_target->link_addr;
 	if (image_target->voidp_sizeof == 4)
 	  grub_mkimage_generate_elf32 (image_target, note, &core_img, &core_size,
-				       target_addr, layout.align, layout.kernel_size, layout.bss_size);
+				       target_addr, &layout);
 	else
 	  grub_mkimage_generate_elf64 (image_target, note, &core_img, &core_size,
-				       target_addr, layout.align, layout.kernel_size, layout.bss_size);
+				       target_addr, &layout);
       }
       break;
     }
diff --git a/grub-core/tests/checksums.h b/grub-core/tests/checksums.h
index 68d8ce7c7753ff721ab0d5a12d40b2aff20c694c..921e57ff48d0be9ecf5d45a75ce1711d262cf7a8 100644
--- a/grub-core/tests/checksums.h
+++ b/grub-core/tests/checksums.h
@@ -1,101 +1,101 @@
-  { "cmdline_cat", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xcd5fc34e, 0xcd5fc34e, 0xeabbecab, 0xeabbecab, 0xc9950151, 0xc9950151, 0x2be222b6, 0x2be222b6, 0xe88c769e, 0xe88c769e, 0x6be4910e, 0x6be4910e, 0x1dc1fe4f, 0x1dc1fe4f, 0xd7613e8f, 0xd7613e8f, 0xf8124196, 0xf8124196, 0x130f5935, 0x130f5935, 0x2872330e, 0x2872330e, 0xaa7b7868, 0xaa7b7868, 0x558eaeea, 0x558eaeea, 0x92f7960f, 0x92f7960f, 0xc5bfc709, 0xc5bfc709, 0x699732fe, 0x699732fe, 0xc859125f, 0xc859125f, 0xfc6ac729, 0xfc6ac729, 0xcdab6cd4, 0xcdab6cd4, 0x58a8b7f8, 0x58a8b7f8, 0xc0e73385, 0x6560d6ef, 0x3be8bb5d, 0x3be8bb5d, }, 45 },
-  { "cmdline_cat", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x13029f94, 0x13029f94, 0x7785fdab, 0x7785fdab, 0x95a7c1e8, 0x95a7c1e8, 0x315ab3e3, 0x315ab3e3, 0x6787f012, 0x6787f012, 0x79b1ecdc, 0x79b1ecdc, 0xdbc67810, 0xdbc67810, 0xafaa982e, 0xafaa982e, 0xc5cd0157, 0xc5cd0157, 0x3c50dd64, 0x3c50dd64, 0x1056cac0, 0x1056cac0, 0x1d7a41fa, 0x1d7a41fa, 0x5690b1e8, 0x5690b1e8, 0x616831d6, 0x616831d6, 0xfaf8e726, 0xfaf8e726, 0xd1ec5e26, 0xd1ec5e26, 0x3c269e1f, 0x3c269e1f, 0x1aa7952d, 0x1aa7952d, 0x6e7e2f99, 0x6e7e2f99, 0x98f4c02, 0x98f4c02, 0xc3f1abf2, 0xe348bb73, 0xea53cd60, 0xea53cd60, }, 45 },
-  { "cmdline_cat", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x8fbb4f4c, 0x8fbb4f4c, 0x5dc00167, 0x5dc00167, 0xbc124df8, 0xbc124df8, 0x31cf0f8e, 0x31cf0f8e, 0x798cc4ed, 0x798cc4ed, 0xc5d2a091, 0xc5d2a091, 0xb58a0591, 0xb58a0591, 0x4d118aca, 0x4d118aca, 0xbb06c7ee, 0xbb06c7ee, 0x42179db7, 0x42179db7, 0x65f2d81e, 0x65f2d81e, 0xa2628bcb, 0xa2628bcb, 0xbdb7f4b, 0xbdb7f4b, 0x66b10309, 0x66b10309, 0x1a550ea9, 0x1a550ea9, 0x377a297d, 0x377a297d, 0x2ea99015, 0x2ea99015, 0x4e20d7bc, 0x4e20d7bc, 0x8ecbde02, 0x8ecbde02, 0xdfa2195a, 0xdfa2195a, 0xe113d2a, 0xe204ee5b, 0x734679c1, 0x734679c1, }, 45 },
-  { "cmdline_cat", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0xe2f6bfe1, 0xe2f6bfe1, 0xf18aee15, 0xf18aee15, 0x5e83b689, 0x5e83b689, 0xb7e8b42c, 0xb7e8b42c, 0x85d78f92, 0x85d78f92, 0xd56fadae, 0xd56fadae, 0x7632f5bf, 0x7632f5bf, 0x2769a748, 0x2769a748, 0x4a6112cd, 0x4a6112cd, 0x4f9b66a4, 0x4f9b66a4, 0x70457d38, 0x70457d38, 0x8cadb1a7, 0x8cadb1a7, 0x451341f, 0x451341f, 0x8a62e741, 0x8a62e741, 0x1b1f9031, 0x1b1f9031, 0x75ab630e, 0x75ab630e, 0xd5ff53ac, 0xd5ff53ac, 0x73a2b3c7, 0x73a2b3c7, 0x7b52acd5, 0x7b52acd5, 0xf6f3e48c, 0xf6f3e48c, 0x8d0db133, 0x8db24310, 0x7aef56d4, 0x7aef56d4, }, 45 },
-  { "cmdline_cat", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x838a3f40, 0x838a3f40, 0x7351ba96, 0x7351ba96, 0x660963bb, 0x660963bb, 0x6f3362a6, 0x6f3362a6, 0x915d35d9, 0x915d35d9, 0xc7edaee9, 0xc7edaee9, 0xbc8ec24c, 0xbc8ec24c, 0xeb120ffd, 0xeb120ffd, 0x8f6d8232, 0x8f6d8232, 0x2de5d515, 0x2de5d515, 0x4f2ecd91, 0x4f2ecd91, 0x555a9b90, 0x555a9b90, 0x8f7b0d77, 0x8f7b0d77, 0x5f9536af, 0x5f9536af, 0x3dd79dbe, 0x3dd79dbe, 0xb555a0, 0xb555a0, 0x75aec882, 0x75aec882, 0xd5da89cb, 0xd5da89cb, 0xb47b3257, 0xb47b3257, 0x7c97c046, 0x7c97c046, 0x726a7abe, 0x4c8b8a56, 0xcffa0854, 0xcffa0854, }, 45 },
-  { "cmdline_cat", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x7bf761e, 0x7bf761e, 0xaf0b6dae, 0xaf0b6dae, 0x7db15930, 0x7db15930, 0xc9720d56, 0xc9720d56, 0x55590d6c, 0x55590d6c, 0xa0d193d9, 0xa0d193d9, 0x728987b2, 0x728987b2, 0x28aecde6, 0x28aecde6, 0xa59bb094, 0xa59bb094, 0x2d0b049d, 0x2d0b049d, 0xd8421240, 0xd8421240, 0x51fa339, 0x51fa339, 0xc625cc46, 0xc625cc46, 0x2c9e6fcc, 0x2c9e6fcc, 0x3d06ffd5, 0x3d06ffd5, 0x8dd72816, 0x8dd72816, 0xfcf2a982, 0xfcf2a982, 0x6ef2870f, 0x6ef2870f, 0xba2caab7, 0xba2caab7, 0x8e5a5872, 0x8e5a5872, 0x62b2fedc, 0x2bd3b588, 0x34ebdb15, 0x34ebdb15, }, 45 },
-  { "cmdline_cat", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0xa133280a, 0xa133280a, 0x1e8f4227, 0x1e8f4227, 0xa01cd911, 0xa01cd911, 0xdcb3d617, 0xdcb3d617, 0x51200351, 0x51200351, 0x609ba305, 0x609ba305, 0x5d96abfd, 0x5d96abfd, 0xd855cc70, 0xd855cc70, 0xdbfaf18d, 0xdbfaf18d, 0x84814843, 0x84814843, 0x4b00e630, 0x4b00e630, 0xd362b0f5, 0xd362b0f5, 0xec863355, 0xec863355, 0x195898d0, 0x195898d0, 0xe8c698c7, 0xe8c698c7, 0x884229e7, 0x884229e7, 0xb41ed3a9, 0xb41ed3a9, 0x2be1ce40, 0x2be1ce40, 0x8c33eb7c, 0x8c33eb7c, 0xbbce1da, 0xbbce1da, 0xef9415fa, 0x22fbc0d, 0xd82c182c, 0xd82c182c, }, 45 },
-  { "gfxterm_menu", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xbe029c, 0x6671ee1f, 0xbe029c, 0x4348cfdb, 0x59c36f00, 0x59c36f00, 0x3ad73295, 0x3ad73295, 0x3ad73295, 0x44575ff3, 0x44575ff3, 0x44575ff3, 0x26a14a21, 0x26a14a21, 0x26a14a21, 0x59c36f00, 0x4348cfdb, 0x4348cfdb, 0x59c36f00, }, 20 },
-  { "gfxterm_menu", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x14e228ef, 0xb0c8af57, 0x14e228ef, 0x3ae7ad90, 0xaa4593fe, 0xaa4593fe, 0xbec19c1b, 0xbec19c1b, 0xbec19c1b, 0x1834917c, 0x1834917c, 0x1834917c, 0x350c3a04, 0x350c3a04, 0x350c3a04, 0xaa4593fe, 0x3ae7ad90, 0x3ae7ad90, 0xaa4593fe, }, 20 },
-  { "gfxterm_menu", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x651fb144, 0xdf93ee9c, 0x651fb144, 0x3808dcc0, 0xc9cbf769, 0xc9cbf769, 0xe4861949, 0xe4861949, 0xe4861949, 0x1a5ed885, 0x1a5ed885, 0x1a5ed885, 0xf314678d, 0xf314678d, 0xf314678d, 0xc9cbf769, 0x3808dcc0, 0x3808dcc0, 0xc9cbf769, }, 20 },
-  { "gfxterm_menu", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0xdfd0119e, 0x6c7018a9, 0xdfd0119e, 0x71865846, 0x9813a416, 0x9813a416, 0xb5e8801c, 0xb5e8801c, 0xb5e8801c, 0x2433062f, 0x2433062f, 0x2433062f, 0x3d893bff, 0x3d893bff, 0x3d893bff, 0x9813a416, 0x71865846, 0x71865846, 0x9813a416, }, 20 },
-  { "gfxterm_menu", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x4e4844e0, 0x5ebe5f81, 0x4e4844e0, 0x38ee7153, 0x5fcf013d, 0x5fcf013d, 0x819b5c4e, 0x819b5c4e, 0x819b5c4e, 0x538b4438, 0x538b4438, 0x538b4438, 0x45f87ba7, 0x45f87ba7, 0x45f87ba7, 0x5fcf013d, 0x38ee7153, 0x38ee7153, 0x5fcf013d, }, 20 },
-  { "gfxterm_menu", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x701427d4, 0x246c830a, 0x701427d4, 0x6b11fdd3, 0xdd28f52b, 0xdd28f52b, 0xcd83646c, 0xcd83646c, 0xcd83646c, 0xecbf9d88, 0xecbf9d88, 0xecbf9d88, 0x91075604, 0x91075604, 0x91075604, 0xdd28f52b, 0x6b11fdd3, 0x6b11fdd3, 0xdd28f52b, }, 20 },
-  { "gfxterm_menu", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x7b5bd4c, 0xac246af1, 0x7b5bd4c, 0xf80aa6cc, 0x43d1f34, 0x43d1f34, 0xb200c08a, 0xb200c08a, 0xb200c08a, 0xcd0a6922, 0xcd0a6922, 0xcd0a6922, 0x545b6ca4, 0x545b6ca4, 0x545b6ca4, 0x43d1f34, 0xf80aa6cc, 0xf80aa6cc, 0x43d1f34, }, 20 },
-  { "gfxmenu", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x1027210c, 0x64e51c81, 0x1027210c, 0x45ca4a8a, 0x9a2e0d26, 0x12fd0f21, 0x12fd0f21, 0x12fd0f21, 0x4e25f9e1, 0x4e25f9e1, 0x4e25f9e1, 0x67bd3773, 0x67bd3773, 0x67bd3773, 0x59c36f00, 0x45ca4a8a, 0x45ca4a8a, }, 18 },
-  { "gfxmenu", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x8d12f697, 0xc5b32248, 0x8d12f697, 0x56720aa4, 0xa9d58ccd, 0xf766a14d, 0xf766a14d, 0xf766a14d, 0xa2390b47, 0xa2390b47, 0xa2390b47, 0xcb0ac30e, 0xcb0ac30e, 0xcb0ac30e, 0xaa4593fe, 0x56720aa4, 0x56720aa4, }, 18 },
-  { "gfxmenu", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xa5ec9f45, 0xdb7085d8, 0xa5ec9f45, 0x9caf1d3f, 0x5411be8b, 0xedc0ad83, 0xedc0ad83, 0xedc0ad83, 0x927e0b17, 0x927e0b17, 0x927e0b17, 0xd00a6b6f, 0xd00a6b6f, 0xd00a6b6f, 0xc9cbf769, 0x9caf1d3f, 0x9caf1d3f, }, 18 },
-  { "gfxmenu", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x1c3742c9, 0xce8e83bf, 0xeb96c838, 0xce8e83bf, 0x73cb3bc1, 0x740d78cf, 0xb35c7e64, 0xb35c7e64, 0xb35c7e64, 0x58f99418, 0x58f99418, 0x58f99418, 0x5eb294e8, 0x5eb294e8, 0x5eb294e8, 0x1c3742c9, 0x73cb3bc1, 0x73cb3bc1, }, 18 },
-  { "gfxmenu", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0xcc5a7bed, 0x56a03e51, 0xee7d8d4b, 0x56a03e51, 0x5bdf9413, 0xbcda144c, 0x220f7a5e, 0x220f7a5e, 0x220f7a5e, 0x4d46a64f, 0x4d46a64f, 0x4d46a64f, 0x40b0384c, 0x40b0384c, 0x40b0384c, 0xcc5a7bed, 0x5bdf9413, 0x5bdf9413, }, 18 },
-  { "gfxmenu", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xef4a3312, 0xea8a9cf0, 0x8929e522, 0xea8a9cf0, 0x78f3dfbc, 0x5d55a141, 0x377f1aeb, 0x377f1aeb, 0x377f1aeb, 0xf1cd5ef5, 0xf1cd5ef5, 0xf1cd5ef5, 0xe5a88e4a, 0xe5a88e4a, 0xe5a88e4a, 0xef4a3312, 0x78f3dfbc, 0x78f3dfbc, }, 18 },
-  { "gfxmenu", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x54e48d80, 0x6dcf1d57, 0x925a4c8f, 0x6dcf1d57, 0x69005b38, 0x6d6bb4bc, 0x756a36b9, 0x756a36b9, 0x756a36b9, 0xf499c068, 0xf499c068, 0xf499c068, 0x623d7907, 0x623d7907, 0x623d7907, 0x54e48d80, 0x69005b38, 0x69005b38, }, 18 },
-  { "gfxterm_ar", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xa49d26b0, 0xaa7d9b28, 0xa49d26b0, 0xe76bebf7, 0x59c36f00, 0x59c36f00, 0xea6ab252, 0xea6ab252, 0xea6ab252, 0x94eadf34, 0x94eadf34, 0x94eadf34, 0xf61ccae6, 0xf61ccae6, 0xf61ccae6, 0x59c36f00, 0xe76bebf7, 0xe76bebf7, 0x59c36f00, }, 20 },
-  { "gfxterm_ar", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x7a277db, 0xf3bf80f7, 0x7a277db, 0x29a7f2a4, 0xaa4593fe, 0xaa4593fe, 0xf1cd57e3, 0xf1cd57e3, 0xf1cd57e3, 0x57385a84, 0x57385a84, 0x57385a84, 0x7a00f1fc, 0x7a00f1fc, 0x7a00f1fc, 0xaa4593fe, 0x29a7f2a4, 0x29a7f2a4, 0xaa4593fe, }, 20 },
-  { "gfxterm_ar", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x631edf85, 0x71926408, 0x631edf85, 0x3e09b201, 0xc9cbf769, 0xc9cbf769, 0xf224ab3, 0xf224ab3, 0xf224ab3, 0xf1fa8b7f, 0xf1fa8b7f, 0xf1fa8b7f, 0x18b03477, 0x18b03477, 0x18b03477, 0xc9cbf769, 0x3e09b201, 0x3e09b201, 0xc9cbf769, }, 20 },
-  { "gfxterm_ar", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0xfbaf4635, 0xe69ef474, 0xfbaf4635, 0x55f90fed, 0x9813a416, 0x9813a416, 0x3aad8f41, 0x3aad8f41, 0x3aad8f41, 0xab760972, 0xab760972, 0xab760972, 0xb2cc34a2, 0xb2cc34a2, 0xb2cc34a2, 0x9813a416, 0x55f90fed, 0x55f90fed, 0x9813a416, }, 20 },
-  { "gfxterm_ar", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0xdce50745, 0x1d8009e4, 0xdce50745, 0xaa4332f6, 0x5fcf013d, 0x5fcf013d, 0x354e5749, 0x354e5749, 0x354e5749, 0xe75e4f3f, 0xe75e4f3f, 0xe75e4f3f, 0xf12d70a0, 0xf12d70a0, 0xf12d70a0, 0x5fcf013d, 0xaa4332f6, 0xaa4332f6, 0x5fcf013d, }, 20 },
-  { "gfxterm_ar", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x3efebeff, 0xf101dfe2, 0x3efebeff, 0x25fb64f8, 0xdd28f52b, 0xdd28f52b, 0x70c69ebd, 0x70c69ebd, 0x70c69ebd, 0x51fa6759, 0x51fa6759, 0x51fa6759, 0x2c42acd5, 0x2c42acd5, 0x2c42acd5, 0xdd28f52b, 0x25fb64f8, 0x25fb64f8, 0xdd28f52b, }, 20 },
-  { "gfxterm_ar", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x59a34c64, 0x281cca78, 0x59a34c64, 0xa61c57e4, 0x43d1f34, 0x43d1f34, 0x95131d4, 0x95131d4, 0x95131d4, 0x765b987c, 0x765b987c, 0x765b987c, 0xef0a9dfa, 0xef0a9dfa, 0xef0a9dfa, 0x43d1f34, 0xa61c57e4, 0xa61c57e4, 0x43d1f34, }, 20 },
-  { "gfxterm_cyr", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xa37c165, 0x72063383, 0xa37c165, 0x49c10c22, 0x59c36f00, 0x59c36f00, 0x4e53de8e, 0x4e53de8e, 0x4e53de8e, 0x30d3b3e8, 0x30d3b3e8, 0x30d3b3e8, 0x5225a63a, 0x5225a63a, 0x5225a63a, 0x59c36f00, 0x49c10c22, 0x49c10c22, 0x59c36f00, }, 20 },
-  { "gfxterm_cyr", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x45bba0ba, 0xe60fd0b6, 0x45bba0ba, 0x6bbe25c5, 0xaa4593fe, 0xaa4593fe, 0x28de2b41, 0x28de2b41, 0x28de2b41, 0x8e2b2626, 0x8e2b2626, 0x8e2b2626, 0xa3138d5e, 0xa3138d5e, 0xa3138d5e, 0xaa4593fe, 0x6bbe25c5, 0x6bbe25c5, 0xaa4593fe, }, 20 },
-  { "gfxterm_cyr", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xb43d4e9d, 0x16f88820, 0xb43d4e9d, 0xe92a2319, 0xc9cbf769, 0xc9cbf769, 0xb8959ec7, 0xb8959ec7, 0xb8959ec7, 0x464d5f0b, 0x464d5f0b, 0x464d5f0b, 0xaf07e003, 0xaf07e003, 0xaf07e003, 0xc9cbf769, 0xe92a2319, 0xe92a2319, 0xc9cbf769, }, 20 },
-  { "gfxterm_cyr", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x46760365, 0x685ae30e, 0x46760365, 0xe8204abd, 0x9813a416, 0x9813a416, 0x8896050a, 0x8896050a, 0x8896050a, 0x194d8339, 0x194d8339, 0x194d8339, 0xf7bee9, 0xf7bee9, 0xf7bee9, 0x9813a416, 0xe8204abd, 0xe8204abd, 0x9813a416, }, 20 },
-  { "gfxterm_cyr", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x6859aa86, 0xf3f11deb, 0x6859aa86, 0x1eff9f35, 0x5fcf013d, 0x5fcf013d, 0xd72b1482, 0xd72b1482, 0xd72b1482, 0x53b0cf4, 0x53b0cf4, 0x53b0cf4, 0x1348336b, 0x1348336b, 0x1348336b, 0x5fcf013d, 0x1eff9f35, 0x1eff9f35, 0x5fcf013d, }, 20 },
-  { "gfxterm_cyr", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x688451e7, 0xf6936b72, 0x688451e7, 0x73818be0, 0xdd28f52b, 0xdd28f52b, 0xf12a65ac, 0xf12a65ac, 0xf12a65ac, 0xd0169c48, 0xd0169c48, 0xd0169c48, 0xadae57c4, 0xadae57c4, 0xadae57c4, 0xdd28f52b, 0x73818be0, 0x73818be0, 0xdd28f52b, }, 20 },
-  { "gfxterm_cyr", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x9616af94, 0xd466be40, 0x9616af94, 0x69a9b414, 0x43d1f34, 0x43d1f34, 0xf3bb3240, 0xf3bb3240, 0xf3bb3240, 0x8cb19be8, 0x8cb19be8, 0x8cb19be8, 0x15e09e6e, 0x15e09e6e, 0x15e09e6e, 0x43d1f34, 0x69a9b414, 0x69a9b414, 0x43d1f34, }, 20 },
-  { "gfxterm_heb", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x8708d1bd, 0x85dd5e9c, 0x8708d1bd, 0xc4fe1cfa, 0x59c36f00, 0x59c36f00, 0x7ae8aced, 0x7ae8aced, 0x7ae8aced, 0x468c18b, 0x468c18b, 0x468c18b, 0x669ed459, 0x669ed459, 0x669ed459, 0x59c36f00, 0xc4fe1cfa, 0xc4fe1cfa, 0x59c36f00, }, 20 },
-  { "gfxterm_heb", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0xa72b1043, 0x147d4ce0, 0xa72b1043, 0x892e953c, 0xaa4593fe, 0xaa4593fe, 0xb7b1dd40, 0xb7b1dd40, 0xb7b1dd40, 0x1144d027, 0x1144d027, 0x1144d027, 0x3c7c7b5f, 0x3c7c7b5f, 0x3c7c7b5f, 0xaa4593fe, 0x892e953c, 0x892e953c, 0xaa4593fe, }, 20 },
-  { "gfxterm_heb", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xc5fb1817, 0x745fb26c, 0xc5fb1817, 0x98ec7593, 0xc9cbf769, 0xc9cbf769, 0xf5f17e2d, 0xf5f17e2d, 0xf5f17e2d, 0xb29bfe1, 0xb29bfe1, 0xb29bfe1, 0xe26300e9, 0xe26300e9, 0xe26300e9, 0xc9cbf769, 0x98ec7593, 0x98ec7593, 0xc9cbf769, }, 20 },
-  { "gfxterm_heb", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x4be837e1, 0xbf4963ca, 0x4be837e1, 0xe5be7e39, 0x9813a416, 0x9813a416, 0xd886fca0, 0xd886fca0, 0xd886fca0, 0x495d7a93, 0x495d7a93, 0x495d7a93, 0x50e74743, 0x50e74743, 0x50e74743, 0x9813a416, 0xe5be7e39, 0xe5be7e39, 0x9813a416, }, 20 },
-  { "gfxterm_heb", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x21a8ccb8, 0x17719be, 0x21a8ccb8, 0x570ef90b, 0x5fcf013d, 0x5fcf013d, 0x2a7b5333, 0x2a7b5333, 0x2a7b5333, 0xf86b4b45, 0xf86b4b45, 0xf86b4b45, 0xee1874da, 0xee1874da, 0xee1874da, 0x5fcf013d, 0x570ef90b, 0x570ef90b, 0x5fcf013d, }, 20 },
-  { "gfxterm_heb", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x7001fe50, 0x4798153f, 0x7001fe50, 0x6b042457, 0xdd28f52b, 0xdd28f52b, 0x46489369, 0x46489369, 0x46489369, 0x67746a8d, 0x67746a8d, 0x67746a8d, 0x1acca101, 0x1acca101, 0x1acca101, 0xdd28f52b, 0x6b042457, 0x6b042457, 0xdd28f52b, }, 20 },
-  { "gfxterm_heb", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x6e10591c, 0x48bd926e, 0x6e10591c, 0x91af429c, 0x43d1f34, 0x43d1f34, 0x59cb829, 0x59cb829, 0x59cb829, 0x7a961181, 0x7a961181, 0x7a961181, 0xe3c71407, 0xe3c71407, 0xe3c71407, 0x43d1f34, 0x91af429c, 0x91af429c, 0x43d1f34, }, 20 },
-  { "gfxterm_gre", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x67627ed5, 0xdb276cef, 0x67627ed5, 0x2494b392, 0x59c36f00, 0x59c36f00, 0x43f511f3, 0x43f511f3, 0x43f511f3, 0x3d757c95, 0x3d757c95, 0x3d757c95, 0x5f836947, 0x5f836947, 0x5f836947, 0x59c36f00, 0x2494b392, 0x2494b392, 0x59c36f00, }, 20 },
-  { "gfxterm_gre", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x987cbf71, 0x6e4c645c, 0x987cbf71, 0xb6793a0e, 0xaa4593fe, 0xaa4593fe, 0xb943d716, 0xb943d716, 0xb943d716, 0x1fb6da71, 0x1fb6da71, 0x1fb6da71, 0x328e7109, 0x328e7109, 0x328e7109, 0xaa4593fe, 0xb6793a0e, 0xb6793a0e, 0xaa4593fe, }, 20 },
-  { "gfxterm_gre", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xf9987c07, 0x4a92eed9, 0xf9987c07, 0xa48f1183, 0xc9cbf769, 0xc9cbf769, 0x5eb3ddf4, 0x5eb3ddf4, 0x5eb3ddf4, 0xa06b1c38, 0xa06b1c38, 0xa06b1c38, 0x4921a330, 0x4921a330, 0x4921a330, 0xc9cbf769, 0xa48f1183, 0xa48f1183, 0xc9cbf769, }, 20 },
-  { "gfxterm_gre", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0xccd804e2, 0xb99e8d91, 0xccd804e2, 0x628e4d3a, 0x9813a416, 0x9813a416, 0x5aec5acc, 0x5aec5acc, 0x5aec5acc, 0xcb37dcff, 0xcb37dcff, 0xcb37dcff, 0xd28de12f, 0xd28de12f, 0xd28de12f, 0x9813a416, 0x628e4d3a, 0x628e4d3a, 0x9813a416, }, 20 },
-  { "gfxterm_gre", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x4990d896, 0x2b3aa242, 0x4990d896, 0x3f36ed25, 0x5fcf013d, 0x5fcf013d, 0x3cc6048d, 0x3cc6048d, 0x3cc6048d, 0xeed61cfb, 0xeed61cfb, 0xeed61cfb, 0xf8a52364, 0xf8a52364, 0xf8a52364, 0x5fcf013d, 0x3f36ed25, 0x3f36ed25, 0x5fcf013d, }, 20 },
-  { "gfxterm_gre", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x4ff5c69f, 0x66586489, 0x4ff5c69f, 0x54f01c98, 0xdd28f52b, 0xdd28f52b, 0xc3ff0bf5, 0xc3ff0bf5, 0xc3ff0bf5, 0xe2c3f211, 0xe2c3f211, 0xe2c3f211, 0x9f7b399d, 0x9f7b399d, 0x9f7b399d, 0xdd28f52b, 0x54f01c98, 0x54f01c98, 0xdd28f52b, }, 20 },
-  { "gfxterm_gre", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x909b7bb4, 0x2bb2a58c, 0x909b7bb4, 0x6f246034, 0x43d1f34, 0x43d1f34, 0x2df40751, 0x2df40751, 0x2df40751, 0x52feaef9, 0x52feaef9, 0x52feaef9, 0xcbafab7f, 0xcbafab7f, 0xcbafab7f, 0x43d1f34, 0x6f246034, 0x6f246034, 0x43d1f34, }, 20 },
-  { "gfxterm_ru", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xc77bfcc6, 0xffcdf45d, 0xc77bfcc6, 0x848d3181, 0x59c36f00, 0x59c36f00, 0xd79cd5e, 0xd79cd5e, 0xd79cd5e, 0x73f9a038, 0x73f9a038, 0x73f9a038, 0x110fb5ea, 0x110fb5ea, 0x110fb5ea, 0x59c36f00, 0x848d3181, 0x848d3181, 0x59c36f00, }, 20 },
-  { "gfxterm_ru", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0xd5494aa5, 0xa0924ec, 0xd5494aa5, 0xfb4ccfda, 0xaa4593fe, 0xaa4593fe, 0x8692c636, 0x8692c636, 0x8692c636, 0x2067cb51, 0x2067cb51, 0x2067cb51, 0xd5f6029, 0xd5f6029, 0xd5f6029, 0xaa4593fe, 0xfb4ccfda, 0xfb4ccfda, 0xaa4593fe, }, 20 },
-  { "gfxterm_ru", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x2436c4f, 0x2cde4e0c, 0x2436c4f, 0x5f5401cb, 0xc9cbf769, 0xc9cbf769, 0x558f50ae, 0x558f50ae, 0x558f50ae, 0xab579162, 0xab579162, 0xab579162, 0x421d2e6a, 0x421d2e6a, 0x421d2e6a, 0xc9cbf769, 0x5f5401cb, 0x5f5401cb, 0xc9cbf769, }, 20 },
-  { "gfxterm_ru", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x86f8a68c, 0xf4116451, 0x86f8a68c, 0x28aeef54, 0x9813a416, 0x9813a416, 0x7befbe43, 0x7befbe43, 0x7befbe43, 0xea343870, 0xea343870, 0xea343870, 0xf38e05a0, 0xf38e05a0, 0xf38e05a0, 0x9813a416, 0x28aeef54, 0x28aeef54, 0x9813a416, }, 20 },
-  { "gfxterm_ru", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x156c292f, 0x3c8eb473, 0x156c292f, 0x63ca1c9c, 0x5fcf013d, 0x5fcf013d, 0x895ea16b, 0x895ea16b, 0x895ea16b, 0x5b4eb91d, 0x5b4eb91d, 0x5b4eb91d, 0x4d3d8682, 0x4d3d8682, 0x4d3d8682, 0x5fcf013d, 0x63ca1c9c, 0x63ca1c9c, 0x5fcf013d, }, 20 },
-  { "gfxterm_ru", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xf57ebf12, 0x798b299b, 0xf57ebf12, 0xee7b6515, 0xdd28f52b, 0xdd28f52b, 0x22563fc6, 0x22563fc6, 0x22563fc6, 0x36ac622, 0x36ac622, 0x36ac622, 0x7ed20dae, 0x7ed20dae, 0x7ed20dae, 0xdd28f52b, 0xee7b6515, 0xee7b6515, 0xdd28f52b, }, 20 },
-  { "gfxterm_ru", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x2bc82eb1, 0x94064cc8, 0x2bc82eb1, 0xd4773531, 0x43d1f34, 0x43d1f34, 0x44cbf2f0, 0x44cbf2f0, 0x44cbf2f0, 0x3bc15b58, 0x3bc15b58, 0x3bc15b58, 0xa2905ede, 0xa2905ede, 0xa2905ede, 0x43d1f34, 0xd4773531, 0xd4773531, 0x43d1f34, }, 20 },
-  { "gfxterm_fr", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x7f6dd146, 0x548af474, 0x7f6dd146, 0x3c9b1c01, 0x59c36f00, 0x59c36f00, 0x7d913e8d, 0x7d913e8d, 0x7d913e8d, 0x31153eb, 0x31153eb, 0x31153eb, 0x61e74639, 0x61e74639, 0x61e74639, 0x59c36f00, 0x3c9b1c01, 0x3c9b1c01, 0x59c36f00, }, 20 },
-  { "gfxterm_fr", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0xf29ad079, 0x50d47c0, 0xf29ad079, 0xdc9f5506, 0xaa4593fe, 0xaa4593fe, 0x6bcf4c90, 0x6bcf4c90, 0x6bcf4c90, 0xcd3a41f7, 0xcd3a41f7, 0xcd3a41f7, 0xe002ea8f, 0xe002ea8f, 0xe002ea8f, 0xaa4593fe, 0xdc9f5506, 0xdc9f5506, 0xaa4593fe, }, 20 },
-  { "gfxterm_fr", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xb25e3082, 0x2ed845dd, 0xb25e3082, 0xef495d06, 0xc9cbf769, 0xc9cbf769, 0xd5322575, 0xd5322575, 0xd5322575, 0x2beae4b9, 0x2beae4b9, 0x2beae4b9, 0xc2a05bb1, 0xc2a05bb1, 0xc2a05bb1, 0xc9cbf769, 0xef495d06, 0xef495d06, 0xc9cbf769, }, 20 },
-  { "gfxterm_fr", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x4cdfcd2e, 0x8bf091f, 0x4cdfcd2e, 0xe28984f6, 0x9813a416, 0x9813a416, 0x8217f630, 0x8217f630, 0x8217f630, 0x13cc7003, 0x13cc7003, 0x13cc7003, 0xa764dd3, 0xa764dd3, 0xa764dd3, 0x9813a416, 0xe28984f6, 0xe28984f6, 0x9813a416, }, 20 },
-  { "gfxterm_fr", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0xf2b49f88, 0x2eff252d, 0xf2b49f88, 0x8412aa3b, 0x5fcf013d, 0x5fcf013d, 0x5d3b9fe7, 0x5d3b9fe7, 0x5d3b9fe7, 0x8f2b8791, 0x8f2b8791, 0x8f2b8791, 0x9958b80e, 0x9958b80e, 0x9958b80e, 0x5fcf013d, 0x8412aa3b, 0x8412aa3b, 0x5fcf013d, }, 20 },
-  { "gfxterm_fr", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x786673be, 0x536f1359, 0x786673be, 0x6363a9b9, 0xdd28f52b, 0xdd28f52b, 0x38653b12, 0x38653b12, 0x38653b12, 0x1959c2f6, 0x1959c2f6, 0x1959c2f6, 0x64e1097a, 0x64e1097a, 0x64e1097a, 0xdd28f52b, 0x6363a9b9, 0x6363a9b9, 0xdd28f52b, }, 20 },
-  { "gfxterm_fr", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0xac4a1127, 0x699c2ad8, 0xac4a1127, 0x53f50aa7, 0x43d1f34, 0x43d1f34, 0xfa47dfba, 0xfa47dfba, 0xfa47dfba, 0x854d7612, 0x854d7612, 0x854d7612, 0x1c1c7394, 0x1c1c7394, 0x1c1c7394, 0x43d1f34, 0x53f50aa7, 0x53f50aa7, 0x43d1f34, }, 20 },
-  { "gfxterm_quot", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xbc5f6633, 0xda908ab0, 0xbc5f6633, 0xffa9ab74, 0x59c36f00, 0x59c36f00, 0x3ad73295, 0x3ad73295, 0x3ad73295, 0x44575ff3, 0x44575ff3, 0x44575ff3, 0x26a14a21, 0x26a14a21, 0x26a14a21, 0x59c36f00, 0xffa9ab74, 0xffa9ab74, 0x59c36f00, }, 20 },
-  { "gfxterm_quot", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0xad820d6b, 0x9a88ad3, 0xad820d6b, 0x83878814, 0xaa4593fe, 0xaa4593fe, 0xbec19c1b, 0xbec19c1b, 0xbec19c1b, 0x1834917c, 0x1834917c, 0x1834917c, 0x350c3a04, 0x350c3a04, 0x350c3a04, 0xaa4593fe, 0x83878814, 0x83878814, 0xaa4593fe, }, 20 },
-  { "gfxterm_quot", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xe5774112, 0x5ffb1eca, 0xe5774112, 0xb8602c96, 0xc9cbf769, 0xc9cbf769, 0xe4861949, 0xe4861949, 0xe4861949, 0x1a5ed885, 0x1a5ed885, 0x1a5ed885, 0xf314678d, 0xf314678d, 0xf314678d, 0xc9cbf769, 0xb8602c96, 0xb8602c96, 0xc9cbf769, }, 20 },
-  { "gfxterm_quot", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x6af1a2bc, 0xd951ab8b, 0x6af1a2bc, 0xc4a7eb64, 0x9813a416, 0x9813a416, 0xb5e8801c, 0xb5e8801c, 0xb5e8801c, 0x2433062f, 0x2433062f, 0x2433062f, 0x3d893bff, 0x3d893bff, 0x3d893bff, 0x9813a416, 0xc4a7eb64, 0xc4a7eb64, 0x9813a416, }, 20 },
-  { "gfxterm_quot", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0xc6baa18, 0x1c9db179, 0xc6baa18, 0x7acd9fab, 0x5fcf013d, 0x5fcf013d, 0x819b5c4e, 0x819b5c4e, 0x819b5c4e, 0x538b4438, 0x538b4438, 0x538b4438, 0x45f87ba7, 0x45f87ba7, 0x45f87ba7, 0x5fcf013d, 0x7acd9fab, 0x7acd9fab, 0x5fcf013d, }, 20 },
-  { "gfxterm_quot", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xe424a6ab, 0xb05c0275, 0xe424a6ab, 0xff217cac, 0xdd28f52b, 0xdd28f52b, 0xcd83646c, 0xcd83646c, 0xcd83646c, 0xecbf9d88, 0xecbf9d88, 0xecbf9d88, 0x91075604, 0x91075604, 0x91075604, 0xdd28f52b, 0xff217cac, 0xff217cac, 0xdd28f52b, }, 20 },
-  { "gfxterm_quot", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x4a7dff41, 0xe1ec28fc, 0x4a7dff41, 0xb5c2e4c1, 0x43d1f34, 0x43d1f34, 0xb200c08a, 0xb200c08a, 0xb200c08a, 0xcd0a6922, 0xcd0a6922, 0xcd0a6922, 0x545b6ca4, 0x545b6ca4, 0x545b6ca4, 0x43d1f34, 0xb5c2e4c1, 0xb5c2e4c1, 0x43d1f34, }, 20 },
-  { "gfxterm_piglatin", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xd3d3e4a2, 0x9c635046, 0xd3d3e4a2, 0x902529e5, 0x59c36f00, 0x59c36f00, 0x85e713, 0x85e713, 0x85e713, 0x7e058a75, 0x7e058a75, 0x7e058a75, 0x1cf39fa7, 0x1cf39fa7, 0x1cf39fa7, 0x59c36f00, 0x902529e5, 0x902529e5, 0x59c36f00, }, 20 },
-  { "gfxterm_piglatin", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0xd61c80f5, 0xdf78b496, 0xd61c80f5, 0xf819058a, 0xaa4593fe, 0xaa4593fe, 0xefc0f7e7, 0xefc0f7e7, 0xefc0f7e7, 0x4935fa80, 0x4935fa80, 0x4935fa80, 0x640d51f8, 0x640d51f8, 0x640d51f8, 0xaa4593fe, 0xf819058a, 0xf819058a, 0xaa4593fe, }, 20 },
-  { "gfxterm_piglatin", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x936bc89d, 0x523a3e80, 0x936bc89d, 0xce7ca519, 0xc9cbf769, 0xc9cbf769, 0xaa99ffb1, 0xaa99ffb1, 0xaa99ffb1, 0x54413e7d, 0x54413e7d, 0x54413e7d, 0xbd0b8175, 0xbd0b8175, 0xbd0b8175, 0xc9cbf769, 0xce7ca519, 0xce7ca519, 0xc9cbf769, }, 20 },
-  { "gfxterm_piglatin", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x4fdd0291, 0x133fa83d, 0x4fdd0291, 0xe18b4b49, 0x9813a416, 0x9813a416, 0x74c38e90, 0x74c38e90, 0x74c38e90, 0xe51808a3, 0xe51808a3, 0xe51808a3, 0xfca23573, 0xfca23573, 0xfca23573, 0x9813a416, 0xe18b4b49, 0xe18b4b49, 0x9813a416, }, 20 },
-  { "gfxterm_piglatin", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x538203b0, 0x2a92e789, 0x538203b0, 0x25243603, 0x5fcf013d, 0x5fcf013d, 0x5e4d3dd8, 0x5e4d3dd8, 0x5e4d3dd8, 0x8c5d25ae, 0x8c5d25ae, 0x8c5d25ae, 0x9a2e1a31, 0x9a2e1a31, 0x9a2e1a31, 0x5fcf013d, 0x25243603, 0x25243603, 0x5fcf013d, }, 20 },
-  { "gfxterm_piglatin", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xcfc85125, 0xa5b0e11b, 0xcfc85125, 0xd4cd8b22, 0xdd28f52b, 0xdd28f52b, 0x1af8cddc, 0x1af8cddc, 0x1af8cddc, 0x3bc43438, 0x3bc43438, 0x3bc43438, 0x467cffb4, 0x467cffb4, 0x467cffb4, 0xdd28f52b, 0xd4cd8b22, 0xd4cd8b22, 0xdd28f52b, }, 20 },
-  { "gfxterm_piglatin", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0xf2469ffb, 0x1d0c1d2, 0xf2469ffb, 0xdf9847b, 0x43d1f34, 0x43d1f34, 0xa2837c7a, 0xa2837c7a, 0xa2837c7a, 0xdd89d5d2, 0xdd89d5d2, 0xdd89d5d2, 0x44d8d054, 0x44d8d054, 0x44d8d054, 0x43d1f34, 0xdf9847b, 0xdf9847b, 0x43d1f34, }, 20 },
-  { "gfxterm_ch", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x27851cc1, 0x15f731b5, 0x27851cc1, 0x6473d186, 0x59c36f00, 0x59c36f00, 0x125bcddf, 0x125bcddf, 0x125bcddf, 0x6cdba0b9, 0x6cdba0b9, 0x6cdba0b9, 0xe2db56b, 0xe2db56b, 0xe2db56b, 0x59c36f00, 0x6473d186, 0x6473d186, 0x59c36f00, }, 20 },
-  { "gfxterm_ch", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0xfcb223c, 0x2c2e18b9, 0xfcb223c, 0x21cea743, 0xaa4593fe, 0xaa4593fe, 0xd700be1a, 0xd700be1a, 0xd700be1a, 0x71f5b37d, 0x71f5b37d, 0x71f5b37d, 0x5ccd1805, 0x5ccd1805, 0x5ccd1805, 0xaa4593fe, 0x21cea743, 0x21cea743, 0xaa4593fe, }, 20 },
-  { "gfxterm_ch", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x807efaa5, 0xb673036a, 0x807efaa5, 0xdd699721, 0xc9cbf769, 0xc9cbf769, 0xdca3ed4b, 0xdca3ed4b, 0xdca3ed4b, 0x227b2c87, 0x227b2c87, 0x227b2c87, 0xcb31938f, 0xcb31938f, 0xcb31938f, 0xc9cbf769, 0xdd699721, 0xdd699721, 0xc9cbf769, }, 20 },
-  { "gfxterm_ch", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x651d0d50, 0xf0dc38fc, 0x651d0d50, 0xcb4b4488, 0x9813a416, 0x9813a416, 0x80d03ee8, 0x80d03ee8, 0x80d03ee8, 0x110bb8db, 0x110bb8db, 0x110bb8db, 0x8b1850b, 0x8b1850b, 0x8b1850b, 0x9813a416, 0xcb4b4488, 0xcb4b4488, 0x9813a416, }, 20 },
-  { "gfxterm_ch", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0xb9b068f, 0xdc68ac3c, 0xb9b068f, 0x7d3d333c, 0x5fcf013d, 0x5fcf013d, 0xa1f0a6e4, 0xa1f0a6e4, 0xa1f0a6e4, 0x73e0be92, 0x73e0be92, 0x73e0be92, 0x6593810d, 0x6593810d, 0x6593810d, 0x5fcf013d, 0x7d3d333c, 0x7d3d333c, 0x5fcf013d, }, 20 },
-  { "gfxterm_ch", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xf0789d7e, 0x6f2f2b61, 0xf0789d7e, 0xeb7d4779, 0xdd28f52b, 0xdd28f52b, 0xb995630, 0xb995630, 0xb995630, 0x2aa5afd4, 0x2aa5afd4, 0x2aa5afd4, 0x571d6458, 0x571d6458, 0x571d6458, 0xdd28f52b, 0xeb7d4779, 0xeb7d4779, 0xdd28f52b, }, 20 },
-  { "gfxterm_ch", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x819821ff, 0xdd19128c, 0x819821ff, 0x7e273a7f, 0x43d1f34, 0x43d1f34, 0xf35981d3, 0xf35981d3, 0xf35981d3, 0x8c53287b, 0x8c53287b, 0x8c53287b, 0x15022dfd, 0x15022dfd, 0x15022dfd, 0x43d1f34, 0x7e273a7f, 0x7e273a7f, 0x43d1f34, }, 20 },
-  { "gfxterm_red", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xa99604d1, 0xcf59e852, 0xa99604d1, 0xfebbba0f, 0x59c36f00, 0x59c36f00, 0x53767ce3, 0x53767ce3, 0x53767ce3, 0x2df61185, 0x2df61185, 0x2df61185, 0x4f000457, 0x4f000457, 0x4f000457, 0x59c36f00, 0xfebbba0f, 0xfebbba0f, 0x59c36f00, }, 20 },
-  { "gfxterm_red", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x7d0a218, 0xa3fa25a0, 0x7d0a218, 0xb777784e, 0xaa4593fe, 0xaa4593fe, 0x35db26e1, 0x35db26e1, 0x35db26e1, 0x932e2b86, 0x932e2b86, 0x932e2b86, 0xbe1680fe, 0xbe1680fe, 0xbe1680fe, 0xaa4593fe, 0xb777784e, 0xb777784e, 0xaa4593fe, }, 20 },
-  { "gfxterm_red", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x63be90f4, 0xd932cf2c, 0x63be90f4, 0x739b8e5a, 0xc9cbf769, 0xc9cbf769, 0x70a00efe, 0x70a00efe, 0x70a00efe, 0x8e78cf32, 0x8e78cf32, 0x8e78cf32, 0x6732703a, 0x6732703a, 0x6732703a, 0xc9cbf769, 0x739b8e5a, 0x739b8e5a, 0xc9cbf769, }, 20 },
-  { "gfxterm_red", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x53460c90, 0xe0e605a7, 0x53460c90, 0x6337f0bf, 0x9813a416, 0x9813a416, 0x4161864c, 0x4161864c, 0x4161864c, 0xd0ba007f, 0xd0ba007f, 0xd0ba007f, 0xc9003daf, 0xc9003daf, 0xc9003daf, 0x9813a416, 0x6337f0bf, 0x6337f0bf, 0x9813a416, }, 20 },
-  { "gfxterm_red", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0xf54761a0, 0xe5b17ac1, 0xf54761a0, 0x5b408e55, 0x5fcf013d, 0x5fcf013d, 0x580fda0e, 0x580fda0e, 0x580fda0e, 0x8a1fc278, 0x8a1fc278, 0x8a1fc278, 0x9c6cfde7, 0x9c6cfde7, 0x9c6cfde7, 0x5fcf013d, 0x5b408e55, 0x5b408e55, 0x5fcf013d, }, 20 },
-  { "gfxterm_red", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xec78b0c1, 0xb800141f, 0xec78b0c1, 0x621c7b1b, 0xdd28f52b, 0xdd28f52b, 0x8f60179, 0x8f60179, 0x8f60179, 0x29caf89d, 0x29caf89d, 0x29caf89d, 0x54723311, 0x54723311, 0x54723311, 0xdd28f52b, 0x621c7b1b, 0x621c7b1b, 0xdd28f52b, }, 20 },
-  { "gfxterm_red", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0xf209411b, 0x599896a6, 0xf209411b, 0x6551c7bb, 0x43d1f34, 0x43d1f34, 0x5ac6bb4a, 0x5ac6bb4a, 0x5ac6bb4a, 0x25cc12e2, 0x25cc12e2, 0x25cc12e2, 0xbc9d1764, 0xbc9d1764, 0xbc9d1764, 0x43d1f34, 0x6551c7bb, 0x6551c7bb, 0x43d1f34, }, 20 },
-  { "gfxterm_high", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x93b4fcd8, 0xf57b105b, 0x93b4fcd8, 0x2bfe5312, 0x59c36f00, 0x59c36f00, 0x3ad73295, 0x3ad73295, 0x3ad73295, 0x44575ff3, 0x44575ff3, 0x44575ff3, 0x26a14a21, 0x26a14a21, 0x26a14a21, 0x59c36f00, 0x2bfe5312, 0x2bfe5312, 0x59c36f00, }, 20 },
-  { "gfxterm_high", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x656c9044, 0xc14617fc, 0x656c9044, 0xa6ea58cb, 0xaa4593fe, 0xaa4593fe, 0xbec19c1b, 0xbec19c1b, 0xbec19c1b, 0x1834917c, 0x1834917c, 0x1834917c, 0x350c3a04, 0x350c3a04, 0x350c3a04, 0xaa4593fe, 0xa6ea58cb, 0xa6ea58cb, 0xaa4593fe, }, 20 },
-  { "gfxterm_high", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xa11479ed, 0x1b982635, 0xa11479ed, 0xe37185d0, 0xc9cbf769, 0xc9cbf769, 0xe4861949, 0xe4861949, 0xe4861949, 0x1a5ed885, 0x1a5ed885, 0x1a5ed885, 0xf314678d, 0xf314678d, 0xf314678d, 0xc9cbf769, 0xe37185d0, 0xe37185d0, 0xc9cbf769, }, 20 },
-  { "gfxterm_high", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x244770a7, 0x97e77990, 0x244770a7, 0x6a54d2ee, 0x9813a416, 0x9813a416, 0xb5e8801c, 0xb5e8801c, 0xb5e8801c, 0x2433062f, 0x2433062f, 0x2433062f, 0x3d893bff, 0x3d893bff, 0x3d893bff, 0x9813a416, 0x6a54d2ee, 0x6a54d2ee, 0x9813a416, }, 20 },
-  { "gfxterm_high", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x8ca34476, 0x9c555f17, 0x8ca34476, 0x1fc54b41, 0x5fcf013d, 0x5fcf013d, 0x819b5c4e, 0x819b5c4e, 0x819b5c4e, 0x538b4438, 0x538b4438, 0x538b4438, 0x45f87ba7, 0x45f87ba7, 0x45f87ba7, 0x5fcf013d, 0x1fc54b41, 0x1fc54b41, 0x5fcf013d, }, 20 },
-  { "gfxterm_high", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xf19f6af8, 0xa5e7ce26, 0xf19f6af8, 0x1619aea6, 0xdd28f52b, 0xdd28f52b, 0xcd83646c, 0xcd83646c, 0xcd83646c, 0xecbf9d88, 0xecbf9d88, 0xecbf9d88, 0x91075604, 0x91075604, 0x91075604, 0xdd28f52b, 0x1619aea6, 0x1619aea6, 0xdd28f52b, }, 20 },
-  { "gfxterm_high", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x5f75414f, 0xf4e496f2, 0x5f75414f, 0x27fd1fe0, 0x43d1f34, 0x43d1f34, 0xb200c08a, 0xb200c08a, 0xb200c08a, 0xcd0a6922, 0xcd0a6922, 0xcd0a6922, 0x545b6ca4, 0x545b6ca4, 0x545b6ca4, 0x43d1f34, 0x27fd1fe0, 0x27fd1fe0, 0x43d1f34, }, 20 },
+  { "cmdline_cat", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x8851b0ee, 0x8851b0ee, 0xafb59f0b, 0xafb59f0b, 0x8c9b72f1, 0x8c9b72f1, 0x6eec5116, 0x6eec5116, 0xad82053e, 0xad82053e, 0x2eeae2ae, 0x2eeae2ae, 0x58cf8def, 0x58cf8def, 0x926f4d2f, 0x926f4d2f, 0xbd1c3236, 0xbd1c3236, 0x56012a95, 0x56012a95, 0x6d7c40ae, 0x6d7c40ae, 0xef750bc8, 0xef750bc8, 0x1080dd4a, 0x1080dd4a, 0xd7f9e5af, 0xd7f9e5af, 0x80b1b4a9, 0x80b1b4a9, 0x2c99415e, 0x2c99415e, 0x8d5761ff, 0x8d5761ff, 0xb964b489, 0xb964b489, 0x88a51f74, 0x88a51f74, 0x1da6c458, 0x1da6c458, 0x85e94025, 0x206ea54f, 0x7ee6c8fd, 0x7ee6c8fd, }, 45 },
+  { "cmdline_cat", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x834b70a0, 0x834b70a0, 0xe7cc129f, 0xe7cc129f, 0x5ee2edc, 0x5ee2edc, 0xa1135cd7, 0xa1135cd7, 0xf7ce1f26, 0xf7ce1f26, 0xe9f803e8, 0xe9f803e8, 0x4b8f9724, 0x4b8f9724, 0x3fe3771a, 0x3fe3771a, 0x5584ee63, 0x5584ee63, 0xac193250, 0xac193250, 0x801f25f4, 0x801f25f4, 0x8d33aece, 0x8d33aece, 0xc6d95edc, 0xc6d95edc, 0xf121dee2, 0xf121dee2, 0x6ab10812, 0x6ab10812, 0x41a5b112, 0x41a5b112, 0xac6f712b, 0xac6f712b, 0x8aee7a19, 0x8aee7a19, 0xfe37c0ad, 0xfe37c0ad, 0x99c6a336, 0x99c6a336, 0x53b844c6, 0x73015447, 0x7a1a2254, 0x7a1a2254, }, 45 },
+  { "cmdline_cat", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xb121c912, 0xb121c912, 0x635a8739, 0x635a8739, 0x8288cba6, 0x8288cba6, 0xf5589d0, 0xf5589d0, 0x471642b3, 0x471642b3, 0xfb4826cf, 0xfb4826cf, 0x8b1083cf, 0x8b1083cf, 0x738b0c94, 0x738b0c94, 0x859c41b0, 0x859c41b0, 0x7c8d1be9, 0x7c8d1be9, 0x5b685e40, 0x5b685e40, 0x9cf80d95, 0x9cf80d95, 0x3541f915, 0x3541f915, 0x582b8557, 0x582b8557, 0x24cf88f7, 0x24cf88f7, 0x9e0af23, 0x9e0af23, 0x1033164b, 0x1033164b, 0x70ba51e2, 0x70ba51e2, 0xb051585c, 0xb051585c, 0xe1389f04, 0xe1389f04, 0x308bbb74, 0xdc9e6805, 0x4ddcff9f, 0x4ddcff9f, }, 45 },
+  { "cmdline_cat", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0xac16e832, 0xac16e832, 0xbf6ab9c6, 0xbf6ab9c6, 0x1063e15a, 0x1063e15a, 0xf908e3ff, 0xf908e3ff, 0xcb37d841, 0xcb37d841, 0x9b8ffa7d, 0x9b8ffa7d, 0x38d2a26c, 0x38d2a26c, 0x6989f09b, 0x6989f09b, 0x481451e, 0x481451e, 0x17b3177, 0x17b3177, 0x3ea52aeb, 0x3ea52aeb, 0xc24de674, 0xc24de674, 0x4ab163cc, 0x4ab163cc, 0xc482b092, 0xc482b092, 0x55ffc7e2, 0x55ffc7e2, 0x3b4b34dd, 0x3b4b34dd, 0x9b1f047f, 0x9b1f047f, 0x3d42e414, 0x3d42e414, 0x35b2fb06, 0x35b2fb06, 0xb813b35f, 0xb813b35f, 0xc3ede6e0, 0xc35214c3, 0x340f0107, 0x340f0107, }, 45 },
+  { "cmdline_cat", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x9c47caee, 0x9c47caee, 0x6c9c4f38, 0x6c9c4f38, 0x79c49615, 0x79c49615, 0x70fe9708, 0x70fe9708, 0x8e90c077, 0x8e90c077, 0xd8205b47, 0xd8205b47, 0xa34337e2, 0xa34337e2, 0xf4dffa53, 0xf4dffa53, 0x90a0779c, 0x90a0779c, 0x322820bb, 0x322820bb, 0x50e3383f, 0x50e3383f, 0x4a976e3e, 0x4a976e3e, 0x90b6f8d9, 0x90b6f8d9, 0x4058c301, 0x4058c301, 0x221a6810, 0x221a6810, 0x1f78a00e, 0x1f78a00e, 0x6a633d2c, 0x6a633d2c, 0xca177c65, 0xca177c65, 0xabb6c7f9, 0xabb6c7f9, 0x635a35e8, 0x635a35e8, 0x6da78f10, 0x53467ff8, 0xd037fdfa, 0xd037fdfa, }, 45 },
+  { "cmdline_cat", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x2b6b8225, 0x2b6b8225, 0x83df9995, 0x83df9995, 0x5165ad0b, 0x5165ad0b, 0xe5a6f96d, 0xe5a6f96d, 0x798df957, 0x798df957, 0x8c0567e2, 0x8c0567e2, 0x5e5d7389, 0x5e5d7389, 0x47a39dd, 0x47a39dd, 0x894f44af, 0x894f44af, 0x1dff0a6, 0x1dff0a6, 0xf496e67b, 0xf496e67b, 0x29cb5702, 0x29cb5702, 0xeaf1387d, 0xeaf1387d, 0x4a9bf7, 0x4a9bf7, 0x11d20bee, 0x11d20bee, 0xa103dc2d, 0xa103dc2d, 0xd0265db9, 0xd0265db9, 0x42267334, 0x42267334, 0x96f85e8c, 0x96f85e8c, 0xa28eac49, 0xa28eac49, 0x4e660ae7, 0x70741b3, 0x183f2f2e, 0x183f2f2e, }, 45 },
+  { "cmdline_cat", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x77b51f44, 0x77b51f44, 0xc8097569, 0xc8097569, 0x769aee5f, 0x769aee5f, 0xa35e159, 0xa35e159, 0x87a6341f, 0x87a6341f, 0xb61d944b, 0xb61d944b, 0x8b109cb3, 0x8b109cb3, 0xed3fb3e, 0xed3fb3e, 0xd7cc6c3, 0xd7cc6c3, 0x52077f0d, 0x52077f0d, 0x9d86d17e, 0x9d86d17e, 0x5e487bb, 0x5e487bb, 0x3a00041b, 0x3a00041b, 0xcfdeaf9e, 0xcfdeaf9e, 0x3e40af89, 0x3e40af89, 0x5ec41ea9, 0x5ec41ea9, 0x6298e4e7, 0x6298e4e7, 0xfd67f90e, 0xfd67f90e, 0x5ab5dc32, 0x5ab5dc32, 0xdd3ad694, 0xdd3ad694, 0x391222b4, 0xd4a98b43, 0xeaa2f62, 0xeaa2f62, }, 45 },
+  { "gfxterm_menu", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x45b0713c, 0x237f9dbf, 0x45b0713c, 0x646bc7b, 0x59c36f00, 0x59c36f00, 0x7fd94135, 0x7fd94135, 0x7fd94135, 0x1592c53, 0x1592c53, 0x1592c53, 0x63af3981, 0x63af3981, 0x63af3981, 0x59c36f00, 0x646bc7b, 0x646bc7b, 0x59c36f00, }, 20 },
+  { "gfxterm_menu", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x84abc7db, 0x20814063, 0x84abc7db, 0xaaae42a4, 0xaa4593fe, 0xaa4593fe, 0x2e88732f, 0x2e88732f, 0x2e88732f, 0x887d7e48, 0x887d7e48, 0x887d7e48, 0xa545d530, 0xa545d530, 0xa545d530, 0xaa4593fe, 0xaaae42a4, 0xaaae42a4, 0xaa4593fe, }, 20 },
+  { "gfxterm_menu", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x5b85371a, 0xe10968c2, 0x5b85371a, 0x6925a9e, 0xc9cbf769, 0xc9cbf769, 0xda1c9f17, 0xda1c9f17, 0xda1c9f17, 0x24c45edb, 0x24c45edb, 0x24c45edb, 0xcd8ee1d3, 0xcd8ee1d3, 0xcd8ee1d3, 0xc9cbf769, 0x6925a9e, 0x6925a9e, 0xc9cbf769, }, 20 },
+  { "gfxterm_menu", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x9130464d, 0x22904f7a, 0x9130464d, 0x3f660f95, 0x9813a416, 0x9813a416, 0xfb08d7cf, 0xfb08d7cf, 0xfb08d7cf, 0x6ad351fc, 0x6ad351fc, 0x6ad351fc, 0x73696c2c, 0x73696c2c, 0x73696c2c, 0x9813a416, 0x3f660f95, 0x3f660f95, 0x9813a416, }, 20 },
+  { "gfxterm_menu", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x5185b14e, 0x4173aa2f, 0x5185b14e, 0x272384fd, 0x5fcf013d, 0x5fcf013d, 0x9e56a9e0, 0x9e56a9e0, 0x9e56a9e0, 0x4c46b196, 0x4c46b196, 0x4c46b196, 0x5a358e09, 0x5a358e09, 0x5a358e09, 0x5fcf013d, 0x272384fd, 0x272384fd, 0x5fcf013d, }, 20 },
+  { "gfxterm_menu", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x5cc0d3ef, 0x8b87731, 0x5cc0d3ef, 0x47c509e8, 0xdd28f52b, 0xdd28f52b, 0xe1579057, 0xe1579057, 0xe1579057, 0xc06b69b3, 0xc06b69b3, 0xc06b69b3, 0xbdd3a23f, 0xbdd3a23f, 0xbdd3a23f, 0xdd28f52b, 0x47c509e8, 0x47c509e8, 0xdd28f52b, }, 20 },
+  { "gfxterm_menu", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0xd1338a02, 0x7aa25dbf, 0xd1338a02, 0x2e8c9182, 0x43d1f34, 0x43d1f34, 0x6486f7c4, 0x6486f7c4, 0x6486f7c4, 0x1b8c5e6c, 0x1b8c5e6c, 0x1b8c5e6c, 0x82dd5bea, 0x82dd5bea, 0x82dd5bea, 0x43d1f34, 0x2e8c9182, 0x2e8c9182, 0x43d1f34, }, 20 },
+  { "gfxmenu", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x1027210c, 0x64e51c81, 0x1027210c, 0x45ca4a8a, 0x9a2e0d26, 0x2b88b6ce, 0x2b88b6ce, 0x2b88b6ce, 0x7750400e, 0x7750400e, 0x7750400e, 0x5ec88e9c, 0x5ec88e9c, 0x5ec88e9c, 0x59c36f00, 0x45ca4a8a, 0x45ca4a8a, }, 18 },
+  { "gfxmenu", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x8d12f697, 0xc5b32248, 0x8d12f697, 0x56720aa4, 0xa9d58ccd, 0xa1b1a1b5, 0xa1b1a1b5, 0xa1b1a1b5, 0xf4ee0bbf, 0xf4ee0bbf, 0xf4ee0bbf, 0x9dddc3f6, 0x9dddc3f6, 0x9dddc3f6, 0xaa4593fe, 0x56720aa4, 0x56720aa4, }, 18 },
+  { "gfxmenu", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xa5ec9f45, 0xdb7085d8, 0xa5ec9f45, 0x9caf1d3f, 0x5411be8b, 0xa07e74d3, 0xa07e74d3, 0xa07e74d3, 0xdfc0d247, 0xdfc0d247, 0xdfc0d247, 0x9db4b23f, 0x9db4b23f, 0x9db4b23f, 0xc9cbf769, 0x9caf1d3f, 0x9caf1d3f, }, 18 },
+  { "gfxmenu", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x1c3742c9, 0xce8e83bf, 0xeb96c838, 0xce8e83bf, 0x73cb3bc1, 0x740d78cf, 0x84312594, 0x84312594, 0x84312594, 0x6f94cfe8, 0x6f94cfe8, 0x6f94cfe8, 0x69dfcf18, 0x69dfcf18, 0x69dfcf18, 0x1c3742c9, 0x73cb3bc1, 0x73cb3bc1, }, 18 },
+  { "gfxmenu", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0xcc5a7bed, 0x56a03e51, 0xee7d8d4b, 0x56a03e51, 0x5bdf9413, 0xbcda144c, 0x131c0760, 0x131c0760, 0x131c0760, 0x7c55db71, 0x7c55db71, 0x7c55db71, 0x71a34572, 0x71a34572, 0x71a34572, 0xcc5a7bed, 0x5bdf9413, 0x5bdf9413, }, 18 },
+  { "gfxmenu", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xef4a3312, 0xea8a9cf0, 0x8929e522, 0xea8a9cf0, 0x78f3dfbc, 0x5d55a141, 0xb9092e0b, 0xb9092e0b, 0xb9092e0b, 0x7fbb6a15, 0x7fbb6a15, 0x7fbb6a15, 0x6bdebaaa, 0x6bdebaaa, 0x6bdebaaa, 0xef4a3312, 0x78f3dfbc, 0x78f3dfbc, }, 18 },
+  { "gfxmenu", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x54e48d80, 0x6dcf1d57, 0x925a4c8f, 0x6dcf1d57, 0x69005b38, 0x6d6bb4bc, 0x14f7c6b1, 0x14f7c6b1, 0x14f7c6b1, 0x95043060, 0x95043060, 0x95043060, 0x3a0890f, 0x3a0890f, 0x3a0890f, 0x54e48d80, 0x69005b38, 0x69005b38, }, 18 },
+  { "gfxterm_ar", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x77ff5efc, 0x791fe364, 0x77ff5efc, 0x340993bb, 0x59c36f00, 0x59c36f00, 0x3908ca1e, 0x3908ca1e, 0x3908ca1e, 0x4788a778, 0x4788a778, 0x4788a778, 0x257eb2aa, 0x257eb2aa, 0x257eb2aa, 0x59c36f00, 0x340993bb, 0x340993bb, 0x59c36f00, }, 20 },
+  { "gfxterm_ar", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0xb2d04b0f, 0x46cdbc23, 0xb2d04b0f, 0x9cd5ce70, 0xaa4593fe, 0xaa4593fe, 0x44bf6b37, 0x44bf6b37, 0x44bf6b37, 0xe24a6650, 0xe24a6650, 0xe24a6650, 0xcf72cd28, 0xcf72cd28, 0xcf72cd28, 0xaa4593fe, 0x9cd5ce70, 0x9cd5ce70, 0xaa4593fe, }, 20 },
+  { "gfxterm_ar", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x4bb823b8, 0x59349835, 0x4bb823b8, 0x16af4e3c, 0xc9cbf769, 0xc9cbf769, 0x2784b68e, 0x2784b68e, 0x2784b68e, 0xd95c7742, 0xd95c7742, 0xd95c7742, 0x3016c84a, 0x3016c84a, 0x3016c84a, 0xc9cbf769, 0x16af4e3c, 0x16af4e3c, 0xc9cbf769, }, 20 },
+  { "gfxterm_ar", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0xb821e44, 0x16b3ac05, 0xb821e44, 0xa5d4579c, 0x9813a416, 0x9813a416, 0xca80d730, 0xca80d730, 0xca80d730, 0x5b5b5103, 0x5b5b5103, 0x5b5b5103, 0x42e16cd3, 0x42e16cd3, 0x42e16cd3, 0x9813a416, 0xa5d4579c, 0xa5d4579c, 0x9813a416, }, 20 },
+  { "gfxterm_ar", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0xbe0b9671, 0x7f6e98d0, 0xbe0b9671, 0xc8ada3c2, 0x5fcf013d, 0x5fcf013d, 0x57a0c67d, 0x57a0c67d, 0x57a0c67d, 0x85b0de0b, 0x85b0de0b, 0x85b0de0b, 0x93c3e194, 0x93c3e194, 0x93c3e194, 0x5fcf013d, 0xc8ada3c2, 0xc8ada3c2, 0x5fcf013d, }, 20 },
+  { "gfxterm_ar", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x9f18b29e, 0x50e7d383, 0x9f18b29e, 0x841d6899, 0xdd28f52b, 0xdd28f52b, 0xd12092dc, 0xd12092dc, 0xd12092dc, 0xf01c6b38, 0xf01c6b38, 0xf01c6b38, 0x8da4a0b4, 0x8da4a0b4, 0x8da4a0b4, 0xdd28f52b, 0x841d6899, 0x841d6899, 0xdd28f52b, }, 20 },
+  { "gfxterm_ar", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x4e8d4d8c, 0x3f32cb90, 0x4e8d4d8c, 0xb132560c, 0x43d1f34, 0x43d1f34, 0x1e7f303c, 0x1e7f303c, 0x1e7f303c, 0x61759994, 0x61759994, 0x61759994, 0xf8249c12, 0xf8249c12, 0xf8249c12, 0x43d1f34, 0xb132560c, 0xb132560c, 0x43d1f34, }, 20 },
+  { "gfxterm_cyr", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x4f39b2c5, 0x37084023, 0x4f39b2c5, 0xccf7f82, 0x59c36f00, 0x59c36f00, 0xb5dad2e, 0xb5dad2e, 0xb5dad2e, 0x75ddc048, 0x75ddc048, 0x75ddc048, 0x172bd59a, 0x172bd59a, 0x172bd59a, 0x59c36f00, 0xccf7f82, 0xccf7f82, 0x59c36f00, }, 20 },
+  { "gfxterm_cyr", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0xd5f24f8e, 0x76463f82, 0xd5f24f8e, 0xfbf7caf1, 0xaa4593fe, 0xaa4593fe, 0xb897c475, 0xb897c475, 0xb897c475, 0x1e62c912, 0x1e62c912, 0x1e62c912, 0x335a626a, 0x335a626a, 0x335a626a, 0xaa4593fe, 0xfbf7caf1, 0xfbf7caf1, 0xaa4593fe, }, 20 },
+  { "gfxterm_cyr", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x8aa7c8c3, 0x28620e7e, 0x8aa7c8c3, 0xd7b0a547, 0xc9cbf769, 0xc9cbf769, 0x860f1899, 0x860f1899, 0x860f1899, 0x78d7d955, 0x78d7d955, 0x78d7d955, 0x919d665d, 0x919d665d, 0x919d665d, 0xc9cbf769, 0xd7b0a547, 0xd7b0a547, 0xc9cbf769, }, 20 },
+  { "gfxterm_cyr", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x89654b6, 0x26bab4dd, 0x89654b6, 0xa6c01d6e, 0x9813a416, 0x9813a416, 0xc67652d9, 0xc67652d9, 0xc67652d9, 0x57add4ea, 0x57add4ea, 0x57add4ea, 0x4e17e93a, 0x4e17e93a, 0x4e17e93a, 0x9813a416, 0xa6c01d6e, 0xa6c01d6e, 0x9813a416, }, 20 },
+  { "gfxterm_cyr", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x77945f28, 0xec3ce845, 0x77945f28, 0x1326a9b, 0x5fcf013d, 0x5fcf013d, 0xc8e6e12c, 0xc8e6e12c, 0xc8e6e12c, 0x1af6f95a, 0x1af6f95a, 0x1af6f95a, 0xc85c6c5, 0xc85c6c5, 0xc85c6c5, 0x5fcf013d, 0x1326a9b, 0x1326a9b, 0x5fcf013d, }, 20 },
+  { "gfxterm_cyr", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x4450a5dc, 0xda479f49, 0x4450a5dc, 0x5f557fdb, 0xdd28f52b, 0xdd28f52b, 0xddfe9197, 0xddfe9197, 0xddfe9197, 0xfcc26873, 0xfcc26873, 0xfcc26873, 0x817aa3ff, 0x817aa3ff, 0x817aa3ff, 0xdd28f52b, 0x5f557fdb, 0x5f557fdb, 0xdd28f52b, }, 20 },
+  { "gfxterm_cyr", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x409098da, 0x2e0890e, 0x409098da, 0xbf2f835a, 0x43d1f34, 0x43d1f34, 0x253d050e, 0x253d050e, 0x253d050e, 0x5a37aca6, 0x5a37aca6, 0x5a37aca6, 0xc366a920, 0xc366a920, 0xc366a920, 0x43d1f34, 0xbf2f835a, 0xbf2f835a, 0x43d1f34, }, 20 },
+  { "gfxterm_heb", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x546aa9f1, 0x56bf26d0, 0x546aa9f1, 0x179c64b6, 0x59c36f00, 0x59c36f00, 0xa98ad4a1, 0xa98ad4a1, 0xa98ad4a1, 0xd70ab9c7, 0xd70ab9c7, 0xd70ab9c7, 0xb5fcac15, 0xb5fcac15, 0xb5fcac15, 0x59c36f00, 0x179c64b6, 0x179c64b6, 0x59c36f00, }, 20 },
+  { "gfxterm_heb", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x12592c97, 0xa10f7034, 0x12592c97, 0x3c5ca9e8, 0xaa4593fe, 0xaa4593fe, 0x2c3e194, 0x2c3e194, 0x2c3e194, 0xa436ecf3, 0xa436ecf3, 0xa436ecf3, 0x890e478b, 0x890e478b, 0x890e478b, 0xaa4593fe, 0x3c5ca9e8, 0x3c5ca9e8, 0xaa4593fe, }, 20 },
+  { "gfxterm_heb", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xed5de42a, 0x5cf94e51, 0xed5de42a, 0xb04a89ae, 0xc9cbf769, 0xc9cbf769, 0xdd578210, 0xdd578210, 0xdd578210, 0x238f43dc, 0x238f43dc, 0x238f43dc, 0xcac5fcd4, 0xcac5fcd4, 0xcac5fcd4, 0xc9cbf769, 0xb04a89ae, 0xb04a89ae, 0xc9cbf769, }, 20 },
+  { "gfxterm_heb", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0xbbc56f90, 0x4f643bbb, 0xbbc56f90, 0x15932648, 0x9813a416, 0x9813a416, 0x28aba4d1, 0x28aba4d1, 0x28aba4d1, 0xb97022e2, 0xb97022e2, 0xb97022e2, 0xa0ca1f32, 0xa0ca1f32, 0xa0ca1f32, 0x9813a416, 0x15932648, 0x15932648, 0x9813a416, }, 20 },
+  { "gfxterm_heb", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x43465d8c, 0x6399888a, 0x43465d8c, 0x35e0683f, 0x5fcf013d, 0x5fcf013d, 0x4895c207, 0x4895c207, 0x4895c207, 0x9a85da71, 0x9a85da71, 0x9a85da71, 0x8cf6e5ee, 0x8cf6e5ee, 0x8cf6e5ee, 0x5fcf013d, 0x35e0683f, 0x35e0683f, 0x5fcf013d, }, 20 },
+  { "gfxterm_heb", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xd1e7f231, 0xe67e195e, 0xd1e7f231, 0xcae22836, 0xdd28f52b, 0xdd28f52b, 0xe7ae9f08, 0xe7ae9f08, 0xe7ae9f08, 0xc69266ec, 0xc69266ec, 0xc69266ec, 0xbb2aad60, 0xbb2aad60, 0xbb2aad60, 0xdd28f52b, 0xcae22836, 0xcae22836, 0xdd28f52b, }, 20 },
+  { "gfxterm_heb", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x793e58f4, 0x5f939386, 0x793e58f4, 0x86814374, 0x43d1f34, 0x43d1f34, 0x12b2b9c1, 0x12b2b9c1, 0x12b2b9c1, 0x6db81069, 0x6db81069, 0x6db81069, 0xf4e915ef, 0xf4e915ef, 0xf4e915ef, 0x43d1f34, 0x86814374, 0x86814374, 0x43d1f34, }, 20 },
+  { "gfxterm_gre", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x226c0d75, 0x9e291f4f, 0x226c0d75, 0x619ac032, 0x59c36f00, 0x59c36f00, 0x6fb6253, 0x6fb6253, 0x6fb6253, 0x787b0f35, 0x787b0f35, 0x787b0f35, 0x1a8d1ae7, 0x1a8d1ae7, 0x1a8d1ae7, 0x59c36f00, 0x619ac032, 0x619ac032, 0x59c36f00, }, 20 },
+  { "gfxterm_gre", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x8355045, 0xfe058b68, 0x8355045, 0x2630d53a, 0xaa4593fe, 0xaa4593fe, 0x290a3822, 0x290a3822, 0x290a3822, 0x8fff3545, 0x8fff3545, 0x8fff3545, 0xa2c79e3d, 0xa2c79e3d, 0xa2c79e3d, 0xaa4593fe, 0x2630d53a, 0x2630d53a, 0xaa4593fe, }, 20 },
+  { "gfxterm_gre", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xc702fa59, 0x74086887, 0xc702fa59, 0x9a1597dd, 0xc9cbf769, 0xc9cbf769, 0x60295baa, 0x60295baa, 0x60295baa, 0x9ef19a66, 0x9ef19a66, 0x9ef19a66, 0x77bb256e, 0x77bb256e, 0x77bb256e, 0xc9cbf769, 0x9a1597dd, 0x9a1597dd, 0xc9cbf769, }, 20 },
+  { "gfxterm_gre", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x82385331, 0xf77eda42, 0x82385331, 0x2c6e1ae9, 0x9813a416, 0x9813a416, 0x140c0d1f, 0x140c0d1f, 0x140c0d1f, 0x85d78b2c, 0x85d78b2c, 0x85d78b2c, 0x9c6db6fc, 0x9c6db6fc, 0x9c6db6fc, 0x9813a416, 0x2c6e1ae9, 0x2c6e1ae9, 0x9813a416, }, 20 },
+  { "gfxterm_gre", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x565d2d38, 0x34f757ec, 0x565d2d38, 0x20fb188b, 0x5fcf013d, 0x5fcf013d, 0x230bf123, 0x230bf123, 0x230bf123, 0xf11be955, 0xf11be955, 0xf11be955, 0xe768d6ca, 0xe768d6ca, 0xe768d6ca, 0x5fcf013d, 0x20fb188b, 0x20fb188b, 0x5fcf013d, }, 20 },
+  { "gfxterm_gre", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x632132a4, 0x4a8c90b2, 0x632132a4, 0x7824e8a3, 0xdd28f52b, 0xdd28f52b, 0xef2bffce, 0xef2bffce, 0xef2bffce, 0xce17062a, 0xce17062a, 0xce17062a, 0xb3afcda6, 0xb3afcda6, 0xb3afcda6, 0xdd28f52b, 0x7824e8a3, 0x7824e8a3, 0xdd28f52b, }, 20 },
+  { "gfxterm_gre", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x461d4cfa, 0xfd3492c2, 0x461d4cfa, 0xb9a2577a, 0x43d1f34, 0x43d1f34, 0xfb72301f, 0xfb72301f, 0xfb72301f, 0x847899b7, 0x847899b7, 0x847899b7, 0x1d299c31, 0x1d299c31, 0x1d299c31, 0x43d1f34, 0xb9a2577a, 0xb9a2577a, 0x43d1f34, }, 20 },
+  { "gfxterm_ru", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x82758f66, 0xbac387fd, 0x82758f66, 0xc1834221, 0x59c36f00, 0x59c36f00, 0x4877befe, 0x4877befe, 0x4877befe, 0x36f7d398, 0x36f7d398, 0x36f7d398, 0x5401c64a, 0x5401c64a, 0x5401c64a, 0x59c36f00, 0xc1834221, 0xc1834221, 0x59c36f00, }, 20 },
+  { "gfxterm_ru", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x4500a591, 0x9a40cbd8, 0x4500a591, 0x6b0520ee, 0xaa4593fe, 0xaa4593fe, 0x16db2902, 0x16db2902, 0x16db2902, 0xb02e2465, 0xb02e2465, 0xb02e2465, 0x9d168f1d, 0x9d168f1d, 0x9d168f1d, 0xaa4593fe, 0x6b0520ee, 0x6b0520ee, 0xaa4593fe, }, 20 },
+  { "gfxterm_ru", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x3cd9ea11, 0x1244c852, 0x3cd9ea11, 0x61ce8795, 0xc9cbf769, 0xc9cbf769, 0x6b15d6f0, 0x6b15d6f0, 0x6b15d6f0, 0x95cd173c, 0x95cd173c, 0x95cd173c, 0x7c87a834, 0x7c87a834, 0x7c87a834, 0xc9cbf769, 0x61ce8795, 0x61ce8795, 0xc9cbf769, }, 20 },
+  { "gfxterm_ru", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0xc818f15f, 0xbaf13382, 0xc818f15f, 0x664eb887, 0x9813a416, 0x9813a416, 0x350fe990, 0x350fe990, 0x350fe990, 0xa4d46fa3, 0xa4d46fa3, 0xa4d46fa3, 0xbd6e5273, 0xbd6e5273, 0xbd6e5273, 0x9813a416, 0x664eb887, 0x664eb887, 0x9813a416, }, 20 },
+  { "gfxterm_ru", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0xaa1dc81, 0x234341dd, 0xaa1dc81, 0x7c07e932, 0x5fcf013d, 0x5fcf013d, 0x969354c5, 0x969354c5, 0x969354c5, 0x44834cb3, 0x44834cb3, 0x44834cb3, 0x52f0732c, 0x52f0732c, 0x52f0732c, 0x5fcf013d, 0x7c07e932, 0x7c07e932, 0x5fcf013d, }, 20 },
+  { "gfxterm_ru", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xd9aa4b29, 0x555fdda0, 0xd9aa4b29, 0xc2af912e, 0xdd28f52b, 0xdd28f52b, 0xe82cbfd, 0xe82cbfd, 0xe82cbfd, 0x2fbe3219, 0x2fbe3219, 0x2fbe3219, 0x5206f995, 0x5206f995, 0x5206f995, 0xdd28f52b, 0xc2af912e, 0xc2af912e, 0xdd28f52b, }, 20 },
+  { "gfxterm_ru", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0xfd4e19ff, 0x42807b86, 0xfd4e19ff, 0x2f1027f, 0x43d1f34, 0x43d1f34, 0x924dc5be, 0x924dc5be, 0x924dc5be, 0xed476c16, 0xed476c16, 0xed476c16, 0x74166990, 0x74166990, 0x74166990, 0x43d1f34, 0x2f1027f, 0x2f1027f, 0x43d1f34, }, 20 },
+  { "gfxterm_fr", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x3a63a2e6, 0x118487d4, 0x3a63a2e6, 0x79956fa1, 0x59c36f00, 0x59c36f00, 0x389f4d2d, 0x389f4d2d, 0x389f4d2d, 0x461f204b, 0x461f204b, 0x461f204b, 0x24e93599, 0x24e93599, 0x24e93599, 0x59c36f00, 0x79956fa1, 0x79956fa1, 0x59c36f00, }, 20 },
+  { "gfxterm_fr", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x62d33f4d, 0x9544a8f4, 0x62d33f4d, 0x4cd6ba32, 0xaa4593fe, 0xaa4593fe, 0xfb86a3a4, 0xfb86a3a4, 0xfb86a3a4, 0x5d73aec3, 0x5d73aec3, 0x5d73aec3, 0x704b05bb, 0x704b05bb, 0x704b05bb, 0xaa4593fe, 0x4cd6ba32, 0x4cd6ba32, 0xaa4593fe, }, 20 },
+  { "gfxterm_fr", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x8cc4b6dc, 0x1042c383, 0x8cc4b6dc, 0xd1d3db58, 0xc9cbf769, 0xc9cbf769, 0xeba8a32b, 0xeba8a32b, 0xeba8a32b, 0x157062e7, 0x157062e7, 0x157062e7, 0xfc3addef, 0xfc3addef, 0xfc3addef, 0xc9cbf769, 0xd1d3db58, 0xd1d3db58, 0xc9cbf769, }, 20 },
+  { "gfxterm_fr", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x23f9afd, 0x465f5ecc, 0x23f9afd, 0xac69d325, 0x9813a416, 0x9813a416, 0xccf7a1e3, 0xccf7a1e3, 0xccf7a1e3, 0x5d2c27d0, 0x5d2c27d0, 0x5d2c27d0, 0x44961a00, 0x44961a00, 0x44961a00, 0x9813a416, 0xac69d325, 0xac69d325, 0x9813a416, }, 20 },
+  { "gfxterm_fr", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0xed796a26, 0x3132d083, 0xed796a26, 0x9bdf5f95, 0x5fcf013d, 0x5fcf013d, 0x42f66a49, 0x42f66a49, 0x42f66a49, 0x90e6723f, 0x90e6723f, 0x90e6723f, 0x86954da0, 0x86954da0, 0x86954da0, 0x5fcf013d, 0x9bdf5f95, 0x9bdf5f95, 0x5fcf013d, }, 20 },
+  { "gfxterm_fr", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0x54b28785, 0x7fbbe762, 0x54b28785, 0x4fb75d82, 0xdd28f52b, 0xdd28f52b, 0x14b1cf29, 0x14b1cf29, 0x14b1cf29, 0x358d36cd, 0x358d36cd, 0x358d36cd, 0x4835fd41, 0x4835fd41, 0x4835fd41, 0xdd28f52b, 0x4fb75d82, 0x4fb75d82, 0xdd28f52b, }, 20 },
+  { "gfxterm_fr", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x7acc2669, 0xbf1a1d96, 0x7acc2669, 0x85733de9, 0x43d1f34, 0x43d1f34, 0x2cc1e8f4, 0x2cc1e8f4, 0x2cc1e8f4, 0x53cb415c, 0x53cb415c, 0x53cb415c, 0xca9a44da, 0xca9a44da, 0xca9a44da, 0x43d1f34, 0x85733de9, 0x85733de9, 0x43d1f34, }, 20 },
+  { "gfxterm_quot", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xf9511593, 0x9f9ef910, 0xf9511593, 0xbaa7d8d4, 0x59c36f00, 0x59c36f00, 0x7fd94135, 0x7fd94135, 0x7fd94135, 0x1592c53, 0x1592c53, 0x1592c53, 0x63af3981, 0x63af3981, 0x63af3981, 0x59c36f00, 0xbaa7d8d4, 0xbaa7d8d4, 0x59c36f00, }, 20 },
+  { "gfxterm_quot", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x3dcbe25f, 0x99e165e7, 0x3dcbe25f, 0x13ce6720, 0xaa4593fe, 0xaa4593fe, 0x2e88732f, 0x2e88732f, 0x2e88732f, 0x887d7e48, 0x887d7e48, 0x887d7e48, 0xa545d530, 0xa545d530, 0xa545d530, 0xaa4593fe, 0x13ce6720, 0x13ce6720, 0xaa4593fe, }, 20 },
+  { "gfxterm_quot", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xdbedc74c, 0x61619894, 0xdbedc74c, 0x86faaac8, 0xc9cbf769, 0xc9cbf769, 0xda1c9f17, 0xda1c9f17, 0xda1c9f17, 0x24c45edb, 0x24c45edb, 0x24c45edb, 0xcd8ee1d3, 0xcd8ee1d3, 0xcd8ee1d3, 0xc9cbf769, 0x86faaac8, 0x86faaac8, 0xc9cbf769, }, 20 },
+  { "gfxterm_quot", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x2411f56f, 0x97b1fc58, 0x2411f56f, 0x8a47bcb7, 0x9813a416, 0x9813a416, 0xfb08d7cf, 0xfb08d7cf, 0xfb08d7cf, 0x6ad351fc, 0x6ad351fc, 0x6ad351fc, 0x73696c2c, 0x73696c2c, 0x73696c2c, 0x9813a416, 0x8a47bcb7, 0x8a47bcb7, 0x9813a416, }, 20 },
+  { "gfxterm_quot", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x13a65fb6, 0x35044d7, 0x13a65fb6, 0x65006a05, 0x5fcf013d, 0x5fcf013d, 0x9e56a9e0, 0x9e56a9e0, 0x9e56a9e0, 0x4c46b196, 0x4c46b196, 0x4c46b196, 0x5a358e09, 0x5a358e09, 0x5a358e09, 0x5fcf013d, 0x65006a05, 0x65006a05, 0x5fcf013d, }, 20 },
+  { "gfxterm_quot", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xc8f05290, 0x9c88f64e, 0xc8f05290, 0xd3f58897, 0xdd28f52b, 0xdd28f52b, 0xe1579057, 0xe1579057, 0xe1579057, 0xc06b69b3, 0xc06b69b3, 0xc06b69b3, 0xbdd3a23f, 0xbdd3a23f, 0xbdd3a23f, 0xdd28f52b, 0xd3f58897, 0xd3f58897, 0xdd28f52b, }, 20 },
+  { "gfxterm_quot", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x9cfbc80f, 0x376a1fb2, 0x9cfbc80f, 0x6344d38f, 0x43d1f34, 0x43d1f34, 0x6486f7c4, 0x6486f7c4, 0x6486f7c4, 0x1b8c5e6c, 0x1b8c5e6c, 0x1b8c5e6c, 0x82dd5bea, 0x82dd5bea, 0x82dd5bea, 0x43d1f34, 0x6344d38f, 0x6344d38f, 0x43d1f34, }, 20 },
+  { "gfxterm_piglatin", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xd327ca68, 0x9c977e8c, 0xd327ca68, 0x90d1072f, 0x59c36f00, 0x59c36f00, 0x71c9d9, 0x71c9d9, 0x71c9d9, 0x7ef1a4bf, 0x7ef1a4bf, 0x7ef1a4bf, 0x1c07b16d, 0x1c07b16d, 0x1c07b16d, 0x59c36f00, 0x90d1072f, 0x90d1072f, 0x59c36f00, }, 20 },
+  { "gfxterm_piglatin", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x2da3855b, 0x24c7b138, 0x2da3855b, 0x3a60024, 0xaa4593fe, 0xaa4593fe, 0x147ff249, 0x147ff249, 0x147ff249, 0xb28aff2e, 0xb28aff2e, 0xb28aff2e, 0x9fb25456, 0x9fb25456, 0x9fb25456, 0xaa4593fe, 0x3a60024, 0x3a60024, 0xaa4593fe, }, 20 },
+  { "gfxterm_piglatin", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x660ab3d9, 0xa75b45c4, 0x660ab3d9, 0x3b1dde5d, 0xc9cbf769, 0xc9cbf769, 0x5ff884f5, 0x5ff884f5, 0x5ff884f5, 0xa1204539, 0xa1204539, 0xa1204539, 0x486afa31, 0x486afa31, 0x486afa31, 0xc9cbf769, 0x3b1dde5d, 0x3b1dde5d, 0xc9cbf769, }, 20 },
+  { "gfxterm_piglatin", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x920957ee, 0xceebfd42, 0x920957ee, 0x3c5f1e36, 0x9813a416, 0x9813a416, 0xa917dbef, 0xa917dbef, 0xa917dbef, 0x38cc5ddc, 0x38cc5ddc, 0x38cc5ddc, 0x2176600c, 0x2176600c, 0x2176600c, 0x9813a416, 0x3c5f1e36, 0x3c5f1e36, 0x9813a416, }, 20 },
+  { "gfxterm_piglatin", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x8298cd03, 0xfb88293a, 0x8298cd03, 0xf43ef8b0, 0x5fcf013d, 0x5fcf013d, 0x8f57f36b, 0x8f57f36b, 0x8f57f36b, 0x5d47eb1d, 0x5d47eb1d, 0x5d47eb1d, 0x4b34d482, 0x4b34d482, 0x4b34d482, 0x5fcf013d, 0xf43ef8b0, 0xf43ef8b0, 0x5fcf013d, }, 20 },
+  { "gfxterm_piglatin", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xd8bbc577, 0xb2c37549, 0xd8bbc577, 0xc3be1f70, 0xdd28f52b, 0xdd28f52b, 0xd8b598e, 0xd8b598e, 0xd8b598e, 0x2cb7a06a, 0x2cb7a06a, 0x2cb7a06a, 0x510f6be6, 0x510f6be6, 0x510f6be6, 0xdd28f52b, 0xc3be1f70, 0xc3be1f70, 0xdd28f52b, }, 20 },
+  { "gfxterm_piglatin", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x4d7993a1, 0xbeefcd88, 0x4d7993a1, 0xb2c68821, 0x43d1f34, 0x43d1f34, 0x1dbc7020, 0x1dbc7020, 0x1dbc7020, 0x62b6d988, 0x62b6d988, 0x62b6d988, 0xfbe7dc0e, 0xfbe7dc0e, 0xfbe7dc0e, 0x43d1f34, 0xb2c68821, 0xb2c68821, 0x43d1f34, }, 20 },
+  { "gfxterm_ch", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0x628b6f61, 0x50f94215, 0x628b6f61, 0x217da226, 0x59c36f00, 0x59c36f00, 0x5755be7f, 0x5755be7f, 0x5755be7f, 0x29d5d319, 0x29d5d319, 0x29d5d319, 0x4b23c6cb, 0x4b23c6cb, 0x4b23c6cb, 0x59c36f00, 0x217da226, 0x217da226, 0x59c36f00, }, 20 },
+  { "gfxterm_ch", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x9f82cd08, 0xbc67f78d, 0x9f82cd08, 0xb1874877, 0xaa4593fe, 0xaa4593fe, 0x4749512e, 0x4749512e, 0x4749512e, 0xe1bc5c49, 0xe1bc5c49, 0xe1bc5c49, 0xcc84f731, 0xcc84f731, 0xcc84f731, 0xaa4593fe, 0xb1874877, 0xb1874877, 0xaa4593fe, }, 20 },
+  { "gfxterm_ch", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0xbee47cfb, 0x88e98534, 0xbee47cfb, 0xe3f3117f, 0xc9cbf769, 0xc9cbf769, 0xe2396b15, 0xe2396b15, 0xe2396b15, 0x1ce1aad9, 0x1ce1aad9, 0x1ce1aad9, 0xf5ab15d1, 0xf5ab15d1, 0xf5ab15d1, 0xc9cbf769, 0xe3f3117f, 0xe3f3117f, 0xc9cbf769, }, 20 },
+  { "gfxterm_ch", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x2bfd5a83, 0xbe3c6f2f, 0x2bfd5a83, 0x85ab135b, 0x9813a416, 0x9813a416, 0xce30693b, 0xce30693b, 0xce30693b, 0x5febef08, 0x5febef08, 0x5febef08, 0x4651d2d8, 0x4651d2d8, 0x4651d2d8, 0x9813a416, 0x85ab135b, 0x85ab135b, 0x9813a416, }, 20 },
+  { "gfxterm_ch", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x1456f321, 0xc3a55992, 0x1456f321, 0x62f0c692, 0x5fcf013d, 0x5fcf013d, 0xbe3d534a, 0xbe3d534a, 0xbe3d534a, 0x6c2d4b3c, 0x6c2d4b3c, 0x6c2d4b3c, 0x7a5e74a3, 0x7a5e74a3, 0x7a5e74a3, 0x5fcf013d, 0x62f0c692, 0x62f0c692, 0x5fcf013d, }, 20 },
+  { "gfxterm_ch", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xdcac6945, 0x43fbdf5a, 0xdcac6945, 0xc7a9b342, 0xdd28f52b, 0xdd28f52b, 0x274da20b, 0x274da20b, 0x274da20b, 0x6715bef, 0x6715bef, 0x6715bef, 0x7bc99063, 0x7bc99063, 0x7bc99063, 0xdd28f52b, 0xc7a9b342, 0xc7a9b342, 0xdd28f52b, }, 20 },
+  { "gfxterm_ch", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x571e16b1, 0xb9f25c2, 0x571e16b1, 0xa8a10d31, 0x43d1f34, 0x43d1f34, 0x25dfb69d, 0x25dfb69d, 0x25dfb69d, 0x5ad51f35, 0x5ad51f35, 0x5ad51f35, 0xc3841ab3, 0xc3841ab3, 0xc3841ab3, 0x43d1f34, 0xa8a10d31, 0xa8a10d31, 0x43d1f34, }, 20 },
+  { "gfxterm_red", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xec987771, 0x8a579bf2, 0xec987771, 0xbbb5c9af, 0x59c36f00, 0x59c36f00, 0x16780f43, 0x16780f43, 0x16780f43, 0x68f86225, 0x68f86225, 0x68f86225, 0xa0e77f7, 0xa0e77f7, 0xa0e77f7, 0x59c36f00, 0xbbb5c9af, 0xbbb5c9af, 0x59c36f00, }, 20 },
+  { "gfxterm_red", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0x97994d2c, 0x33b3ca94, 0x97994d2c, 0x273e977a, 0xaa4593fe, 0xaa4593fe, 0xa592c9d5, 0xa592c9d5, 0xa592c9d5, 0x367c4b2, 0x367c4b2, 0x367c4b2, 0x2e5f6fca, 0x2e5f6fca, 0x2e5f6fca, 0xaa4593fe, 0x273e977a, 0x273e977a, 0xaa4593fe, }, 20 },
+  { "gfxterm_red", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x5d2416aa, 0xe7a84972, 0x5d2416aa, 0x4d010804, 0xc9cbf769, 0xc9cbf769, 0x4e3a88a0, 0x4e3a88a0, 0x4e3a88a0, 0xb0e2496c, 0xb0e2496c, 0xb0e2496c, 0x59a8f664, 0x59a8f664, 0x59a8f664, 0xc9cbf769, 0x4d010804, 0x4d010804, 0xc9cbf769, }, 20 },
+  { "gfxterm_red", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x1da65b43, 0xae065274, 0x1da65b43, 0x2dd7a76c, 0x9813a416, 0x9813a416, 0xf81d19f, 0xf81d19f, 0xf81d19f, 0x9e5a57ac, 0x9e5a57ac, 0x9e5a57ac, 0x87e06a7c, 0x87e06a7c, 0x87e06a7c, 0x9813a416, 0x2dd7a76c, 0x2dd7a76c, 0x9813a416, }, 20 },
+  { "gfxterm_red", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0xea8a940e, 0xfa7c8f6f, 0xea8a940e, 0x448d7bfb, 0x5fcf013d, 0x5fcf013d, 0x47c22fa0, 0x47c22fa0, 0x47c22fa0, 0x95d237d6, 0x95d237d6, 0x95d237d6, 0x83a10849, 0x83a10849, 0x83a10849, 0x5fcf013d, 0x448d7bfb, 0x448d7bfb, 0x5fcf013d, }, 20 },
+  { "gfxterm_red", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xc0ac44fa, 0x94d4e024, 0xc0ac44fa, 0x4ec88f20, 0xdd28f52b, 0xdd28f52b, 0x2422f542, 0x2422f542, 0x2422f542, 0x51e0ca6, 0x51e0ca6, 0x51e0ca6, 0x78a6c72a, 0x78a6c72a, 0x78a6c72a, 0xdd28f52b, 0x4ec88f20, 0x4ec88f20, 0xdd28f52b, }, 20 },
+  { "gfxterm_red", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x248f7655, 0x8f1ea1e8, 0x248f7655, 0xb3d7f0f5, 0x43d1f34, 0x43d1f34, 0x8c408c04, 0x8c408c04, 0x8c408c04, 0xf34a25ac, 0xf34a25ac, 0xf34a25ac, 0x6a1b202a, 0x6a1b202a, 0x6a1b202a, 0x43d1f34, 0xb3d7f0f5, 0xb3d7f0f5, 0x43d1f34, }, 20 },
+  { "gfxterm_high", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x59c36f00, 0xd6ba8f78, 0xb07563fb, 0xd6ba8f78, 0x6ef020b2, 0x59c36f00, 0x59c36f00, 0x7fd94135, 0x7fd94135, 0x7fd94135, 0x1592c53, 0x1592c53, 0x1592c53, 0x63af3981, 0x63af3981, 0x63af3981, 0x59c36f00, 0x6ef020b2, 0x6ef020b2, 0x59c36f00, }, 20 },
+  { "gfxterm_high", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0xaa4593fe, 0xf5257f70, 0x510ff8c8, 0xf5257f70, 0x36a3b7ff, 0xaa4593fe, 0xaa4593fe, 0x2e88732f, 0x2e88732f, 0x2e88732f, 0x887d7e48, 0x887d7e48, 0x887d7e48, 0xa545d530, 0xa545d530, 0xa545d530, 0xaa4593fe, 0x36a3b7ff, 0x36a3b7ff, 0xaa4593fe, }, 20 },
+  { "gfxterm_high", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xc9cbf769, 0x9f8effb3, 0x2502a06b, 0x9f8effb3, 0xddeb038e, 0xc9cbf769, 0xc9cbf769, 0xda1c9f17, 0xda1c9f17, 0xda1c9f17, 0x24c45edb, 0x24c45edb, 0x24c45edb, 0xcd8ee1d3, 0xcd8ee1d3, 0xcd8ee1d3, 0xc9cbf769, 0xddeb038e, 0xddeb038e, 0xc9cbf769, }, 20 },
+  { "gfxterm_high", 640, 480, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 640x480xrgba8888 */, (grub_uint32_t []) { 0x9813a416, 0x6aa72774, 0xd9072e43, 0x6aa72774, 0x24b4853d, 0x9813a416, 0x9813a416, 0xfb08d7cf, 0xfb08d7cf, 0xfb08d7cf, 0x6ad351fc, 0x6ad351fc, 0x6ad351fc, 0x73696c2c, 0x73696c2c, 0x73696c2c, 0x9813a416, 0x24b4853d, 0x24b4853d, 0x9813a416, }, 20 },
+  { "gfxterm_high", 800, 600, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 800x600xrgba8888 */, (grub_uint32_t []) { 0x5fcf013d, 0x936eb1d8, 0x8398aab9, 0x936eb1d8, 0x8beef, 0x5fcf013d, 0x5fcf013d, 0x9e56a9e0, 0x9e56a9e0, 0x9e56a9e0, 0x4c46b196, 0x4c46b196, 0x4c46b196, 0x5a358e09, 0x5a358e09, 0x5a358e09, 0x5fcf013d, 0x8beef, 0x8beef, 0x5fcf013d, }, 20 },
+  { "gfxterm_high", 1024, 768, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 1024x768xrgba8888 */, (grub_uint32_t []) { 0xdd28f52b, 0xdd4b9ec3, 0x89333a1d, 0xdd4b9ec3, 0x3acd5a9d, 0xdd28f52b, 0xdd28f52b, 0xe1579057, 0xe1579057, 0xe1579057, 0xc06b69b3, 0xc06b69b3, 0xc06b69b3, 0xbdd3a23f, 0xbdd3a23f, 0xbdd3a23f, 0xdd28f52b, 0x3acd5a9d, 0x3acd5a9d, 0xdd28f52b, }, 20 },
+  { "gfxterm_high", 2560, 1440, 0x1, 256, 32, 4, 16, 8, 8, 8, 0, 8, 24, 8 /* 2560x1440xrgba8888 */, (grub_uint32_t []) { 0x43d1f34, 0x89f37601, 0x2262a1bc, 0x89f37601, 0xf17b28ae, 0x43d1f34, 0x43d1f34, 0x6486f7c4, 0x6486f7c4, 0x6486f7c4, 0x1b8c5e6c, 0x1b8c5e6c, 0x1b8c5e6c, 0x82dd5bea, 0x82dd5bea, 0x82dd5bea, 0x43d1f34, 0xf17b28ae, 0xf17b28ae, 0x43d1f34, }, 20 },
   { "videotest", 640, 480, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 640x480xi16 */, (grub_uint32_t []) { 0x1368a483, 0x1368a483, 0x1368a483, 0x1368a483, 0x1368a483, }, 5 },
   { "videotest", 800, 600, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 800x600xi16 */, (grub_uint32_t []) { 0x7033079c, 0x7033079c, 0x7033079c, 0x7033079c, 0x7033079c, }, 5 },
   { "videotest", 1024, 768, 0x2, 16, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0 /* 1024x768xi16 */, (grub_uint32_t []) { 0xff583fbf, 0xff583fbf, 0xff583fbf, 0xff583fbf, 0xff583fbf, }, 5 },
diff --git a/include/grub/arm/coreboot/console.h b/include/grub/arm/coreboot/console.h
new file mode 100644
index 0000000000000000000000000000000000000000..13a14b783839a6cae96845973ae3087bcaef670e
--- /dev/null
+++ b/include/grub/arm/coreboot/console.h
@@ -0,0 +1,29 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2009  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_MACHINE_CONSOLE_HEADER
+#define GRUB_MACHINE_CONSOLE_HEADER	1
+
+void grub_video_coreboot_fb_init (void);
+void grub_video_coreboot_fb_early_init (void);
+void grub_video_coreboot_fb_late_init (void);
+void grub_video_coreboot_fb_fini (void);
+
+extern struct grub_linuxbios_table_framebuffer *grub_video_coreboot_fbtable;
+
+#endif /* ! GRUB_MACHINE_CONSOLE_HEADER */
diff --git a/include/grub/arm/coreboot/kernel.h b/include/grub/arm/coreboot/kernel.h
new file mode 100644
index 0000000000000000000000000000000000000000..2695053427050f306b8ca86ba066df90c519e8e0
--- /dev/null
+++ b/include/grub/arm/coreboot/kernel.h
@@ -0,0 +1,44 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_KERNEL_MACHINE_HEADER
+#define GRUB_KERNEL_MACHINE_HEADER	1
+
+#ifndef ASM_FILE
+
+#include <grub/symbol.h>
+#include <grub/types.h>
+
+struct grub_fdt_board
+{
+  const char *vendor, *part;
+  const grub_uint8_t *dtb;
+  grub_size_t dtb_size;
+};
+
+extern struct grub_fdt_board grub_fdt_boards[];
+void grub_machine_timer_init (void);
+void grub_pl050_init (void);
+void grub_cros_init (void);
+void grub_rk3288_spi_init (void);
+extern grub_addr_t EXPORT_VAR (start_of_ram);
+#endif /* ! ASM_FILE */
+
+#define GRUB_KERNEL_MACHINE_STACK_SIZE GRUB_KERNEL_ARM_STACK_SIZE
+
+#endif /* ! GRUB_KERNEL_MACHINE_HEADER */
diff --git a/include/grub/arm/cros_ec.h b/include/grub/arm/cros_ec.h
new file mode 100644
index 0000000000000000000000000000000000000000..45a372572a5c3c411c9b2b7f328135f5cbe551c8
--- /dev/null
+++ b/include/grub/arm/cros_ec.h
@@ -0,0 +1,21 @@
+#ifndef GRUB_ARM_CROS_EC_H
+#define GRUB_ARM_CROS_EC_H 1
+
+#include <grub/types.h>
+#include <grub/fdtbus.h>
+
+#define GRUB_CROS_EC_KEYSCAN_COLS 13
+#define GRUB_CROS_EC_KEYSCAN_ROWS 8
+
+struct grub_cros_ec_keyscan {
+  grub_uint8_t data[GRUB_CROS_EC_KEYSCAN_COLS];
+};
+
+int
+grub_cros_ec_scan_keyboard (const struct grub_fdtbus_dev *dev,
+			    struct grub_cros_ec_keyscan *scan);
+
+int
+grub_cros_ec_validate (const struct grub_fdtbus_dev *dev);
+
+#endif
diff --git a/include/grub/arm/linux.h b/include/grub/arm/linux.h
index a66caad13db8c5c3b0da10f624d01a81640eab44..f217f8281ade38fdb95ebd0b0e18bdf7bbe9aaf9 100644
--- a/include/grub/arm/linux.h
+++ b/include/grub/arm/linux.h
@@ -46,6 +46,22 @@ grub_arm_firmware_get_machine_type (void)
 {
   return GRUB_ARM_MACHINE_TYPE_FDT;
 }
+#elif defined (GRUB_MACHINE_COREBOOT)
+#include <grub/fdtbus.h>
+#include <grub/machine/kernel.h>
+# define LINUX_ADDRESS        (start_of_ram + 0x8000)
+# define LINUX_INITRD_ADDRESS (start_of_ram + 0x02000000)
+# define LINUX_FDT_ADDRESS    (LINUX_INITRD_ADDRESS - 0x10000)
+static inline const void *
+grub_arm_firmware_get_boot_data (void)
+{
+  return grub_fdtbus_get_fdt ();
+}
+static inline grub_uint32_t
+grub_arm_firmware_get_machine_type (void)
+{
+  return GRUB_ARM_MACHINE_TYPE_FDT;
+}
 #endif
 
 #define FDT_ADDITIONAL_ENTRIES_SIZE	0x300
diff --git a/include/grub/arm/startup.h b/include/grub/arm/startup.h
new file mode 100644
index 0000000000000000000000000000000000000000..9afb6c57c0bc4c53e96f711bf545d94a8ed07aa5
--- /dev/null
+++ b/include/grub/arm/startup.h
@@ -0,0 +1,16 @@
+#ifndef GRUB_STARTUP_CPU_HEADER
+#define GRUB_STARTUP_CPU_HEADER
+
+struct grub_arm_startup_registers
+{
+  /* registers 0-11 */
+  /* for U-boot r[1] is machine type */
+  /* for U-boot r[2] is boot data */
+  grub_uint32_t r[12];
+  grub_uint32_t sp;
+  grub_uint32_t lr;
+};
+
+extern struct grub_arm_startup_registers grub_arm_saved_registers;
+
+#endif
diff --git a/include/grub/arm64/linux.h b/include/grub/arm64/linux.h
index 1ea23696e7a096e53075af2314da11ecce91f8d7..a981df5d15f5f186935af0648da2408ac613f796 100644
--- a/include/grub/arm64/linux.h
+++ b/include/grub/arm64/linux.h
@@ -23,8 +23,6 @@
 
 #define GRUB_ARM64_LINUX_MAGIC 0x644d5241 /* 'ARM\x64' */
 
-#define GRUB_EFI_PE_MAGIC	0x5A4D
-
 /* From linux/Documentation/arm64/booting.txt */
 struct grub_arm64_linux_kernel_header
 {
diff --git a/include/grub/at_keyboard.h b/include/grub/at_keyboard.h
index b4f8ff0a06117756a770129683796edf0050b867..bcb4d9ba78f1376bdaa82249418f847eb4e543a6 100644
--- a/include/grub/at_keyboard.h
+++ b/include/grub/at_keyboard.h
@@ -23,13 +23,11 @@
 #define KEYBOARD_COMMAND_ISREADY(x)	!((x) & 0x02)
 #define KEYBOARD_COMMAND_READ		0x20
 #define KEYBOARD_COMMAND_WRITE		0x60
+#define KEYBOARD_COMMAND_ENABLE		0xf4
 #define KEYBOARD_COMMAND_REBOOT		0xfe
 
 #define KEYBOARD_AT_TRANSLATE		0x40
-
-#define GRUB_AT_ACK                     0xfa
-#define GRUB_AT_NACK                    0xfe
-#define GRUB_AT_TRIES                   5
+#define KEYBOARD_AT_DISABLE		0x10
 
 #define KEYBOARD_ISMAKE(x)	!((x) & 0x80)
 #define KEYBOARD_ISREADY(x)	((x) & 0x01)
diff --git a/include/grub/autoefi.h b/include/grub/autoefi.h
index b75591176eb9d785de3f2867e32edc1b9a626280..b7a252e079e2137b4d27639b5c981e9085cb8a82 100644
--- a/include/grub/autoefi.h
+++ b/include/grub/autoefi.h
@@ -55,7 +55,7 @@ static inline grub_err_t grub_autoefi_prepare (void)
 # define SYSTEM_TABLE_PTR GRUB_EFIEMU_SYSTEM_TABLE_PTR
 # define SIZEOF_OF_UINTN GRUB_EFIEMU_SIZEOF_OF_UINTN
 # define SYSTEM_TABLE GRUB_EFIEMU_SYSTEM_TABLE
-# define grub_efi_allocate_pages(x,y) (x)
+# define grub_efi_allocate_fixed(x,y) (x)
 # define grub_efi_free_pages(x,y) GRUB_EFI_SUCCESS
 # define grub_autoefi_finish_boot_services grub_efiemu_finish_boot_services
 # define EFI_PRESENT 1
diff --git a/include/grub/cache.h b/include/grub/cache.h
index fc669dfd1892c14bb43c6230e48067a0ff8e7c23..ccfa717e669625e0db96df0692c65f5a4c5ff916 100644
--- a/include/grub/cache.h
+++ b/include/grub/cache.h
@@ -34,15 +34,16 @@ void EXPORT_FUNC(grub_arch_sync_caches) (void *address, grub_size_t len);
 #endif
 
 #ifndef GRUB_MACHINE_EMU
-#ifdef _mips
-void EXPORT_FUNC(grub_arch_sync_dma_caches) (volatile void *address,
-					     grub_size_t len);
-#else
+#if defined (__aarch64__) || defined (__powerpc__) || defined (__sparc__)
+
+#elif defined (__i386__) || defined (__x86_64__)
 static inline void
 grub_arch_sync_dma_caches (volatile void *address __attribute__ ((unused)),
 			   grub_size_t len __attribute__ ((unused)))
 {
 }
+#else
+void EXPORT_FUNC(grub_arch_sync_dma_caches) (volatile void *address, grub_size_t len);
 #endif
 #endif
 
diff --git a/include/grub/i386/coreboot/lbio.h b/include/grub/coreboot/lbio.h
similarity index 93%
rename from include/grub/i386/coreboot/lbio.h
rename to include/grub/coreboot/lbio.h
index 1c3fa6f1953c3a6b41ea3644c30f000c98524224..5076d36c71ba32e5c55a6242287e5fe159e09b4f 100644
--- a/include/grub/i386/coreboot/lbio.h
+++ b/include/grub/coreboot/lbio.h
@@ -20,6 +20,9 @@
 #ifndef _GRUB_MACHINE_LBIO_HEADER
 #define _GRUB_MACHINE_LBIO_HEADER      1
 
+#include <grub/types.h>
+#include <grub/err.h>
+
 struct grub_linuxbios_table_header
 {
   grub_uint8_t signature[4];
@@ -102,4 +105,10 @@ EXPORT_FUNC(grub_linuxbios_table_iterate) (int (*hook) (grub_linuxbios_table_ite
 					   void *),
 					   void *hook_data);
 
+grub_linuxbios_table_header_t
+grub_linuxbios_get_tables (void);
+
+int
+grub_linuxbios_check_signature (grub_linuxbios_table_header_t tbl_header);
+
 #endif
diff --git a/include/grub/dma.h b/include/grub/dma.h
new file mode 100644
index 0000000000000000000000000000000000000000..19992ebc131d4fc93a45f31992ad3c03b9de2821
--- /dev/null
+++ b/include/grub/dma.h
@@ -0,0 +1,44 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2008,2009  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef	GRUB_DMA_H
+#define	GRUB_DMA_H	1
+
+struct grub_pci_dma_chunk;
+
+struct grub_pci_dma_chunk *EXPORT_FUNC(grub_memalign_dma32) (grub_size_t align,
+							     grub_size_t size);
+void EXPORT_FUNC(grub_dma_free) (struct grub_pci_dma_chunk *ch);
+volatile void *EXPORT_FUNC(grub_dma_get_virt) (struct grub_pci_dma_chunk *ch);
+grub_uint32_t EXPORT_FUNC(grub_dma_get_phys) (struct grub_pci_dma_chunk *ch);
+
+static inline void *
+grub_dma_phys2virt (grub_uint32_t phys, struct grub_pci_dma_chunk *chunk)
+{
+  return ((grub_uint8_t *) grub_dma_get_virt (chunk)
+	  + (phys - grub_dma_get_phys (chunk)));
+}
+
+static inline grub_uint32_t
+grub_dma_virt2phys (volatile void *virt, struct grub_pci_dma_chunk *chunk)
+{
+  return (((grub_uint8_t *) virt - (grub_uint8_t *) grub_dma_get_virt (chunk))
+	  + grub_dma_get_phys (chunk));
+}
+
+#endif
diff --git a/include/grub/efi/efi.h b/include/grub/efi/efi.h
index e9c601f34103ae1a4ced7e93be8204970bfef193..3fa082816ca5d6a5ae98d91d3ead3ef05a969159 100644
--- a/include/grub/efi/efi.h
+++ b/include/grub/efi/efi.h
@@ -38,8 +38,15 @@ void *EXPORT_FUNC(grub_efi_open_protocol) (grub_efi_handle_t handle,
 int EXPORT_FUNC(grub_efi_set_text_mode) (int on);
 void EXPORT_FUNC(grub_efi_stall) (grub_efi_uintn_t microseconds);
 void *
-EXPORT_FUNC(grub_efi_allocate_pages) (grub_efi_physical_address_t address,
+EXPORT_FUNC(grub_efi_allocate_pages_real) (grub_efi_physical_address_t address,
+				           grub_efi_uintn_t pages,
+					   grub_efi_allocate_type_t alloctype,
+					   grub_efi_memory_type_t memtype);
+void *
+EXPORT_FUNC(grub_efi_allocate_fixed) (grub_efi_physical_address_t address,
 				      grub_efi_uintn_t pages);
+void *
+EXPORT_FUNC(grub_efi_allocate_any_pages) (grub_efi_uintn_t pages);
 void EXPORT_FUNC(grub_efi_free_pages) (grub_efi_physical_address_t address,
 				       grub_efi_uintn_t pages);
 int
diff --git a/include/grub/arm64/fdtload.h b/include/grub/efi/fdtload.h
similarity index 100%
rename from include/grub/arm64/fdtload.h
rename to include/grub/efi/fdtload.h
diff --git a/include/grub/efi/pe32.h b/include/grub/efi/pe32.h
index f79c36c026e0a518b3f9edaca36251d6d4943757..7d44732d2c353b74271262a1cf094d4aafd8dd10 100644
--- a/include/grub/efi/pe32.h
+++ b/include/grub/efi/pe32.h
@@ -45,6 +45,8 @@
 
 #define GRUB_PE32_MSDOS_STUB_SIZE	0x80
 
+#define GRUB_PE32_MAGIC			0x5a4d
+
 /* According to the spec, the minimal alignment is 512 bytes...
    But some examples (such as EFI drivers in the Intel
    Sample Implementation) use 32 bytes (0x20) instead, and it seems
diff --git a/include/grub/fdt.h b/include/grub/fdt.h
index fdfca75bf487f17e8621fee5d1642f4874a2bf16..75525fa317c340c7649f0241bf447ee47495b78a 100644
--- a/include/grub/fdt.h
+++ b/include/grub/fdt.h
@@ -20,6 +20,7 @@
 #define GRUB_FDT_HEADER	1
 
 #include <grub/types.h>
+#include <grub/symbol.h>
 
 #define FDT_MAGIC 0xD00DFEED
 
@@ -95,16 +96,22 @@ struct grub_fdt_empty_tree {
 #define grub_fdt_set_size_dt_struct(fdt, value)	\
 	grub_fdt_set_header(fdt, size_dt_struct, value)
 
-int grub_fdt_create_empty_tree (void *fdt, unsigned int size);
-int grub_fdt_check_header (void *fdt, unsigned int size);
-int grub_fdt_check_header_nosize (void *fdt);
-int grub_fdt_find_subnode (const void *fdt, unsigned int parentoffset,
-			   const char *name);
-int grub_fdt_add_subnode (void *fdt, unsigned int parentoffset,
+int EXPORT_FUNC(grub_fdt_create_empty_tree) (void *fdt, unsigned int size);
+int EXPORT_FUNC(grub_fdt_check_header) (const void *fdt, unsigned int size);
+int EXPORT_FUNC(grub_fdt_check_header_nosize) (const void *fdt);
+int EXPORT_FUNC(grub_fdt_find_subnode) (const void *fdt, unsigned int parentoffset,
+					const char *name);
+int EXPORT_FUNC(grub_fdt_first_node) (const void *fdt, unsigned int parentoffset);
+int EXPORT_FUNC(grub_fdt_next_node) (const void *fdt, unsigned int currentoffset);
+int EXPORT_FUNC(grub_fdt_add_subnode) (void *fdt, unsigned int parentoffset,
 			  const char *name);
+const char *
+EXPORT_FUNC(grub_fdt_get_nodename) (const void *fdt, unsigned int nodeoffset);
+const void *EXPORT_FUNC(grub_fdt_get_prop) (const void *fdt, unsigned int nodeoffset, const char *name,
+					    grub_uint32_t *len);
 
-int grub_fdt_set_prop (void *fdt, unsigned int nodeoffset, const char *name,
-		      const void *val, grub_uint32_t len);
+int EXPORT_FUNC(grub_fdt_set_prop) (void *fdt, unsigned int nodeoffset, const char *name,
+				    const void *val, grub_uint32_t len);
 #define grub_fdt_set_prop32(fdt, nodeoffset, name, val)	\
 ({ \
   grub_uint32_t _val = grub_cpu_to_be32(val); \
diff --git a/include/grub/fdtbus.h b/include/grub/fdtbus.h
new file mode 100644
index 0000000000000000000000000000000000000000..f519c40ec35faea9aeedca055164012d9d9b3fb5
--- /dev/null
+++ b/include/grub/fdtbus.h
@@ -0,0 +1,89 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2016  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_FDTBUS_HEADER
+#define GRUB_FDTBUS_HEADER	1
+
+#include <grub/fdt.h>
+#include <grub/err.h>
+
+struct grub_fdtbus_dev
+{
+  struct grub_fdtbus_dev *next;
+  struct grub_fdtbus_dev *parent;
+  int node;
+  struct grub_fdtbus_driver *driver;
+};
+
+struct grub_fdtbus_driver
+{
+  struct grub_fdtbus_driver *next;
+  struct grub_fdtbus_driver **prev;
+
+  const char *compatible;
+
+  grub_err_t (*attach) (const struct grub_fdtbus_dev *dev);
+  void (*detach) (const struct grub_fdtbus_dev *dev);
+
+  /* Message bus operations.  */
+  grub_err_t (*send) (const struct grub_fdtbus_dev *dev, const void *data, grub_size_t sz);
+  grub_err_t (*receive) (const struct grub_fdtbus_dev *dev, void *data, grub_size_t sz);
+  grub_err_t (*start) (const struct grub_fdtbus_dev *dev);
+  void (*stop) (const struct grub_fdtbus_dev *dev);
+};
+
+extern char EXPORT_VAR(grub_fdtbus_invalid_mapping)[1];
+
+static inline int
+grub_fdtbus_is_mapping_valid (volatile void *m)
+{
+  return m != grub_fdtbus_invalid_mapping;
+}
+
+volatile void *
+EXPORT_FUNC(grub_fdtbus_map_reg) (const struct grub_fdtbus_dev *dev, int reg, grub_size_t *size);
+
+const void *
+EXPORT_FUNC(grub_fdtbus_get_fdt) (void);
+
+const char *
+EXPORT_FUNC(grub_fdtbus_get_name) (const struct grub_fdtbus_dev *dev);
+
+const void *
+EXPORT_FUNC(grub_fdtbus_get_prop) (const struct grub_fdtbus_dev *dev,
+		      const char *name,
+		      grub_uint32_t *len);
+
+void
+EXPORT_FUNC(grub_fdtbus_register) (struct grub_fdtbus_driver *driver);
+
+void
+EXPORT_FUNC(grub_fdtbus_unregister) (struct grub_fdtbus_driver *driver);
+
+int
+EXPORT_FUNC(grub_fdtbus_is_compatible) (const char *compat_string,
+					const struct grub_fdtbus_dev *dev);
+
+/* Must be called before any register(). */
+/* dtb is assumed to be unfreeable and must remain
+   valid for lifetime of GRUB.
+ */
+void
+grub_fdtbus_init (const void *dtb, grub_size_t size);
+
+#endif
diff --git a/include/grub/kernel.h b/include/grub/kernel.h
index 20ddf2da297d5c883ed5b5542f2cfd99ee9c18da..ecd88ca72c6dea39be9f046463e7c51c874cb351 100644
--- a/include/grub/kernel.h
+++ b/include/grub/kernel.h
@@ -28,7 +28,8 @@ enum
   OBJ_TYPE_MEMDISK,
   OBJ_TYPE_CONFIG,
   OBJ_TYPE_PREFIX,
-  OBJ_TYPE_PUBKEY
+  OBJ_TYPE_PUBKEY,
+  OBJ_TYPE_DTB
 };
 
 /* The module header.  */
diff --git a/include/grub/net.h b/include/grub/net.h
index 2192fa18628862e8e3a6046d854b12613e914ff9..1096b24322eb1ba36e8c996872fce2a255e6bccc 100644
--- a/include/grub/net.h
+++ b/include/grub/net.h
@@ -291,6 +291,7 @@ struct grub_net_network_level_interface
   grub_net_interface_flags_t flags;
   struct grub_net_bootp_packet *dhcp_ack;
   grub_size_t dhcp_acklen;
+  grub_uint16_t vlantag;
   void *data;
 };
 
@@ -561,4 +562,6 @@ extern char *grub_net_default_server;
 #define GRUB_NET_INTERVAL 400
 #define GRUB_NET_INTERVAL_ADDITION 20
 
+#define VLANTAG_IDENTIFIER 0x8100
+
 #endif /* ! GRUB_NET_HEADER */
diff --git a/include/grub/net/arp.h b/include/grub/net/arp.h
index bb1703622e1529479618e7f71b0d5e88adb631d1..8d9d081134f52e2d33c23928baae7f6b4c08470f 100644
--- a/include/grub/net/arp.h
+++ b/include/grub/net/arp.h
@@ -22,10 +22,11 @@
 #include <grub/net.h>
 
 extern grub_err_t grub_net_arp_receive (struct grub_net_buff *nb,
-					struct grub_net_card *card);
+                                        struct grub_net_card *card,
+                                        grub_uint16_t *vlantag);
 
 grub_err_t
 grub_net_arp_send_request (struct grub_net_network_level_interface *inf,
-			   const grub_net_network_level_address_t *proto_addr);
+                           const grub_net_network_level_address_t *proto_addr);
 
 #endif 
diff --git a/include/grub/net/ip.h b/include/grub/net/ip.h
index dcceaa56894605a39f87858964da7af11951ff11..ab9d68f98252b9772853a712ff1e8556162002ee 100644
--- a/include/grub/net/ip.h
+++ b/include/grub/net/ip.h
@@ -48,7 +48,8 @@ grub_err_t
 grub_net_recv_ip_packets (struct grub_net_buff *nb,
 			  struct grub_net_card *card,
 			  const grub_net_link_level_address_t *hwaddress,
-			  const grub_net_link_level_address_t *src_hwaddress);
+			  const grub_net_link_level_address_t *src_hwaddress,
+                          grub_uint16_t *vlantag);
 
 grub_err_t
 grub_net_send_ip_packet (struct grub_net_network_level_interface *inf,
diff --git a/include/grub/offsets.h b/include/grub/offsets.h
index c88c86d4d2ebddddb23f25c50ad2c29b52e54ccb..bf0689fc99a89ff465985af7d1708c15a68c90eb 100644
--- a/include/grub/offsets.h
+++ b/include/grub/offsets.h
@@ -122,6 +122,12 @@
 #define GRUB_KERNEL_ARM_UBOOT_MOD_ALIGN 	0x8
 #define GRUB_KERNEL_ARM_UBOOT_TOTAL_MODULE_SIZE	0x4
 
+#define GRUB_KERNEL_ARM_COREBOOT_MOD_ALIGN 	0x8
+#define GRUB_KERNEL_ARM_COREBOOT_TOTAL_MODULE_SIZE	0x4
+
+#define GRUB_KERNEL_ARM_STACK_SIZE 0x40000
+#define GRUB_KERNEL_ARM_COREBOOT_MOD_GAP (GRUB_KERNEL_ARM_STACK_SIZE + 1024)
+
 /* Minimal gap between _end and the start of the modules.  It's a hack
    for PowerMac to prevent "CLAIM failed" error.  The real fix is to
    rewrite grub-mkimage to generate valid ELF files.  */
diff --git a/include/grub/pci.h b/include/grub/pci.h
index 70d9a05131b240bbe3c7fe12df899c8e3de237ce..262c89b748bbfccc98ffa27912ce7e2a5005f545 100644
--- a/include/grub/pci.h
+++ b/include/grub/pci.h
@@ -142,27 +142,7 @@ grub_pci_address_t EXPORT_FUNC(grub_pci_make_address) (grub_pci_device_t dev,
 void EXPORT_FUNC(grub_pci_iterate) (grub_pci_iteratefunc_t hook,
 				    void *hook_data);
 
-struct grub_pci_dma_chunk;
-
-struct grub_pci_dma_chunk *EXPORT_FUNC(grub_memalign_dma32) (grub_size_t align,
-							     grub_size_t size);
-void EXPORT_FUNC(grub_dma_free) (struct grub_pci_dma_chunk *ch);
-volatile void *EXPORT_FUNC(grub_dma_get_virt) (struct grub_pci_dma_chunk *ch);
-grub_uint32_t EXPORT_FUNC(grub_dma_get_phys) (struct grub_pci_dma_chunk *ch);
-
-static inline void *
-grub_dma_phys2virt (grub_uint32_t phys, struct grub_pci_dma_chunk *chunk)
-{
-  return ((grub_uint8_t *) grub_dma_get_virt (chunk)
-	  + (phys - grub_dma_get_phys (chunk)));
-}
-
-static inline grub_uint32_t
-grub_dma_virt2phys (volatile void *virt, struct grub_pci_dma_chunk *chunk)
-{
-  return (((grub_uint8_t *) virt - (grub_uint8_t *) grub_dma_get_virt (chunk))
-	  + grub_dma_get_phys (chunk));
-}
+#include <grub/dma.h>
 
 grub_uint8_t
 EXPORT_FUNC (grub_pci_find_capability) (grub_pci_device_t dev, grub_uint8_t cap);
diff --git a/include/grub/ps2.h b/include/grub/ps2.h
new file mode 100644
index 0000000000000000000000000000000000000000..4f2e527e49767c297646f1ea3d0e09bdc2855892
--- /dev/null
+++ b/include/grub/ps2.h
@@ -0,0 +1,43 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2007,2008,2009  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_PS2_HEADER
+#define GRUB_PS2_HEADER	1
+
+#include <grub/types.h>
+
+#define GRUB_AT_ACK                     0xfa
+#define GRUB_AT_NACK                    0xfe
+#define GRUB_AT_TRIES                   5
+
+/* Make sure it's zeroed-out and set current_set at init.  */
+struct grub_ps2_state
+{
+  int e0_received;
+  int f0_received;
+  grub_uint8_t led_status;
+  short at_keyboard_status;
+  grub_uint8_t current_set;
+};
+
+/* If there is a key pending, return it; otherwise return GRUB_TERM_NO_KEY.  */
+int
+grub_ps2_process_incoming_byte (struct grub_ps2_state *ps2_state,
+				grub_uint8_t data);
+
+#endif
diff --git a/include/grub/term.h b/include/grub/term.h
index 5ffb38f69aaa8911a66bdc6f417a72666b19e514..8117e2a24dac3f270d05408f1897fae9f0fa1593 100644
--- a/include/grub/term.h
+++ b/include/grub/term.h
@@ -55,7 +55,8 @@
 #define GRUB_TERM_KEY_INSERT    (GRUB_TERM_EXTENDED | 0x52)
 #define GRUB_TERM_KEY_CENTER    (GRUB_TERM_EXTENDED | 0x4c)
 
-#define GRUB_TERM_ESC		'\e'
+/* Hex value is used for ESC, since '\e' is nonstandard */
+#define GRUB_TERM_ESC		0x1b
 #define GRUB_TERM_TAB		'\t'
 #define GRUB_TERM_BACKSPACE	'\b'
 
diff --git a/include/grub/usb.h b/include/grub/usb.h
index 11d96481ff6b58cc43f468bcb2020475663fa098..512ae1dd0e64931c852847c9d52efdbd6b2caccb 100644
--- a/include/grub/usb.h
+++ b/include/grub/usb.h
@@ -321,5 +321,9 @@ grub_usb_err_t
 grub_usb_check_transfer (grub_usb_transfer_t trans, grub_size_t *actual);
 void
 grub_usb_cancel_transfer (grub_usb_transfer_t trans);
+void
+grub_ehci_init_device (volatile void *regs);
+void
+grub_ehci_pci_scan (void);
 
 #endif /* GRUB_USB_H */
diff --git a/include/grub/util/install.h b/include/grub/util/install.h
index 5ca4811cd130f6810f07e6fbce89af1de36827c7..5910b0c09bc8be529e074d388afabcd60eea7ab4 100644
--- a/include/grub/util/install.h
+++ b/include/grub/util/install.h
@@ -29,6 +29,8 @@
 #define GRUB_INSTALL_OPTIONS					  \
   { "modules",      GRUB_INSTALL_OPTIONS_MODULES, N_("MODULES"),	  \
     0, N_("pre-load specified modules MODULES"), 1 },			  \
+  { "dtb",      GRUB_INSTALL_OPTIONS_DTB, N_("FILE"),	  \
+    0, N_("embed a specific DTB"), 1 },			  \
   { "install-modules", GRUB_INSTALL_OPTIONS_INSTALL_MODULES,	  \
     N_("MODULES"), 0,							  \
     N_("install only MODULES and their dependencies [default=all]"), 1 }, \
@@ -99,6 +101,7 @@ enum grub_install_plat
     GRUB_INSTALL_PLATFORM_I386_XEN,
     GRUB_INSTALL_PLATFORM_X86_64_XEN,
     GRUB_INSTALL_PLATFORM_ARM64_EFI,
+    GRUB_INSTALL_PLATFORM_ARM_COREBOOT,
     GRUB_INSTALL_PLATFORM_MAX
   };
 
@@ -115,7 +118,8 @@ enum grub_install_options {
   GRUB_INSTALL_OPTIONS_LOCALE_DIRECTORY,
   GRUB_INSTALL_OPTIONS_THEMES_DIRECTORY,
   GRUB_INSTALL_OPTIONS_GRUB_MKIMAGE,
-  GRUB_INSTALL_OPTIONS_INSTALL_CORE_COMPRESS
+  GRUB_INSTALL_OPTIONS_INSTALL_CORE_COMPRESS,
+  GRUB_INSTALL_OPTIONS_DTB
 };
 
 extern char *grub_install_source_directory;
@@ -176,7 +180,7 @@ grub_install_generate_image (const char *dir, const char *prefix,
 			     char *config_path,
 			     const struct grub_install_image_target_desc *image_target,
 			     int note,
-			     grub_compression_t comp);
+			     grub_compression_t comp, const char *dtb_file);
 
 const struct grub_install_image_target_desc *
 grub_install_get_image_target (const char *arg);
diff --git a/include/grub/util/mkimage.h b/include/grub/util/mkimage.h
index 1a18708a89c6e5503dd29b0b76f5098cef3ac893..b3a5ca132bc4d336f8d85158726bcce77fd7cd37 100644
--- a/include/grub/util/mkimage.h
+++ b/include/grub/util/mkimage.h
@@ -51,13 +51,13 @@ grub_mkimage_load_image64 (const char *kernel_path,
 void
 grub_mkimage_generate_elf32 (const struct grub_install_image_target_desc *image_target,
 			     int note, char **core_img, size_t *core_size,
-			     Elf32_Addr target_addr, grub_size_t align,
-			     size_t kernel_size, size_t bss_size);
+			     Elf32_Addr target_addr,
+			     struct grub_mkimage_layout *layout);
 void
 grub_mkimage_generate_elf64 (const struct grub_install_image_target_desc *image_target,
 			     int note, char **core_img, size_t *core_size,
-			     Elf64_Addr target_addr, grub_size_t align,
-			     size_t kernel_size, size_t bss_size);
+			     Elf64_Addr target_addr,
+			     struct grub_mkimage_layout *layout);
 
 struct grub_install_image_target_desc
 {
diff --git a/grub-core/boot/sparc64/ieee1275/boot.S b/grub-core/boot/sparc64/ieee1275/boot.S
index 586efb4014e8648e560fb43eee8eea8b09da669b..9ea9b4e06627bbd8b7da422ffba3357b4fba0a6a 100644
--- a/grub-core/boot/sparc64/ieee1275/boot.S
+++ b/grub-core/boot/sparc64/ieee1275/boot.S
@@ -69,6 +69,10 @@ prom_seek_name:		.asciz "seek"
 prom_read_name:		.asciz "read"
 prom_exit_name:		.asciz "exit"
 grub_name:		.asciz "GRUB "
+#ifdef CDBOOT
+prom_close_name:	.asciz "close"
+#endif
+
 #define GRUB_NAME_LEN	5
 
 	.align	4
@@ -213,6 +217,12 @@ bootpath_known:
 	call	prom_call_3_1_o1
 #ifdef CDBOOT
 	 LDUW_ABS(kernel_size, 0x00, %o3)
+
+	GET_ABS(prom_close_name, %o0)
+	mov	1, %g1
+	mov	0, %o5
+	call	prom_call
+	 mov	BOOTDEV_REG, %o1
 #else
 	 mov	512, %o3
 #endif
diff --git a/grub-core/kern/arm/cache_armv7.S b/grub-core/kern/arm/cache_armv7.S
index 1ef2754af8a7612c35c26011fab442dbba074dfd..5ae76a3d819c002676f54db3311f517791e0c4e8 100644
--- a/grub-core/kern/arm/cache_armv7.S
+++ b/grub-core/kern/arm/cache_armv7.S
@@ -33,6 +33,18 @@
 # define ISB	isb
 #define ARMV7 1
 
+FUNCTION(grub_arm_clean_dcache_range_poc_armv7)
+	DSB
+	@ Clean data cache for range to point-of-coherence
+1:	cmp	r0, r1
+	bge	2f
+	mcr	p15, 0, r0, c7, c14, 1	@ DCCMVAC
+	add	r0, r0, r2		@ Next line
+	b	1b
+2:	DSB
+	bx	lr
+
+
 	@ r0  - CLIDR
 	@ r1  - LoC
 	@ r2  - current level
diff --git a/grub-core/kern/arm/coreboot/coreboot.S b/grub-core/kern/arm/coreboot/coreboot.S
new file mode 100644
index 0000000000000000000000000000000000000000..a1104526c154bd5a9dfd9e3680d8bb787c1088ef
--- /dev/null
+++ b/grub-core/kern/arm/coreboot/coreboot.S
@@ -0,0 +1,44 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2016  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/symbol.h>
+
+	.file	"coreboot.S"
+	.text
+	.syntax	unified
+#if !defined (__thumb2__)
+	.arch	armv7a
+	.arm
+#else
+	.arch	armv7
+	.thumb
+#endif
+
+FUNCTION(grub_arm_pfr1)
+	mrc p15, 0, r0, c0, c1, 1
+	bx	lr
+
+FUNCTION(grub_armv7_get_timer_value)
+	isb
+	mrrc p15, 1, r0, r1, c14
+	bx	lr
+
+FUNCTION(grub_armv7_get_timer_frequency)
+	mrc p15, 0, r0, c14, c0, 0
+	bx	lr
+
diff --git a/grub-core/kern/arm/uboot/startup.S b/grub-core/kern/arm/startup.S
similarity index 77%
rename from grub-core/kern/arm/uboot/startup.S
rename to grub-core/kern/arm/startup.S
index 5efaae16e838b48dd4d9a5debfc2937a558c65ba..3946fe8e183023f80e3a90ae4ee7b942f02f204d 100644
--- a/grub-core/kern/arm/uboot/startup.S
+++ b/grub-core/kern/arm/startup.S
@@ -24,6 +24,7 @@
  * GRUB is called from U-Boot as a Linux Kernel type image, which
  * means among other things that it always enters in ARM state.
  *
+ * coreboot starts in ARM mode as well.
  *
  * Overview of GRUB image layout:
  *
@@ -86,7 +87,7 @@ FUNCTION(codestart)
 	@ Stack pointer used as start address for signature probing
 	mov	r12, sp
 	adr	sp, entry_state
-	push	{r1-r12,lr}	@ store U-Boot context (sp in r12)
+	push	{r0-r12,lr}	@ store U-Boot context (sp in r12)
 
 	adr     r1, _start
 	ldr	r0, bss_start_ptr		@ src
@@ -127,6 +128,8 @@ reloc_done:
 
 	str     r1, EXT_C(grub_modbase)
 
+	/* Coreboot already places modules at right place.  */
+#ifndef GRUB_MACHINE_COREBOOT
 	add	r1, r1, r2
 	add	r0, r0, r2
 	sub     r1, r1, #4
@@ -136,6 +139,7 @@ reloc_done:
 	str	r3, [r1], #-4			@ *dst-- = r3 
 	subs	r2, #4				@ remaining -= 4
 	bne	1b				@ while remaining != 0
+#endif
 
 	@ Since we _are_ the C run-time, we need to manually zero the BSS
 	@ region before continuing
@@ -153,69 +157,21 @@ reloc_done:
 	
 	b	EXT_C(grub_main)
 
-	/*
-	 * uboot_syscall():
-	 *   This function is effectively a veneer, so it cannot
-	 *   modify the stack or corrupt any registers other than
-	 *   r12 (ip). Furthermore it needs to restore r8 for
-	 *   U-Boot (Global Data Pointer) and preserve it for Grub.
-	 */
-FUNCTION(grub_uboot_syscall)
-	str     r8, transition_space
-	str     lr, transition_space + 4
-	str     r9, transition_space + 8
-
-	ldr	r8, gd_backup
-	ldr	r9, gd_backup + 4
-
-	bl	do_syscall
-
-	ldr     r8, transition_space
-	ldr     lr, transition_space + 4
-	ldr     r9, transition_space + 8
-
-	bx	lr
-do_syscall:
-
-	ldr	ip, grub_uboot_syscall_ptr
-	bx	ip
-	
-FUNCTION(grub_uboot_return)
-	adr	sp, entry_state_end
-	pop	{r4-r12, lr}
-	mov	sp, r12
-	bx	lr
-
-	
 	.align	3
-@ U-boot context stack space
-entry_state_end:
-VARIABLE(grub_uboot_machine_type)
+@ U-boot/coreboot context stack space
+VARIABLE(grub_arm_saved_registers)
+	.long	0	@ r0
 	.long	0	@ r1
-VARIABLE(grub_uboot_boot_data)
 	.long	0	@ r2
 	.long	0	@ r3
 	.long	0	@ r4
 	.long	0	@ r5
 	.long	0	@ r6
 	.long	0	@ r7
-gd_backup:	
-	.long	0	@ r8 - U-Boot global data pointer up to 2013-09-21
-	.long	0	@ r9 - U-Boot global data pointer 2013-09-21 onwards
-	.long	0	@ r10
-	.long	0	@ r11
-VARIABLE(grub_uboot_search_hint)@ U-Boot stack pointer - 
-	.long	0	@ also API signature address hint.
-	.long	0	@ lr
-entry_state:		@ backup for U-Boot context
-
-@ GRUB context stack space
-transition_space:	
 	.long	0	@ r8
-	.long	0	@ lr
 	.long	0	@ r9
-
-VARIABLE(grub_uboot_syscall_ptr)
-	.long	0	@
-
-	END
+	.long	0	@ r10
+	.long	0	@ r11
+	.long	0	@ sp
+	.long	0	@ lr
+entry_state:
diff --git a/grub-core/kern/arm/uboot/uboot.S b/grub-core/kern/arm/uboot/uboot.S
new file mode 100644
index 0000000000000000000000000000000000000000..d128775f19ea1f862b46bc82b05b453be577d741
--- /dev/null
+++ b/grub-core/kern/arm/uboot/uboot.S
@@ -0,0 +1,73 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/offsets.h>
+#include <grub/symbol.h>
+#include <grub/machine/kernel.h>
+
+	/*
+	 * uboot_syscall():
+	 *   This function is effectively a veneer, so it cannot
+	 *   modify the stack or corrupt any registers other than
+	 *   r12 (ip). Furthermore it needs to restore r8 for
+	 *   U-Boot (Global Data Pointer) and preserve it for Grub.
+	 */
+FUNCTION(grub_uboot_syscall)
+	str     r8, transition_space
+	str     lr, transition_space + 4
+	str     r9, transition_space + 8
+
+	ldr	ip, saved_registers_ptr
+	ldr	r8, [ip, #4 * 8]
+	ldr	r9, [ip, #4 * 9]
+
+	bl	do_syscall
+
+	ldr     r8, transition_space
+	ldr     lr, transition_space + 4
+	ldr     r9, transition_space + 8
+
+	bx	lr
+do_syscall:
+
+	ldr	ip, grub_uboot_syscall_ptr
+	bx	ip
+	
+FUNCTION(grub_uboot_return)
+	ldr	ip, saved_registers_ptr
+	ldr	sp, [ip, #4 * 4]
+	pop	{r4-r12, lr}
+	mov	sp, r12
+	bx	lr
+
+	
+	.align	3
+
+@ GRUB context stack space
+transition_space:	
+	.long	0	@ r8
+	.long	0	@ lr
+	.long	0	@ r9
+
+saved_registers_ptr:
+	.long EXT_C(grub_arm_saved_registers)
+
+VARIABLE(grub_uboot_syscall_ptr)
+	.long	0	@
+
+	END
diff --git a/conf/Makefile.common b/conf/Makefile.common
index 11296b550a7cd40ded498613620f556d78c67d84..311da61c6c59fed3de8cba06c2c581b217d8273f 100644
--- a/conf/Makefile.common
+++ b/conf/Makefile.common
@@ -86,9 +86,11 @@ CPPFLAGS_TERMINAL_LIST += '-Dgrub_term_register_output(...)=OUTPUT_TERMINAL_LIST
 CPPFLAGS_COMMAND_LIST = '-Dgrub_register_command(...)=COMMAND_LIST_MARKER(__VA_ARGS__)'
 CPPFLAGS_COMMAND_LIST += '-Dgrub_register_extcmd(...)=EXTCOMMAND_LIST_MARKER(__VA_ARGS__)'
 CPPFLAGS_COMMAND_LIST += '-Dgrub_register_command_p1(...)=P1COMMAND_LIST_MARKER(__VA_ARGS__)'
+CPPFLAGS_FDT_LIST := '-Dgrub_fdtbus_register(...)=FDT_DRIVER_LIST_MARKER(__VA_ARGS__)'
 CPPFLAGS_MARKER = $(CPPFLAGS_FS_LIST) $(CPPFLAGS_VIDEO_LIST) \
 	$(CPPFLAGS_PARTTOOL_LIST) $(CPPFLAGS_PARTMAP_LIST) \
-	$(CPPFLAGS_TERMINAL_LIST) $(CPPFLAGS_COMMAND_LIST)
+	$(CPPFLAGS_TERMINAL_LIST) $(CPPFLAGS_COMMAND_LIST) \
+	$(CPPFLAGS_FDT_LIST)
 
 # Define these variables to calm down automake
 
diff --git a/docs/grub.texi b/docs/grub.texi
index e935af33ea5e24d832e588d1345e3721b826d5a0..a0c4b9e4e8e861fd786fa911d8d9005a7678182b 100644
--- a/docs/grub.texi
+++ b/docs/grub.texi
@@ -3873,11 +3873,9 @@ you forget a command, you can run the command @command{help}
 @comment * vbeinfo::                     List available video modes
 * verify_detached::             Verify detached digital signature
 * videoinfo::                   List available video modes
-@comment * xen_*::              Xen boot commands
-* xen_hypervisor::              Load xen hypervisor binary
-* xen_linux::                   Load dom0 kernel for xen hypervisor
-* xen_initrd::                  Load dom0 initrd for dom0 kernel
-* xen_xsm::                     Load xen security module for xen hypervisor
+@comment * xen_*::              Xen boot commands for AArch64
+* xen_hypervisor::              Load xen hypervisor binary (only on AArch64)
+* xen_module::                  Load xen modules for xen hypervisor (only on AArch64)
 @end menu
 
 
@@ -5153,32 +5151,22 @@ List available video modes. If resolution is given, show only matching modes.
 Load a Xen hypervisor binary from @var{file}. The rest of the line is passed
 verbatim as the @dfn{kernel command-line}. Any other binaries must be
 reloaded after using this command.
+This command is only available on AArch64 systems.
 @end deffn
 
-@node xen_linux
-@subsection xen_linux
+@node xen_module
+@subsection xen_module
 
-@deffn Command xen_linux file [arguments]
-Load a dom0 kernel image for xen hypervisor at the booting process of xen.
+@deffn Command xen_module [--nounzip] file [arguments]
+Load a module for xen hypervisor at the booting process of xen.
 The rest of the line is passed verbatim as the module command line.
+Modules should be loaded in the following order:
+ - dom0 kernel image
+ - dom0 ramdisk if present
+ - XSM policy if present
+This command is only available on AArch64 systems.
 @end deffn
 
-@node xen_initrd
-@subsection xen_initrd
-
-@deffn Command xen_initrd file
-Load a initrd image for dom0 kernel at the booting process of xen.
-@end deffn
-
-@node xen_xsm
-@subsection xen_xsm
-
-@deffn Command xen_xsm file
-Load a xen security module for xen hypervisor at the booting process of xen.
-See @uref{http://wiki.xen.org/wiki/XSM} for more detail.
-@end deffn
-
-
 @node Networking commands
 @section The list of networking commands
 
diff --git a/gentpl.py b/gentpl.py
index f08bcc404f6a8bd8c3b13a6d5bb041ee32422776..da67965a41a40cde7c987b719fea39cd02ba10e5 100644
--- a/gentpl.py
+++ b/gentpl.py
@@ -31,7 +31,8 @@ GRUB_PLATFORMS = [ "emu", "i386_pc", "i386_efi", "i386_qemu", "i386_coreboot",
                    "i386_xen", "x86_64_xen",
                    "mips_loongson", "sparc64_ieee1275",
                    "powerpc_ieee1275", "mips_arc", "ia64_efi",
-                   "mips_qemu_mips", "arm_uboot", "arm_efi", "arm64_efi" ]
+                   "mips_qemu_mips", "arm_uboot", "arm_efi", "arm64_efi",
+                   "arm_coreboot"]
 
 GROUPS = {}
 
@@ -44,7 +45,7 @@ GROUPS["x86"]      = GROUPS["i386"] + GROUPS["x86_64"]
 GROUPS["mips"]     = [ "mips_loongson", "mips_qemu_mips", "mips_arc" ]
 GROUPS["sparc64"]  = [ "sparc64_ieee1275" ]
 GROUPS["powerpc"]  = [ "powerpc_ieee1275" ]
-GROUPS["arm"]      = [ "arm_uboot", "arm_efi" ]
+GROUPS["arm"]      = [ "arm_uboot", "arm_efi", "arm_coreboot" ]
 GROUPS["arm64"]    = [ "arm64_efi" ]
 
 # Groups based on firmware
@@ -52,6 +53,7 @@ GROUPS["efi"]  = [ "i386_efi", "x86_64_efi", "ia64_efi", "arm_efi", "arm64_efi"
 GROUPS["ieee1275"]   = [ "i386_ieee1275", "sparc64_ieee1275", "powerpc_ieee1275" ]
 GROUPS["uboot"] = [ "arm_uboot" ]
 GROUPS["xen"]  = [ "i386_xen", "x86_64_xen" ]
+GROUPS["coreboot"]  = [ "i386_coreboot", "arm_coreboot" ]
 
 # emu is a special case so many core functionality isn't needed on this platform
 GROUPS["noemu"]   = GRUB_PLATFORMS[:]; GROUPS["noemu"].remove("emu")
@@ -61,10 +63,10 @@ GROUPS["cmos"] = GROUPS["x86"][:] + ["mips_loongson", "mips_qemu_mips",
                                      "sparc64_ieee1275", "powerpc_ieee1275"]
 GROUPS["cmos"].remove("i386_efi"); GROUPS["cmos"].remove("x86_64_efi");
 GROUPS["pci"]      = GROUPS["x86"] + ["mips_loongson"]
-GROUPS["usb"]      = GROUPS["pci"]
+GROUPS["usb"]      = GROUPS["pci"] + ["arm_coreboot"]
 
 # If gfxterm is main output console integrate it into kernel
-GROUPS["videoinkernel"] = ["mips_loongson", "i386_coreboot" ]
+GROUPS["videoinkernel"] = ["mips_loongson", "i386_coreboot", "arm_coreboot" ]
 GROUPS["videomodules"]   = GRUB_PLATFORMS[:];
 for i in GROUPS["videoinkernel"]: GROUPS["videomodules"].remove(i)
 
diff --git a/grub-core/Makefile.am b/grub-core/Makefile.am
index 04e9395fd949460672c1113c3d49c90a5d4471ec..10451384720474e8dc071a6843eda0fafa455724 100644
--- a/grub-core/Makefile.am
+++ b/grub-core/Makefile.am
@@ -112,7 +112,7 @@ endif
 
 if COND_i386_coreboot
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/i386/tsc.h
-KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/i386/coreboot/lbio.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/coreboot/lbio.h
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/video.h
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/video_fb.h
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/gfxterm.h
@@ -239,6 +239,20 @@ KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/lib/arg.h
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/arm/system.h
 endif
 
+if COND_arm_coreboot
+KERNEL_HEADER_FILES += $(top_builddir)/include/grub/keyboard_layouts.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/arm/system.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/video.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/video_fb.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/gfxterm.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/font.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/bufio.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/fdt.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/dma.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/arm/coreboot/kernel.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/fdtbus.h
+endif
+
 if COND_arm_efi
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/arm/efi/loader.h
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/efi/efi.h
@@ -278,7 +292,7 @@ BUILT_SOURCES += symlist.h
 
 symlist.c: symlist.h gensymlist.sh
 	$(TARGET_CPP) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS_KERNEL) $(CPPFLAGS) -DGRUB_SYMBOL_GENERATOR=1 symlist.h > symlist.p || (rm -f symlist.p; exit 1)
-	cat symlist.p | /bin/sh $(srcdir)/gensymlist.sh $(top_builddir)/config.h $(KERNEL_HEADER_FILES) >$@ || (rm -f $@; exit 1)
+	cat symlist.p | $(SHELL) $(srcdir)/gensymlist.sh $(top_builddir)/config.h $(KERNEL_HEADER_FILES) >$@ || (rm -f $@; exit 1)
 	rm -f symlist.p
 CLEANFILES += symlist.c
 BUILT_SOURCES += symlist.c
@@ -358,6 +372,16 @@ terminal.lst: $(MARKER_FILES)
 platform_DATA += terminal.lst
 CLEANFILES += terminal.lst
 
+fdt.lst: $(MARKER_FILES)
+	(for pp in $^; do \
+	  b=`basename $$pp .marker`; \
+	  sed -n \
+	    -e "/FDT_DRIVER_LIST_MARKER *( *\"/{s/.*( *\"\([^\"]*\)\".*/i\1: $$b/;p;}" \
+	    -e "/FDT_DRIVER_LIST_MARKER *( *\"/{s/.*( *\"\([^\"]*\)\".*/o\1: $$b/;p;}" $$pp; \
+	done) | sort -u > $@
+platform_DATA += fdt.lst
+CLEANFILES += fdt.lst
+
 parttool.lst: $(MARKER_FILES)
 	(for pp in $^; do \
 	  b=`basename $$pp .marker`; \
diff --git a/grub-core/genmod.sh.in b/grub-core/genmod.sh.in
index 03cc3b7f69ed3cfb69b744f8114895fd0e14fde7..3de06ee018f83e04069566f9de1365bdbc01e377 100644
--- a/grub-core/genmod.sh.in
+++ b/grub-core/genmod.sh.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 set -e
 
 # Copyright (C) 2010 Free Software Foundation, Inc.
diff --git a/grub-core/gensyminfo.sh.in b/grub-core/gensyminfo.sh.in
index 2e8716b425cb04d9379ef5e2c629283d0f346c90..9bc7675327a6d9229492548671dd004054282434 100644
--- a/grub-core/gensyminfo.sh.in
+++ b/grub-core/gensyminfo.sh.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 set -e
 
 # Copyright (C) 2010 Free Software Foundation, Inc.
diff --git a/grub-core/modinfo.sh.in b/grub-core/modinfo.sh.in
index faf0ad30edbe878270a185add45aa70e245d8b3a..f6cd657ce0f8307547fc5d011efa35622c318e63 100644
--- a/grub-core/modinfo.sh.in
+++ b/grub-core/modinfo.sh.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 # User-controllable options
 grub_modinfo_target_cpu=@target_cpu@
diff --git a/po/Makefile.in.in b/po/Makefile.in.in
index 3619458e85f2bed3f92a76a9d919c26a30116dee..e68e9da843d927bfb6bbd519f4b3923c733abd7c 100644
--- a/po/Makefile.in.in
+++ b/po/Makefile.in.in
@@ -15,7 +15,7 @@ PACKAGE = @PACKAGE@
 VERSION = @VERSION@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 
-SHELL = /bin/sh
+SHELL = @SHELL@
 @SET_MAKE@
 
 srcdir = @srcdir@
diff --git a/tests/ahci_test.in b/tests/ahci_test.in
index 1d01d1f59a0aac8911ff7ca3e62565f2dee5954d..7df56046201e4c2e4a55bdcdd403853cde902268 100644
--- a/tests/ahci_test.in
+++ b/tests/ahci_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/btrfs_test.in b/tests/btrfs_test.in
index c55d9477f78e01b6556bc0da9695f038523936f4..2b37ddd3324cc77f1edeb03feb369c22d03204a2 100644
--- a/tests/btrfs_test.in
+++ b/tests/btrfs_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/cdboot_test.in b/tests/cdboot_test.in
index 1cc901977c229dcf839bf58bede2b34f04252d57..75acdfedb7fe4a634d4122e44b3cd01778ed6f35 100644
--- a/tests/cdboot_test.in
+++ b/tests/cdboot_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/core_compress_test.in b/tests/core_compress_test.in
index 1003587ccca65616b0c7e3c1b90353ef7f459299..9d216ebcff60bfce04e3be4dbd1f8834800a6948 100644
--- a/tests/core_compress_test.in
+++ b/tests/core_compress_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/cpio_test.in b/tests/cpio_test.in
index 0b09db549f07868a524376f0eb25fd6a2cac9e40..5742cf17b9d8f587d00590d481f0a00aaf6cada8 100644
--- a/tests/cpio_test.in
+++ b/tests/cpio_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/ehci_test.in b/tests/ehci_test.in
index 7dd8d3e8fbd4a76b8efb88d69ecd8989546dc543..b197f8cdc922628ed35863dfa384eeef4cc4cc09 100644
--- a/tests/ehci_test.in
+++ b/tests/ehci_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/example_scripted_test.in b/tests/example_scripted_test.in
index 09633e89341e079a05fda7461d867e1541df4287..783b7f13853f39f9ec63b8da1da6e8a1b3a887a5 100644
--- a/tests/example_scripted_test.in
+++ b/tests/example_scripted_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 set -e
 
 true
diff --git a/tests/exfat_test.in b/tests/exfat_test.in
index fc1a0fe5ec0306434434f0b49b20c44a1736dca1..cd3cd4cb2f70bb99df7edbfa8b5697f4316548ac 100644
--- a/tests/exfat_test.in
+++ b/tests/exfat_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/ext234_test.in b/tests/ext234_test.in
index c986960a8bec696deb37a55cba00915219d77215..4f1eb527eb2ed41095266dba6d5013ead77d9be3 100644
--- a/tests/ext234_test.in
+++ b/tests/ext234_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
@@ -30,3 +30,4 @@ fi
 "@builddir@/grub-fs-tester" ext3
 "@builddir@/grub-fs-tester" ext4
 "@builddir@/grub-fs-tester" ext4_metabg
+"@builddir@/grub-fs-tester" ext4_encrypt
diff --git a/tests/fat_test.in b/tests/fat_test.in
index 1d132b51703c43e269d5500ca1740fa1e6b9a42c..b6b4748ca694b59337441a2f3111863e01799884 100644
--- a/tests/fat_test.in
+++ b/tests/fat_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/fddboot_test.in b/tests/fddboot_test.in
index a59645b7f873872490ac2474a30420c2df7a5caf..2d7dfc8891f6d7fdf42f88dea1213428e23b6f2e 100644
--- a/tests/fddboot_test.in
+++ b/tests/fddboot_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/file_filter_test.in b/tests/file_filter_test.in
index 8909e4021fb1d507cd5bf3b63319824fdc005dd5..bfb6382274e48d409d6cf6f918fc252f993f717f 100644
--- a/tests/file_filter_test.in
+++ b/tests/file_filter_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2014  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/gettext_strings_test.in b/tests/gettext_strings_test.in
index 5c305e75b7e9583f6be8a23d389051cf1fe2c243..813999ebe6ea5ee35796669e58baa57d0a2ace95 100644
--- a/tests/gettext_strings_test.in
+++ b/tests/gettext_strings_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 cd '@srcdir@'
 
diff --git a/tests/grub_cmd_date.in b/tests/grub_cmd_date.in
index a459353e8a51c22fb966a842af532cff904de2a3..f7c9ca00432fa3307a2fb53ac88ca11115d7f73f 100644
--- a/tests/grub_cmd_date.in
+++ b/tests/grub_cmd_date.in
@@ -1,4 +1,4 @@
-#! /bin/bash
+#! @BUILD_SHEBANG@
 set -e
 
 . "@builddir@/grub-core/modinfo.sh"
@@ -9,7 +9,7 @@ if [ "${grub_modinfo_target_cpu}-${grub_modinfo_platform}" = sparc64-ieee1275 ];
 fi
 
 pdt="$(date -u +%s)"
-dt=`echo date | @builddir@/grub-shell`
+dt=`echo date | @builddir@/grub-shell | sed 's, [A-Z][a-z]*$,,'`
 dtg="$(date -u -d "$dt" +%s)"
 ndt="$(date -u +%s)"
 
diff --git a/tests/grub_cmd_regexp.in b/tests/grub_cmd_regexp.in
index e7e6257011525ee42ca6945485208155fe717d24..6520bd6d79acc0c8f5bfddc443912d74e826a0c8 100644
--- a/tests/grub_cmd_regexp.in
+++ b/tests/grub_cmd_regexp.in
@@ -1,4 +1,4 @@
-#! /bin/bash
+#! @BUILD_SHEBANG@
 set -e
 
 # Run GRUB script in a Qemu instance
diff --git a/tests/grub_cmd_set_date.in b/tests/grub_cmd_set_date.in
index c594ae3fc14ebf7a6be86b90f4d048747383a69f..aac120a6c52731649678549d34372af14fef52d9 100644
--- a/tests/grub_cmd_set_date.in
+++ b/tests/grub_cmd_set_date.in
@@ -1,4 +1,4 @@
-#! /bin/bash
+#! @BUILD_SHEBANG@
 set -e
 
 . "@builddir@/grub-core/modinfo.sh"
diff --git a/tests/grub_cmd_sleep.in b/tests/grub_cmd_sleep.in
index eb362aa2439d713bf4246e2c56932bbc6200d710..8797f6632845f5a76ac22b813c223897ceddd672 100644
--- a/tests/grub_cmd_sleep.in
+++ b/tests/grub_cmd_sleep.in
@@ -1,4 +1,4 @@
-#! /bin/bash
+#! @BUILD_SHEBANG@
 set -e
 
 . "@builddir@/grub-core/modinfo.sh"
@@ -11,8 +11,8 @@ fi
 # Compare RTC with interval timer.
 # Not 100% proper but should check that timer is running ok
 dt=`echo 'date; sleep 10; date' | @builddir@/grub-shell`
-dt1="$(date -u -d "$(echo "$dt" | head -n 1)" +%s)"
-dt2="$(date -u -d "$(echo "$dt" | tail -n 1)" +%s)"
+dt1="$(date -u -d "$(echo "$dt" | head -n 1 | sed 's, [A-Z][a-z]*$,,')" +%s)"
+dt2="$(date -u -d "$(echo "$dt" | tail -n 1 | sed 's, [A-Z][a-z]*$,,')" +%s)"
 
 # Ignore QEMU bug
 if [ "${grub_modinfo_target_cpu}" = arm ] && [ $((dt2 - dt1)) -ge 15 ] && [ $((dt2 - dt1)) -le 17 ]; then
diff --git a/tests/grub_cmd_test.in b/tests/grub_cmd_test.in
index 6269891c9eeddb70f42da372e5636089e666818d..3399eb2929408570e9dad99db8dbc7215b41aea4 100644
--- a/tests/grub_cmd_test.in
+++ b/tests/grub_cmd_test.in
@@ -1,4 +1,4 @@
-#! /bin/bash
+#! @BUILD_SHEBANG@
 
 # create a randome file
 empty="`mktemp "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX"`" || exit 1
diff --git a/tests/grub_cmd_tr.in b/tests/grub_cmd_tr.in
index 3fb15e35c8ac3ac218abf580f8ff5cdcaa2925ca..bed469c03ddc9a762112896d75af399678af711e 100644
--- a/tests/grub_cmd_tr.in
+++ b/tests/grub_cmd_tr.in
@@ -1,4 +1,4 @@
-#! /bin/bash -e
+#! @BUILD_SHEBANG@ -e
 
 # Run GRUB script in a Qemu instance
 # Copyright (C) 2010  Free Software Foundation, Inc.
diff --git a/tests/grub_func_test.in b/tests/grub_func_test.in
index c8cc263763377fd23d6c7f1eca49c1edafe530a7..c67f9e422534a402614eb280fe67d165fd0bb906 100644
--- a/tests/grub_func_test.in
+++ b/tests/grub_func_test.in
@@ -1,4 +1,4 @@
-#! /bin/bash
+#! @BUILD_SHEBANG@
 set -e
 
 . "@builddir@/grub-core/modinfo.sh"
diff --git a/tests/grub_script_blanklines.in b/tests/grub_script_blanklines.in
index 89ed763d3f4e0bb2a3ac3a61de9e0ec49b2eaccf..bd8735491be3b947c72fffbf5767d7ab6bcf91ae 100644
--- a/tests/grub_script_blanklines.in
+++ b/tests/grub_script_blanklines.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 set -e
 
 @builddir@/grub-script-check <<EOF
diff --git a/tests/grub_script_blockarg.in b/tests/grub_script_blockarg.in
index 2765b61acbb8c1081f620960e0350c5489dc2875..6ea9b8c3d87cb2e9fc5693da93cb9885cfdd20e2 100644
--- a/tests/grub_script_blockarg.in
+++ b/tests/grub_script_blockarg.in
@@ -1,4 +1,4 @@
-#! /bin/bash
+#! @BUILD_SHEBANG@
 
 # Run GRUB script in a Qemu instance
 # Copyright (C) 2010  Free Software Foundation, Inc.
diff --git a/tests/grub_script_dollar.in b/tests/grub_script_dollar.in
index 2e076427afbc86e05260b58e9f22f7e3fe48ce4e..392fe2e7ab0f773ef3ba04366386d799cda3f83c 100644
--- a/tests/grub_script_dollar.in
+++ b/tests/grub_script_dollar.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 set -e
 
 @builddir@/grub-script-check << EOF
diff --git a/tests/grub_script_expansion.in b/tests/grub_script_expansion.in
index e46401c4c9f1b6bea3c7bed452882d373e51bd61..9d0dcdd29100904bfba93ccd429340d4a5afbcf3 100644
--- a/tests/grub_script_expansion.in
+++ b/tests/grub_script_expansion.in
@@ -1,4 +1,4 @@
-#! /bin/bash
+#! @BUILD_SHEBANG@
 set -e
 
 # Run GRUB script in a Qemu instance
diff --git a/tests/grub_script_final_semicolon.in b/tests/grub_script_final_semicolon.in
index 3ac26540bbd7cf4614dc199534417b139c2bb7f0..f17a9bf95e6db3d710d683fdbdc749fdab7e3a0a 100644
--- a/tests/grub_script_final_semicolon.in
+++ b/tests/grub_script_final_semicolon.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 set -e
 
 @builddir@/grub-script-check <<EOF
diff --git a/tests/grub_script_no_commands.in b/tests/grub_script_no_commands.in
index c31d267e5fdf090fda15878cbe0b794b2f4e8b9f..996bb181043dcbddd95ab98c8cbcc57b0fe91f4d 100644
--- a/tests/grub_script_no_commands.in
+++ b/tests/grub_script_no_commands.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 set -e
 
 # grub-script-check refuses to pass a file with no commands; this usually
diff --git a/tests/gzcompress_test.in b/tests/gzcompress_test.in
index 11b6bb208302e03e0c5198f678bc7cc119862898..42c8fe7c4e8fc83022f656c0be7963aab3166a75 100644
--- a/tests/gzcompress_test.in
+++ b/tests/gzcompress_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/hddboot_test.in b/tests/hddboot_test.in
index c229716a642942d1eba6cc9d00867c0292c8e7a4..6d70847a5dec394fec13e6b21a9dd0d890cf2a4d 100644
--- a/tests/hddboot_test.in
+++ b/tests/hddboot_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/help_test.in b/tests/help_test.in
index e780924ef7b02245b6009956bd2baab3623aa5a8..b08cf201382e043e6b2fc07fd6f7a410aa051dca 100644
--- a/tests/help_test.in
+++ b/tests/help_test.in
@@ -1,4 +1,4 @@
-#! /bin/bash
+#! @BUILD_SHEBANG@
 set -e
 
 . "@builddir@/grub-core/modinfo.sh"
diff --git a/tests/hfs_test.in b/tests/hfs_test.in
index e3e88f190677d24699def63ba666df3b2748b045..d7ec56beffa7909c28636a4af5142a2c8ee334de 100644
--- a/tests/hfs_test.in
+++ b/tests/hfs_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/hfsplus_test.in b/tests/hfsplus_test.in
index f947c4a447fe1a310761a3606257c793b9e2358a..85f1c37dce6a0c5a217d75b051b1ab426d06a2be 100644
--- a/tests/hfsplus_test.in
+++ b/tests/hfsplus_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/iso9660_test.in b/tests/iso9660_test.in
index fdcc9e124208dd3b8d5a997c8522ffb52bc3ced1..571b938d7a08b14ca21dd6497bd0092f3d6d40cb 100644
--- a/tests/iso9660_test.in
+++ b/tests/iso9660_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/jfs_test.in b/tests/jfs_test.in
index c2e5eceddcd2cb433dcdc120fe44dc9d8bd2b45e..6cf7576b35ed8ce4b86036ed67df02b698fbc062 100644
--- a/tests/jfs_test.in
+++ b/tests/jfs_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/lzocompress_test.in b/tests/lzocompress_test.in
index 41984c25419b78c727b3b8957bde3ac611cbd76e..4e5f7e078d5116f0794b035cabe1002420fb1d2c 100644
--- a/tests/lzocompress_test.in
+++ b/tests/lzocompress_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/minixfs_test.in b/tests/minixfs_test.in
index 1784b1261f7592a78820dbd9f1900f89df133f9b..3b16a4de09314b95eb45ee21fe9441789b429e51 100644
--- a/tests/minixfs_test.in
+++ b/tests/minixfs_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/netboot_test.in b/tests/netboot_test.in
index c757023d989e89a9400dbbc79e674edd5bea9fd6..9f71e3d88542ae9b87e9218c1c1197aeef29989a 100644
--- a/tests/netboot_test.in
+++ b/tests/netboot_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/nilfs2_test.in b/tests/nilfs2_test.in
index 780b60ec1ac980ea1e40af3a319c83a86a6415e6..ad44d5b33c8af3ab9f62b7c8ca866c025a51d24a 100644
--- a/tests/nilfs2_test.in
+++ b/tests/nilfs2_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/ntfs_test.in b/tests/ntfs_test.in
index e25c6384a9cd6e086961116c83db4a31353d6e7c..9eb7b01f66e923009939abf7b839276a15fa67a3 100644
--- a/tests/ntfs_test.in
+++ b/tests/ntfs_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/ohci_test.in b/tests/ohci_test.in
index 7fede6f262c1fdac41609dc660017e279a06f3a1..8693f8c472879fcbd43f52d4e61973d19b52ddc1 100644
--- a/tests/ohci_test.in
+++ b/tests/ohci_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/partmap_test.in b/tests/partmap_test.in
index f8dc456fb8c6c25d034c53821066ad618664afa0..6ef518b0adc1e001bfc64c853ffb5c490d02330d 100644
--- a/tests/partmap_test.in
+++ b/tests/partmap_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 set -e
 
 # Copyright (C) 2010  Free Software Foundation, Inc.
diff --git a/tests/pata_test.in b/tests/pata_test.in
index c1d0f63ea21b5cdc6d818a1aabbd691a2e7a2fa5..4b18fdef3d3594ccb105dd0d265e8517890d9853 100644
--- a/tests/pata_test.in
+++ b/tests/pata_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/pseries_test.in b/tests/pseries_test.in
index 226494593d1514112f33eee695c3c418421198c1..655eb4f3a63a210ffd1271ac16da47bcbad70434 100644
--- a/tests/pseries_test.in
+++ b/tests/pseries_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/reiserfs_test.in b/tests/reiserfs_test.in
index 678efe7b36662dfb1325b969e7451ccb5024c3dc..b5fed7635673467d5c46409625463e50498b9807 100644
--- a/tests/reiserfs_test.in
+++ b/tests/reiserfs_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/romfs_test.in b/tests/romfs_test.in
index 83e09315acf62eb00c54faa95e785b114b08017a..98bb50c324b6e8cd1163c772a78271b64768ae57 100644
--- a/tests/romfs_test.in
+++ b/tests/romfs_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/squashfs_test.in b/tests/squashfs_test.in
index ec34e0108c3bfb663e1a8959fb4cd3bb736bff76..2f044f95d99b2ee7a6ddf1d2b2e54be3944f235f 100644
--- a/tests/squashfs_test.in
+++ b/tests/squashfs_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/syslinux_test.in b/tests/syslinux_test.in
index fc4edd8ef6b91f7d0759c85c7a657402248fd120..4ea86390e0a320ed9afdf77ecc42e4d328e17e28 100644
--- a/tests/syslinux_test.in
+++ b/tests/syslinux_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/tar_test.in b/tests/tar_test.in
index 46ba3bce295b256631eaa8ab12c581f2bdafb7f6..6e2f2de8b7ff78ca84401213dadd011a0b65f281 100644
--- a/tests/tar_test.in
+++ b/tests/tar_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/test_sha512sum.in b/tests/test_sha512sum.in
index d5ef7f9ea62d1c9749c6a134580dace95fa7624a..027092a8b17f398776e605251fcd8d48b7b4965e 100644
--- a/tests/test_sha512sum.in
+++ b/tests/test_sha512sum.in
@@ -1,4 +1,4 @@
-#! /bin/bash
+#! @BUILD_SHEBANG@
 
 # create a randome file
 file="`mktemp "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX"`" || exit 1
diff --git a/tests/udf_test.in b/tests/udf_test.in
index fe244e2bdfc8b7d17ec25ac80d12724dcdbb1cba..fb92f0173cc74151d7fdc722522d654efa2233b5 100644
--- a/tests/udf_test.in
+++ b/tests/udf_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/uhci_test.in b/tests/uhci_test.in
index 89e2c18051ac00f414edd0e80bdcfd911c8f9842..4af72fd8fea5ab2b3e2059d2a89f0b0dfaa74c9a 100644
--- a/tests/uhci_test.in
+++ b/tests/uhci_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/util/grub-fs-tester.in b/tests/util/grub-fs-tester.in
index 2337771a1b9ce287c3e5e24e49c7c27baee7edb8..fd7e0f14b68ebe1a555ddd9acc70cdee77731f21 100644
--- a/tests/util/grub-fs-tester.in
+++ b/tests/util/grub-fs-tester.in
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!@BUILD_SHEBANG@
 
 set -e
 
@@ -13,8 +13,29 @@ run_it () {
     LC_ALL=C "$GRUBFSTEST" "$@"
 }
 
+range() {
+    range_counter="$1"
+    while test "$range_counter" -le "$2"; do
+	echo "$range_counter"
+	range_counter="$((range_counter + $3))"
+    done
+}
+
+powrange() {
+    range_counter="$1"
+    while test "$range_counter" -le "$2"; do
+	echo "$range_counter"
+	range_counter="$((range_counter * 2))"
+    done
+}
+
 run_grubfstest () {
-    run_it -c $NEED_IMAGES_N "${NEED_IMAGES[@]}"  "$@"
+    need_images=
+    for i in $(range 0 $((NEED_IMAGES_N-1)) 1); do
+	need_images="$need_images $FSIMAGEP${i}.img";
+    done
+
+    run_it -c $NEED_IMAGES_N $need_images  "$@"
 }
 
 # OS LIMITATION: GNU/Linux has no AFS support, so we use a premade image and a reference tar file. I.a. no multiblocksize test
@@ -51,7 +72,7 @@ case x"$fs" in
 	# OS limitation: zfs-fuse always uses ashift=9 with loop devices
 	MAXLOGSECSIZE=9;;
 esac
-for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE + 1)); do
+for LOGSECSIZE in $(range "$MINLOGSECSIZE" "$MAXLOGSECSIZE" 1); do
     SECSIZE="$((1 << LOGSECSIZE))"
     MINBLKSIZE=512
     MAXBLKSIZE=512
@@ -135,6 +156,12 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		# Could go further but what's the point?
 	    MAXBLKSIZE=$((65536*1024))
 	    ;;
+       xext4_encrypt)
+           # OS LIMITATION: Linux currently only allows the 'encrypt' feature
+           # in combination with block_size = PAGE_SIZE (4096 bytes on x86).
+           MINBLKSIZE=$(getconf PAGE_SIZE)
+           MAXBLKSIZE=$MINBLKSIZE
+           ;;
 	xext*)
 	    MINBLKSIZE=1024
 	    if [ $MINBLKSIZE -lt $SECSIZE ]; then
@@ -169,7 +196,12 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    MINBLKSIZE=1024
 	    MAXBLKSIZE=4096;;
     esac
-    for ((BLKSIZE=MINBLKSIZE;BLKSIZE<=MAXBLKSIZE;BLKSIZE=BLKSTEP?BLKSIZE+BLKSTEP:2*BLKSIZE)); do
+    if test "$BLKSTEP" -eq 0; then
+	blksizes="$(powrange "$MINBLKSIZE" "$MAXBLKSIZE")"
+    else
+	blksizes="$(range "$MINBLKSIZE" "$MAXBLKSIZE" "$BLKSTEP")"
+    fi
+    for BLKSIZE in $blksizes; do
 	MAXDEVICES=1
 	MINDEVICES=1
 	export fs
@@ -199,13 +231,11 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		MAXDEVICES=7;;
 	esac
 
-	for ((NDEVICES=MINDEVICES; NDEVICES <= MAXDEVICES; NDEVICES++)); do
+	for NDEVICES in $(range "$MINDEVICES" "$MAXDEVICES" 1); do
 	    export NDEVICES
-	    unset FSIMAGES
-	    for ((i=0; i < NDEVICES; i++)); do
-		FSIMAGES[i]="${tempdir}/${fs}_${SECSIZE}_${BLKSIZE}_${NDEVICES}_$i.img"
-	    done
-	    export FSIMAGES
+	    unset FSIMAGEP
+	    FSIMAGEP="${tempdir}/${fs}_${SECSIZE}_${BLKSIZE}_${NDEVICES}_"
+	    export FSIMAGEP
 	    unset NEED_IMAGES;
 
 	    case x$fs in
@@ -226,11 +256,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		*)
 		    NEED_IMAGES_N=$NDEVICES;;
 	    esac
-	    for ((i=0;i < NEED_IMAGES_N; i++)); do
-		NEED_IMAGES[i]="${FSIMAGES[i]}";
-	    done
 	    export NEED_IMAGES_N
-	    export NEED_IMAGES
 
 	    MNTPOINTRO="${tempdir}/${fs}_ro"
 	    MNTPOINTRW="${tempdir}/${fs}_rw"
@@ -238,20 +264,25 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    MOUNTFS="$fs"
 	    MASTER="${tempdir}/master"
 	    FSLABEL="grub_;/testi urewfceniuewruevrewnuuireurevueurnievrewfnerfcnevirivinrewvnirewnivrewiuvcrewvnuewvrrrewniuerwreiuviurewiuviurewnuvewnvrenurnunuvrevuurerejiremvreijnvcreivire nverivnreivrevnureiorfnfrvoeoiroireoireoifrefoieroifoireoifoirefoireoifoijfoirereoireoivoioirevoinvoinreoinvnoieoinreoinveoinveoinreoinvoineoinoinoineoinernoiveoinvreoiioewdioewoirvnoireoivfoirewfewoifoijewoijfoijewfoijfewoijoijoijoijoijoijoijfewceniuewruevrewnuuireurevueurnievrewfnerfcnevirivinrewvnirewnivrewiuvcrewvnuewvrrrewniuerwreiuviurewiuviurewnuvewnvrenurnunuvrevuurerejiremvreijnvcreivire nverivnreivrevnureiorfnfrvoeoiroireoireoifrefoieroifoireoifoirefoireoifoijfoirereoireoivoioirevoinvoinreoinvnoieoinreoinveoinveoinreoinvoineoinoinoineoinernoiveoinvreoiioewdioewoirvnoireoivfoirewfewoifoijewoijfoijewfoijfewoijoijoijoijoijoijoijfewrewfceniuewruevrewnuuireurevueurnievrewfnerfcnevirivinrewvnirewnivrewiuvcrewvnuewvrrrewniuerwreiuviurewiuviurewnuvewnvrenurnunuvrevuurerejiremvreijnvcreivire nverivnreivrevnureiorfnfrvoeoiroireoireoifrefoieroifoireoifoirefoireoifoijfoirereoireoivoioirevoinvoinreoinvnoieoinreoinveoinveoinreoinvoineoinoinoineoinernoiveoinvreoiioewdioewoirvnoireoivfoirewfewoifoijewoijfoijewfoijfewoijoijoijoijoijoijoijfewceniuewruevrewnuuireurevueurnievrewfnerfcnevirivinrewvnirewnivrewiuvcrewvnuewvrrrewniuerwreiuviurewiuviurewnuvewnvrenurnunuvrevuurerejiremvreijnvcreivire nverivnreivrevnureiorfnfrvoeoiroireoireoifrefoieroifoireoifoirefoireoifoijfoirereoireoivoioirevoinvoinreoinvnoieoinreoinveoinveoinreoinvoineoinoinoineoinernoiveoinvreoiioewdioewoirvnoireoivfoirewfewoifoijewoijfoijewfoijfewoijoijoijoijoijoijoijfew"
-	    CFILESN=1
-	    if test -f /usr/share/dict/american-english; then
-		CFILESSRC[0]="/usr/share/dict/american-english"
-	    else
-		CFILESSRC[0]="/usr/share/dict/linux.words"
+	    CFILESRC=
+	    for cand in /usr/share/dict/american-english /usr/share/dict/linux.words /data/data/com.termux/files/usr/share/hunspell/en_US.dic; do
+		if test -f "$cand" ; then
+		    CFILESRC="$cand"
+		    break
+		fi
+	    done
+	    if test "$CFILESRC" = "" ; then
+		echo "Couldn't find compressible file" >&2
+		exit 1
 	    fi
 	    case x"$fs" in
 		    # FS LIMITATION: 8.3 names
 		xmsdos*)
-		    CFILES[0]="american.eng";;
+		    CFILE="american.eng";;
 		xiso9660)
-		    CFILES[0]="american_english";;
+		    CFILE="american_english";;
 		*)
-		    CFILES[0]="american-english";;
+		    CFILE="american-english";;
 	    esac
         # OS LIMITATION: Limited by NAME_MAX (usually 255) in GNU/Linux
 	    LONGNAME="qwertzuiopasdfghjklyxcvbnm1234567890qwertzuiopasdfghjklyxcvbnm1234567890oiewqfiewioqoiqoiurqruewqoiuwoieoiiuewqroreqiufieiuwrnureweriuvceoiroiewqoiricdsalkcndsakfirefoiwqeoircorejwoijfreoijojoiewjfwnfcoirenfoirefnreoifenoiwfnoi"
@@ -388,8 +419,8 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		    ;;
 		x"vfat16" | xmsdos16)
 		    BIGBLOCKCNT=$((25000 * BLKSIZE))
-		    if [ $BIGBLOCKCNT -gt $((16#ffffffff)) ]; then
-			BIGBLOCKCNT=$((16#ffffffff))
+		    if [ $BIGBLOCKCNT -gt 4294967295 ]; then
+			BIGBLOCKCNT=4294967295
 		    fi
 		    ;;
 		x"minix")
@@ -410,7 +441,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		    BIGBLOCKCNT=$((4000 * 1048576));;
 		    # FS LIMITATION: These FS have uint32 as file size field
 		x"vfat"* | xmsdos* | x"cpio_crc" | x"cpio_newc" | x"cpio_bin" | x"cpio_hpbin" | xsfs*)
-		    BIGBLOCKCNT=$((16#ffffffff));;
+		    BIGBLOCKCNT=4294967295;;
 		    # FS LIMITATION: These FS have int32 as file size field
 		    # FIXME: not so sure about AFFS
 		    # OS LIMITATION: minix2/minix3 could be formatted in a way to permit more.
@@ -543,18 +574,18 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 
 	    PDIR=""
 		# OS LIMITATION: Limited by PATH_MAX (usually 1024)
-	    for ((i=0;i<PDIRCOMPNUM;i++)); do
+	    for i in $(range 0 $((PDIRCOMPNUM-1)) 1); do
 		PDIR="$PDIR/$i";
-		if [ $((i%3)) == 0 ]; then
+		if test $((i%3)) = 0; then
 		    PDIR="$PDIR/"
 		fi
 	    done
 
 	    PDIR2=""
 		# OS LIMITATION: Limited by PATH_MAX (usually 1024)
-	    for ((i=0;i<PDIR2COMPNUM;i++)); do
+	    for i in $(range 0 $((PDIR2COMPNUM-1)) 1); do
 		PDIR2="${PDIR2}/$i";
-		if [ $((i%3)) == 0 ]; then
+		if test $((i%3)) = 0; then
 		    PDIR2="${PDIR2}/"
 		fi
 	    done
@@ -563,7 +594,9 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 
 	    unset LODEVICES
 	    GENERATED=n
-
+	    LODEVICES=
+	    MOUNTDEVICE=
+	    
 	    case x"$fs" in
 		x"tarfs" | x"cpio_"*| x"ziso9660" | x"romfs" | x"squash4_"*\
                     | x"iso9660" | xjoliet | xrockridge | xrockridge_joliet \
@@ -577,62 +610,65 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		*)
 		    mkdir -p "$MNTPOINTRW"
 		    mkdir -p "$MNTPOINTRO"
-		    for ((i=0; i < NDEVICES; i++)); do
-			dd if=/dev/zero of="${FSIMAGES[i]}" count=1 bs=1 seek=$((DISKSIZE-1)) &> /dev/null
-			LODEVICES[i]=`losetup -f`
-			losetup "${LODEVICES[i]}" "${FSIMAGES[i]}"
+		    for i in $(range 0 $((NDEVICES-1)) 1); do
+			dd if=/dev/zero of="$FSIMAGEP${i}.img" count=1 bs=1 seek=$((DISKSIZE-1)) &> /dev/null
+			LODEVICE="$(losetup -f)"
+			LODEVICES="$LODEVICES $LODEVICE"
+			losetup "$LODEVICE" "$FSIMAGEP${i}.img"
+			if test "$i" = 0; then
+			    MOUNTDEVICE="$LODEVICE"
+			fi
 		    done ;;
 	    esac
 
-	    MOUNTDEVICE="${LODEVICES[0]}"
 	    case x"$fs" in
 		x"afs")
 		    ;;
 		x"btrfs")
-		    "mkfs.btrfs" -s $SECSIZE -L "$FSLABEL" "${LODEVICES[0]}" ;;
+		    "mkfs.btrfs" -s $SECSIZE -L "$FSLABEL" "${MOUNTDEVICE}" ;;
 		x"btrfs_zlib" | x"btrfs_lzo")
-		    "mkfs.btrfs" -s $SECSIZE -L "$FSLABEL" "${LODEVICES[0]}"
+		    "mkfs.btrfs" -s $SECSIZE -L "$FSLABEL" "${MOUNTDEVICE}"
 		    MOUNTOPTS="compress=${fs/btrfs_/},"
 		    MOUNTFS="btrfs"
 		    ;;
 		x"btrfs_raid0")
-		    "mkfs.btrfs" -s $SECSIZE -d raid0 -m raid0 -L "$FSLABEL" "${LODEVICES[@]}"
+		    "mkfs.btrfs" -s $SECSIZE -d raid0 -m raid0 -L "$FSLABEL" $LODEVICES
 		    MOUNTFS="btrfs"
 		    ;;
 		x"btrfs_raid1")
-		    "mkfs.btrfs" -s $SECSIZE -d raid1 -m raid1 -L "$FSLABEL" "${LODEVICES[@]}"
+		    "mkfs.btrfs" -s $SECSIZE -d raid1 -m raid1 -L "$FSLABEL" $LODEVICES
 		    MOUNTFS="btrfs"
 		    ;;
 		x"btrfs_raid10")
-		    "mkfs.btrfs" -s $SECSIZE -d raid10 -m raid10 -L "$FSLABEL" "${LODEVICES[@]}"
+		    "mkfs.btrfs" -s $SECSIZE -d raid10 -m raid10 -L "$FSLABEL" $LODEVICES
 		    MOUNTFS="btrfs"
 		    ;;
 		x"btrfs_single")
-		    "mkfs.btrfs" -s $SECSIZE -d single -L "$FSLABEL" "${LODEVICES[@]}"
+		    "mkfs.btrfs" -s $SECSIZE -d single -L "$FSLABEL" $LODEVICES
 		    MOUNTFS="btrfs"
 		    ;;
 		x"exfat")
-		    "mkfs.$fs" -s $((BLKSIZE/512)) -n "$FSLABEL" "${LODEVICES[0]}"
+		    "mkfs.$fs" -s $((BLKSIZE/512)) -n "$FSLABEL" "${MOUNTDEVICE}"
 		    MOUNTOPTS="iocharset=utf8,"
 		    MOUNTFS="exfat-fuse";;
 		x"minix")
-		    "mkfs.minix" "${LODEVICES[0]}"
+		    "mkfs.minix" "${MOUNTDEVICE}"
 		    ;;
 	# mkfs.hfs and mkfs.hfsplus don't fill UUID.
 		x"hfsplus")
-		    "mkfs.hfsplus" -b $BLKSIZE -v "$FSLABEL" "${LODEVICES[0]}"
-		    dd if=/dev/urandom of="${LODEVICES[0]}" bs=1 seek=$((16#468)) conv=notrunc count=8 ;;
+		    "mkfs.hfsplus" -b $BLKSIZE -v "$FSLABEL" "${MOUNTDEVICE}"
+		    dd if=/dev/urandom of="${MOUNTDEVICE}" bs=1 seek=$((16#468)) conv=notrunc count=8 ;;
 		x"hfsplus_wrap")
-		    "mkfs.hfsplus" -w -b $BLKSIZE -v "$FSLABEL" "${LODEVICES[0]}"
-		    dd if=/dev/urandom of="${LODEVICES[0]}" bs=1 seek=$((16#468)) conv=notrunc count=8
+		    "mkfs.hfsplus" -w -b $BLKSIZE -v "$FSLABEL" "${MOUNTDEVICE}"
+		    dd if=/dev/urandom of="${MOUNTDEVICE}" bs=1 seek=$((16#468)) conv=notrunc count=8
 		    MOUNTFS="hfsplus";;
 		x"hfsplus_casesens")
-		    "mkfs.hfsplus" -s -b $BLKSIZE -v "$FSLABEL" "${LODEVICES[0]}"
-		    dd if=/dev/urandom of="${LODEVICES[0]}" bs=1 seek=$((16#468)) conv=notrunc count=8
+		    "mkfs.hfsplus" -s -b $BLKSIZE -v "$FSLABEL" "${MOUNTDEVICE}"
+		    dd if=/dev/urandom of="${MOUNTDEVICE}" bs=1 seek=$((16#468)) conv=notrunc count=8
 		    MOUNTFS="hfsplus";;
 		x"hfs")
-		    "mkfs.hfs" -b $BLKSIZE -v "`echo $FSLABEL |recode utf8..macroman`" -h "${LODEVICES[0]}"
-		    dd if=/dev/urandom of="${LODEVICES[0]}" bs=1 seek=$((16#474)) conv=notrunc count=8
+		    "mkfs.hfs" -b $BLKSIZE -v "`echo $FSLABEL |recode utf8..macroman`" -h "${MOUNTDEVICE}"
+		    dd if=/dev/urandom of="${MOUNTDEVICE}" bs=1 seek=$((16#474)) conv=notrunc count=8
 		    MOUNTOPTS="iocharset=utf8,codepage=macroman,"
 		    ;;
 		x"vfat"*|xmsdos*)
@@ -643,98 +679,98 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		    else
 			A=
 		    fi
-		    "mkfs.vfat" -a $A -S $SECSIZE -s $((BLKSIZE/SECSIZE)) -F "${BITS:0:2}" -n "$FSLABEL" "${FSIMAGES[0]}"
+		    "mkfs.vfat" -a $A -S $SECSIZE -s $((BLKSIZE/SECSIZE)) -F "${BITS:0:2}" -n "$FSLABEL" "${MOUNTDEVICE}"
 		    MOUNTOPTS="iocharset=utf8,codepage=437,"
 		    MOUNTFS="$(echo "$fs"|sed 's,[0-9]*a\?$,,')";;
 		x"minix2")
-		    "mkfs.minix" -v "${LODEVICES[0]}"
+		    "mkfs.minix" -v "${MOUNTDEVICE}"
 		    MOUNTFS="minix";;
 		x"minix3")
-		    "mkfs.minix" -B $BLKSIZE -3 "${LODEVICES[0]}"
+		    "mkfs.minix" -B $BLKSIZE -3 "${MOUNTDEVICE}"
 		    MOUNTFS="minix";;
 		x"ntfs"*)
-		    "mkfs.ntfs" -s "$SECSIZE" -c "$BLKSIZE" -L "$FSLABEL" -Q -q "${LODEVICES[0]}"
+		    "mkfs.ntfs" -s "$SECSIZE" -c "$BLKSIZE" -L "$FSLABEL" -Q -q "${MOUNTDEVICE}"
 		    MOUNTOPTS="iocharset=utf8,compression,"
 		    MOUNTFS="ntfs-3g";;
 		x"udf")
-		    "mkudffs" --utf8 -b $BLKSIZE --lvid="$FSLABEL" "${LODEVICES[0]}"
+		    "mkudffs" --utf8 -b $BLKSIZE --lvid="$FSLABEL" "${MOUNTDEVICE}"
 		    MOUNTOPTS="iocharset=utf8,bs=$BLKSIZE,";;
 		x"ufs2")
-		    "mkfs.ufs" -b $BLKSIZE -L "$FSLABEL" -O 2 "${LODEVICES[0]}"
+		    "mkfs.ufs" -b $BLKSIZE -L "$FSLABEL" -O 2 "${MOUNTDEVICE}"
 		    MOUNTOPTS="ufstype=ufs2,"
 		    MOUNTFS="ufs";;
 		x"ufs1")
-		    "mkfs.ufs" -b $BLKSIZE -L "$FSLABEL" -O 1 "${LODEVICES[0]}"
+		    "mkfs.ufs" -b $BLKSIZE -L "$FSLABEL" -O 1 "${MOUNTDEVICE}"
 		    MOUNTOPTS="ufstype=44bsd,"
 		    MOUNTFS="ufs";;
 		x"ufs1_sun")
-		    "mkfs.ufs" -b $BLKSIZE -L "$FSLABEL" -O 1 "${LODEVICES[0]}"
+		    "mkfs.ufs" -b $BLKSIZE -L "$FSLABEL" -O 1 "${MOUNTDEVICE}"
 		    MOUNTOPTS="ufstype=sun,"
 		    MOUNTFS="ufs";;
 		x"zfs")
-		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" "${LODEVICES[0]}"
+		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" "${MOUNTDEVICE}"
 		    sleep 1
 		    "zfs" create "$FSLABEL"/"grub fs"
 		    sleep 1;;
 		x"zfs_caseins")
-		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" "${LODEVICES[0]}"
+		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" "${MOUNTDEVICE}"
 		    sleep 1
 		    "zfs" create -o casesensitivity=insensitive "$FSLABEL"/"grub fs"
 		    sleep 1;;
 		x"zfs_lzjb" | xzfs_gzip | xzfs_zle)
-		    "zpool" create -O compression=${fs/zfs_/} -R "$MNTPOINTRW" "$FSLABEL" "${LODEVICES[0]}"
+		    "zpool" create -O compression=${fs/zfs_/} -R "$MNTPOINTRW" "$FSLABEL" "${MOUNTDEVICE}"
 		    sleep 1
 		    "zfs" create -o compression=${fs/zfs_/} "$FSLABEL"/"grub fs"
 		    sleep 1;;
 		x"zfs_raidz")
-		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" raidz1 "${LODEVICES[@]}"
+		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" raidz1 $LODEVICES
 		    sleep 1
 		    "zfs" create "$FSLABEL"/"grub fs"
 		    sleep 1;;
 		x"zfs_raidz2")
-		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" raidz2 "${LODEVICES[@]}"
+		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" raidz2 $LODEVICES
 		    sleep 1
 		    "zfs" create "$FSLABEL"/"grub fs"
 		    sleep 1;;
 		x"zfs_raidz3")
-		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" raidz3 "${LODEVICES[@]}"
+		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" raidz3 $LODEVICES
 		    sleep 1
 		    "zfs" create "$FSLABEL"/"grub fs"
 		    sleep 1;;
 		x"zfs_mirror")
-		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" mirror "${LODEVICES[@]}"
+		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" mirror $LODEVICES
 		    sleep 1
 		    "zfs" create "$FSLABEL"/"grub fs"
 		    sleep 1;;
 		x"zfs_stripe")
-		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" "${LODEVICES[@]}"
+		    "zpool" create -R "$MNTPOINTRW" "$FSLABEL" $LODEVICES
 		    sleep 1
 		    "zfs" create "$FSLABEL"/"grub fs"
 		    sleep 1;;
 		x"tarfs" | x"cpio_"* | x"iso9660" | xjoliet | xrockridge | xrockridge_joliet | x"iso9660_1999" | xjoliet_1999 | xrockridge_1999 | xrockridge_joliet_1999 | x"ziso9660" | x"romfs" | x"squash4_"*)
 		    INSTDEVICE=/dev/null;;
 		x"reiserfs")
-		    "mkfs.reiserfs" --format=3.6 -b $BLKSIZE -l "$FSLABEL" -q "${LODEVICES[0]}" ;;
+		    "mkfs.reiserfs" --format=3.6 -b $BLKSIZE -l "$FSLABEL" -q "${MOUNTDEVICE}" ;;
 		x"reiserfs_old")
-		    "mkfs.reiserfs" --format=3.5 -b $BLKSIZE -l "$FSLABEL" -q "${LODEVICES[0]}"
+		    "mkfs.reiserfs" --format=3.5 -b $BLKSIZE -l "$FSLABEL" -q "${MOUNTDEVICE}"
 		    MOUNTFS=reiserfs;;
 		x"jfs")
-		    "mkfs.jfs" -L "$FSLABEL" -q "${LODEVICES[0]}"
+		    "mkfs.jfs" -L "$FSLABEL" -q "${MOUNTDEVICE}"
 		    MOUNTOPTS="iocharset=utf8,";;
 		x"jfs_caseins")
-		    "mkfs.jfs" -O -L "$FSLABEL" -q "${LODEVICES[0]}"
+		    "mkfs.jfs" -O -L "$FSLABEL" -q "${MOUNTDEVICE}"
 		    MOUNTFS=jfs
 		    MOUNTOPTS="iocharset=utf8,";;
 		x"mdraid"*)
-		    mdadm -C --chunk=$((BLKSIZE/1024)) --force -e "${fs:6:1}.${fs:7:1}" "/dev/md/${fs}_${NDEVICES}" --level="${fs:13}" --raid-devices="$NDEVICES" "${LODEVICES[@]}"
+		    mdadm -C --chunk=$((BLKSIZE/1024)) --force -e "${fs:6:1}.${fs:7:1}" "/dev/md/${fs}_${NDEVICES}" --level="${fs:13}" --raid-devices="$NDEVICES" $LODEVICES
 		    MOUNTDEVICE="/dev/md/${fs}_${NDEVICES}"
 		    MOUNTFS=ext2
 		    "mkfs.ext2" -L "$FSLABEL" -q "${MOUNTDEVICE}" ;;
 		x"lvm"*)
-		    for ((i=0;i<NDEVICES;i++)); do
-			pvcreate "${LODEVICES[i]}"
+		    for lodev in $LODEVICES; do
+			pvcreate "$lodev"
 		    done
-		    vgcreate -s $((BLKSIZE/1024))K grub_test "${LODEVICES[@]}"
+		    vgcreate -s $((BLKSIZE/1024))K grub_test $LODEVICES
 		    if [ x$fs = xlvm ] ; then
 			lvcreate -l "$((NDEVICES*7*LVMBLKMUL))" -n testvol grub_test
 		    elif [ x$fs = xlvm_stripe ] ; then
@@ -757,22 +793,26 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		    MOUNTFS=ext2
 		    "mkfs.ext2" -L "$FSLABEL" -q "${MOUNTDEVICE}"  ;;
 		xnilfs2)
-		    "mkfs.nilfs2" -L "$FSLABEL" -b $BLKSIZE  -q "${LODEVICES[0]}" ;;
+		    "mkfs.nilfs2" -L "$FSLABEL" -b $BLKSIZE  -q "${MOUNTDEVICE}" ;;
 		xext2_old)
-		    MKE2FS_DEVICE_SECTSIZE=$SECSIZE "mkfs.ext2" -r 0 -b $BLKSIZE -L "$FSLABEL" -q "${LODEVICES[0]}"
+		    MKE2FS_DEVICE_SECTSIZE=$SECSIZE "mkfs.ext2" -r 0 -b $BLKSIZE -L "$FSLABEL" -q "${MOUNTDEVICE}"
 		    MOUNTFS=ext2
 		    ;;
 		xext4_metabg)
-		    MKE2FS_DEVICE_SECTSIZE=$SECSIZE "mkfs.ext4" -O meta_bg,^resize_inode -b $BLKSIZE -L "$FSLABEL" -q "${LODEVICES[0]}"
+		    MKE2FS_DEVICE_SECTSIZE=$SECSIZE "mkfs.ext4" -O meta_bg,^resize_inode -b $BLKSIZE -L "$FSLABEL" -q "${MOUNTDEVICE}"
 		    MOUNTFS=ext4
 		    ;;
+               xext4_encrypt)
+                   MKE2FS_DEVICE_SECTSIZE=$SECSIZE "mkfs.ext4" -O encrypt -b $BLKSIZE -L "$FSLABEL" -q "${MOUNTDEVICE}"
+                   MOUNTFS=ext4
+                   ;;
 		xext*)
-		    MKE2FS_DEVICE_SECTSIZE=$SECSIZE "mkfs.$fs" -b $BLKSIZE -L "$FSLABEL" -q "${LODEVICES[0]}" ;;
+		    MKE2FS_DEVICE_SECTSIZE=$SECSIZE "mkfs.$fs" -b $BLKSIZE -L "$FSLABEL" -q "${MOUNTDEVICE}" ;;
 		xxfs)
-		    "mkfs.xfs" -m crc=0 -b size=$BLKSIZE -s size=$SECSIZE -L "$FSLABEL" -q "${LODEVICES[0]}" ;;
+		    "mkfs.xfs" -m crc=0 -b size=$BLKSIZE -s size=$SECSIZE -L "$FSLABEL" -q "${MOUNTDEVICE}" ;;
 		xxfs_crc)
 		    MOUNTFS="xfs"
-		    "mkfs.xfs" -m crc=1 -b size=$BLKSIZE -s size=$SECSIZE -L "$FSLABEL" -q "${LODEVICES[0]}" ;;
+		    "mkfs.xfs" -m crc=1 -b size=$BLKSIZE -s size=$SECSIZE -L "$FSLABEL" -q "${MOUNTDEVICE}" ;;
 		*)
 		    echo "Add appropriate mkfs command here"
 		    exit 1
@@ -873,11 +913,13 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		*)
 		    if ! mount -t "$MOUNTFS" "${MOUNTDEVICE}" "$MNTPOINTRW" -o ${MOUNTOPTS}${SELINUXOPTS}rw  ; then
 			echo "MOUNT FAILED."
-			for ((i=0; i < NDEVICES; i++)); do
-			    while ! losetup -d "${LODEVICES[i]}"; do
+			for lodev in $LODEVICES; do
+			    while ! losetup -d "$lodev"; do
 				sleep 1
 			    done
-			    rm "${FSIMAGES[i]}"
+			done
+			for i in $(range 0 $((NDEVICES-1)) 1); do
+			    rm "$FSIMAGEP${i}.img"
 			done
 			exit 1;
 		    fi
@@ -939,11 +981,11 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    if (test x$fs = xvfat12a || test x$fs = xmsdos12a) && test x$BLKSIZE = x131072; then
 		    # With this config there isn't enough space for full copy.
 		    # Copy as much as we can
-		cp "${CFILESSRC[0]}" "$MNTPOINTRW/$OSDIR/${CFILES[0]}" &> /dev/null;
+		cp "${CFILESRC}" "$MNTPOINTRW/$OSDIR/${CFILE}" &> /dev/null;
 	    else
-		for ((i=0;i<$CFILESN;i++)); do
-		    cp "${CFILESSRC[i]}" "$MNTPOINTRW/$OSDIR/${CFILES[i]}";
-		done
+
+		cp "${CFILESRC}" "$MNTPOINTRW/$OSDIR/${CFILE}";
+
 	    fi
 
 	    if [ x$NOSYMLINK != xy ]; then
@@ -968,48 +1010,48 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		    sleep 2
 		    ;;
 		x"tarfs")
-		    (cd "$MASTER"; tar cf "${FSIMAGES[0]}" .) ;;
+		    (cd "$MASTER"; tar cf "${FSIMAGEP}0.img" .) ;;
 		x"cpio_"*)
-		    (cd "$MASTER"; find . | cpio -o -H "${fs/cpio_/}" > "${FSIMAGES[0]}" ) ;;
+		    (cd "$MASTER"; find . | cpio -o -H "$(echo ${fs} | sed 's@^cpio_@@')" > "${FSIMAGEP}0.img" ) ;;
 		x"ziso9660")
 		    FSUUID=$(date -u +%Y-%m-%d-%H-%M-%S-00);
-		    xorriso -compliance rec_mtime -set_filter_r --zisofs -- -zisofs default -as mkisofs -iso-level 3 -graft-points -R -J -joliet-long -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGES[0]}"  -- -set_filter_r --zisofs -- -zisofs default -add /="$MASTER" ;;
+		    xorriso -compliance rec_mtime -set_filter_r --zisofs -- -zisofs default -as mkisofs -iso-level 3 -graft-points -R -J -joliet-long -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGEP}0.img"  -- -set_filter_r --zisofs -- -zisofs default -add /="$MASTER" ;;
 		x"iso9660")
 		    FSUUID=$(date -u +%Y-%m-%d-%H-%M-%S-00);
-		    xorriso --rockridge off -compliance rec_mtime -as mkisofs -iso-level 3 -graft-points -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGES[0]}" /="$MASTER"  ;;
+		    xorriso --rockridge off -compliance rec_mtime -as mkisofs -iso-level 3 -graft-points -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGEP}0.img" /="$MASTER"  ;;
 		x"joliet")
 		    FSUUID=$(date -u +%Y-%m-%d-%H-%M-%S-00);
-		    xorriso --rockridge off  -compliance rec_mtime -as mkisofs -iso-level 3 -graft-points -J -joliet-long -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGES[0]}" /="$MASTER"  ;;
+		    xorriso --rockridge off  -compliance rec_mtime -as mkisofs -iso-level 3 -graft-points -J -joliet-long -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGEP}0.img" /="$MASTER"  ;;
 		x"rockridge")
 		    FSUUID=$(date -u +%Y-%m-%d-%H-%M-%S-00);
-		    xorriso --rockridge on -compliance rec_mtime -as mkisofs -iso-level 3 -graft-points -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGES[0]}" /="$MASTER"  ;;
+		    xorriso --rockridge on -compliance rec_mtime -as mkisofs -iso-level 3 -graft-points -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGEP}0.img" /="$MASTER"  ;;
 		x"rockridge_joliet")
 		    FSUUID=$(date -u +%Y-%m-%d-%H-%M-%S-00);
-		    xorriso --rockridge on -compliance rec_mtime -as mkisofs -iso-level 3 -graft-points -J -joliet-long -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGES[0]}" /="$MASTER"  ;;
+		    xorriso --rockridge on -compliance rec_mtime -as mkisofs -iso-level 3 -graft-points -J -joliet-long -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGEP}0.img" /="$MASTER"  ;;
 		x"iso9660_1999")
 		    FSUUID=$(date -u +%Y-%m-%d-%H-%M-%S-00);
-		    xorriso --rockridge off -compliance rec_mtime -as mkisofs -iso-level 4 -graft-points -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGES[0]}" /="$MASTER"  ;;
+		    xorriso --rockridge off -compliance rec_mtime -as mkisofs -iso-level 4 -graft-points -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGEP}0.img" /="$MASTER"  ;;
 		x"joliet_1999")
 		    FSUUID=$(date -u +%Y-%m-%d-%H-%M-%S-00);
-		    xorriso --rockridge off  -compliance rec_mtime -as mkisofs -iso-level 4 -graft-points -J -joliet-long -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGES[0]}" /="$MASTER"  ;;
+		    xorriso --rockridge off  -compliance rec_mtime -as mkisofs -iso-level 4 -graft-points -J -joliet-long -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGEP}0.img" /="$MASTER"  ;;
 		x"rockridge_1999")
 		    FSUUID=$(date -u +%Y-%m-%d-%H-%M-%S-00);
-		    xorriso --rockridge on -compliance rec_mtime -as mkisofs -iso-level 4 -graft-points -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGES[0]}" /="$MASTER"  ;;
+		    xorriso --rockridge on -compliance rec_mtime -as mkisofs -iso-level 4 -graft-points -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGEP}0.img" /="$MASTER"  ;;
 		x"rockridge_joliet_1999")
 		    FSUUID=$(date -u +%Y-%m-%d-%H-%M-%S-00);
-		    xorriso --rockridge on -compliance rec_mtime -as mkisofs -iso-level 4 -graft-points -J -joliet-long -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGES[0]}" /="$MASTER"  ;;
+		    xorriso --rockridge on -compliance rec_mtime -as mkisofs -iso-level 4 -graft-points -J -joliet-long -V "$FSLABEL" --modification-date=$(echo ${FSUUID} | sed 's/-//g;') -o "${FSIMAGEP}0.img" /="$MASTER"  ;;
 		x"romfs")
-		    genromfs -V "$FSLABEL" -f "${FSIMAGES[0]}" -d "$MASTER" ;;
+		    genromfs -V "$FSLABEL" -f "${FSIMAGEP}0.img" -d "$MASTER" ;;
 		xsquash4_*)
-		    echo mksquashfs "$MASTER" "${FSIMAGES[0]}" -always-use-fragments -comp "${fs/squash4_/}" -b $BLKSIZE
-		    mksquashfs "$MASTER" "${FSIMAGES[0]}" -always-use-fragments -comp "${fs/squash4_/}" -b $BLKSIZE ;;
+		    echo mksquashfs "$MASTER" "${FSIMAGEP}0.img" -always-use-fragments -comp "${fs/squash4_/}" -b $BLKSIZE
+		    mksquashfs "$MASTER" "${FSIMAGEP}0.img" -always-use-fragments -comp "${fs/squash4_/}" -b $BLKSIZE ;;
 		x"bfs")
 		    sleep 1
 		    fusermount -u "$MNTPOINTRW"
 		    ;;
 		xlvm*)
 		    sleep 1
-		    for ((try=0;try < 20; try++)); do
+		    for try in $(range 0 20 1); do
 			if umount "$MNTPOINTRW" ; then
 			    break;
 			fi
@@ -1021,7 +1063,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		    ;;
 		xmdraid*)
 		    sleep 1
-		    for ((try=0;try < 20; try++)); do
+		    for try in $(range 0 20 1); do
 			if umount "$MNTPOINTRW" ; then
 			    break;
 			fi
@@ -1033,7 +1075,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		    ;;
 		*)
 		    sleep 1
-		    for ((try=0;try < 20; try++)); do
+		    for try in $(range 0 20 1); do
 			if umount "$MNTPOINTRW" ; then
 			    break;
 			fi
@@ -1066,7 +1108,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		    sleep 1
 		    mount -t "$MOUNTFS" "${MOUNTDEVICE}" "$MNTPOINTRO" -o ${MOUNTOPTS}${SELINUXOPTS}ro ;;
 		xmdraid*)
-		    mdadm --assemble /dev/md/"${fs}_$NDEVICES" "${LODEVICES[@]}"
+		    mdadm --assemble /dev/md/"${fs}_$NDEVICES" $LODEVICES
 		    sleep 1
 		    mount -t "$MOUNTFS" "${MOUNTDEVICE}" "$MNTPOINTRO" -o ${MOUNTOPTS}${SELINUXOPTS}ro ;;
 		*)
@@ -1085,7 +1127,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    else
 		echo LIST FAIL
 		echo "$LSROUT"
-		TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -l "$MNTPOINTRO"
+		TZ=UTC ls -l "$MNTPOINTRO"
 		exit 1
 	    fi
 
@@ -1094,7 +1136,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    else
 		echo NLIST FAIL
 		echo "$LSROUT"
-		TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -lA "$MNTPOINTRO"
+		TZ=UTC ls -lA "$MNTPOINTRO"
 		exit 1
 	    fi
 
@@ -1103,7 +1145,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    else
 		echo ILIST FAIL
 		echo "$LSROUT"
-		TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -l "$MNTPOINTRO"
+		TZ=UTC ls -l "$MNTPOINTRO"
 		exit 1
 	    fi
 
@@ -1112,7 +1154,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    else
 		echo LONG LIST FAIL
 		echo "$LSROUT"
-		TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -l "$MNTPOINTRO"
+		TZ=UTC ls -l "$MNTPOINTRO"
 		exit 1
 	    fi
 
@@ -1123,7 +1165,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		else
 		    echo TIME FAIL
 		    echo "$LSROUT"
-		    TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -l "$MNTPOINTRO"
+		    TZ=UTC ls -l "$MNTPOINTRO"
 		    exit 1
 		fi
 
@@ -1133,7 +1175,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		else
 		    echo LONG TIME FAIL
 		    echo "$LSROUT"
-		    TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -l "$MNTPOINTRO"
+		    TZ=UTC ls -l "$MNTPOINTRO"
 		    exit 1
 		fi
 	    fi
@@ -1149,7 +1191,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    else
 		echo DOT IN ROOTDIR FAIL
 		echo "$LSROUT"
-		TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -l "$MNTPOINTRO"
+		TZ=UTC ls -l "$MNTPOINTRO"
 		exit 1
 	    fi
 
@@ -1163,7 +1205,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		    else
 			echo DOTDOT IN ROOTDIR FAIL
 			echo "$LSROUT"
-			TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -l "$MNTPOINTRO"
+			TZ=UTC ls -l "$MNTPOINTRO"
 			exit 1
 		    fi
 		    ;;
@@ -1180,7 +1222,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    else
 		echo SLIST FAIL
 		echo "$LSROUT"
-		TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -l "$MNTPOINTRO/sdir"
+		TZ=UTC ls -l "$MNTPOINTRO/sdir"
 		exit 1
 	    fi
 
@@ -1195,7 +1237,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    else
 		echo PLIST FAIL
 		echo "$LSROUT"
-		TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -l "$MNTPOINTRO/$PDIR"
+		TZ=UTC ls -l "$MNTPOINTRO/$PDIR"
 		exit 1
 	    fi
 
@@ -1210,7 +1252,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    else
 		echo DOT IN SUBDIR FAIL
 		echo "$LSROUT"
-		TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -l "$MNTPOINTRO/$OSDIR/sdir"
+		TZ=UTC ls -l "$MNTPOINTRO/$OSDIR/sdir"
 		exit 1
 	    fi
 
@@ -1225,7 +1267,7 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    else
 		echo DOTDOT IN SUBDIR FAIL
 		echo "$LSROUT"
-		TZ=UTC ls --time-style=+%Y%m%d%H%M%S.%N -l "$MNTPOINTRO/$OSDIR/ssdir"
+		TZ=UTC ls -l "$MNTPOINTRO/$OSDIR/ssdir"
 		exit 1
 	    fi
 
@@ -1245,8 +1287,8 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 	    case x"$fs" in
 		x"iso9660" | x"ziso9660" | xrockridge | xjoliet | xrockridge_joliet | x"iso9660_1999" | xrockridge_1999 | xjoliet_1999 | xrockridge_joliet_1999) ;;
 		x"zfs"*)
-		    for ((i=0;i<NDEVICES;i++)); do
-			FSUUID=$(printf "%016x\n" $(blkid -o export "${LODEVICES[i]}" |grep -F UUID=|sed s,UUID=,,g))
+		    for lodev in $LODEVICES; do
+			FSUUID=$(printf "%016x\n" $(blkid -o export "$lodev" |grep -F UUID=|sed s,UUID=,,g))
 			if [ "$FSUUID" != 0000000000000000 ]; then
 			    break;
 			fi
@@ -1264,8 +1306,8 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 			echo UUID FAIL
 			echo "$LSOUT"
 			echo "$GRUBUUID"
-			for ((i=0;i<NDEVICES;i++)); do
-			    blkid "${LODEVICES[i]}"
+			for lodev in $LODEVICES; do
+			    blkid "$lodev"
 			done
 			exit 1
 		    fi
@@ -1290,37 +1332,37 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 			echo UUID FAIL
 			echo "$FSUUID"
 			echo "$LSOUT"
-			blkid "${LODEVICES[0]}"
+			blkid "${MOUNTDEVICE}"
 			exit 1
 		    fi
 		    ;;
 	    esac
 
-	    case x$fs in
-		xiso9660 | xziso9660 | xrockridge | xjoliet | xrockridge_joliet | xiso9660_1999 | xrockridge_1999 | xjoliet_1999 | xrockridge_joliet_1999)
-		    FSTIME="$(date -d "$(echo ${FSUUID} | awk -F - '{ print $1"-"$2"-"$3" "$4":"$5":"$6 ;}')" '+%Y-%m-%d %H:%M:%S')";;
-		xlvm*|xmdraid*)
-		    # With some abstractions like mdraid flushing to disk
-		    # may be delayed for a long time.
-		    FSTIME="$UMOUNT_TIME";;
-		*)
-		    FSTIME="$(TZ=UTC ls --time-style="+%Y-%m-%d_%H:%M:%S" -l -d "${FSIMAGES[0]}"|awk '{print $6; }'|sed 's,_, ,g')";;
-	    esac
-	    # With some abstractions like mdraid computing of UMOUNT_TIME
-	    # is not precise. Account for small difference here.
-	    FSTIMEM1="$(date -d "$FSTIME UTC -1 second" -u "+%Y-%m-%d %H:%M:%S")"
-	    FSTIMEM2="$(date -d "$FSTIME UTC -2 second" -u "+%Y-%m-%d %H:%M:%S")"
-	    FSTIMEM3="$(date -d "$FSTIME UTC -3 second" -u "+%Y-%m-%d %H:%M:%S")"
+	    if [ x$NOFSTIME != xy ]; then
+		case x$fs in
+		    xiso9660 | xziso9660 | xrockridge | xjoliet | xrockridge_joliet | xiso9660_1999 | xrockridge_1999 | xjoliet_1999 | xrockridge_joliet_1999)
+			FSTIME="$(date -d "$(echo ${FSUUID} | awk -F - '{ print $1"-"$2"-"$3" "$4":"$5":"$6 ;}')" '+%Y-%m-%d %H:%M:%S')";;
+		    xlvm*|xmdraid*)
+			# With some abstractions like mdraid flushing to disk
+			# may be delayed for a long time.
+			FSTIME="$UMOUNT_TIME";;
+		    *)
+			FSTIME="$(TZ=UTC ls --time-style="+%Y-%m-%d_%H:%M:%S" -l -d "${FSIMAGEP}0.img"|awk '{print $6; }'|sed 's,_, ,g')";;
+		esac
+		# With some abstractions like mdraid computing of UMOUNT_TIME
+		# is not precise. Account for small difference here.
+		FSTIMEM1="$(date -d "$FSTIME UTC -1 second" -u "+%Y-%m-%d %H:%M:%S")"
+		FSTIMEM2="$(date -d "$FSTIME UTC -2 second" -u "+%Y-%m-%d %H:%M:%S")"
+		FSTIMEM3="$(date -d "$FSTIME UTC -3 second" -u "+%Y-%m-%d %H:%M:%S")"
 
-	    if [ x$NOFSTIME = xy ]; then
-		:
-	    elif echo "$LSOUT" | grep -F 'Last modification time '"$FSTIME" > /dev/null || echo "$LSOUT" | grep -F 'Last modification time '"$FSTIMEM1" > /dev/null || echo "$LSOUT" | grep -F 'Last modification time '"$FSTIMEM2" || echo "$LSOUT" | grep -F 'Last modification time '"$FSTIMEM3" > /dev/null; then
-		:
-	    else
-		echo FSTIME FAIL
-		echo "$FSTIME"
-		echo "$LSOUT"
-		exit 1
+		if echo "$LSOUT" | grep -F 'Last modification time '"$FSTIME" > /dev/null || echo "$LSOUT" | grep -F 'Last modification time '"$FSTIMEM1" > /dev/null || echo "$LSOUT" | grep -F 'Last modification time '"$FSTIMEM2" || echo "$LSOUT" | grep -F 'Last modification time '"$FSTIMEM3" > /dev/null; then
+		    :
+		else
+		    echo FSTIME FAIL
+		    echo "$FSTIME"
+		    echo "$LSOUT"
+		    exit 1
+		fi
 	    fi
 
 	    if [ x$NOHARDLINK != xy ]; then
@@ -1410,11 +1452,9 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		exit 1
 	    fi
 	    ok=true
-	    for ((i=0;i<$CFILESN;i++)); do
-		if ! run_grubfstest cmp "$GRUBDIR/${CFILES[i]}" "$MNTPOINTRO/$OSDIR/${CFILES[i]}"  ; then
-		    ok=false;
-		fi
-	    done
+	    if ! run_grubfstest cmp "$GRUBDIR/${CFILE}" "$MNTPOINTRO/$OSDIR/${CFILE}"  ; then
+		ok=false;
+	    fi
 	    if  test x$ok = xtrue; then
 		:
 	    else
@@ -1503,15 +1543,17 @@ for ((LOGSECSIZE=MINLOGSECSIZE;LOGSECSIZE<=MAXLOGSECSIZE;LOGSECSIZE=LOGSECSIZE +
 		    sleep 1
 		    ;;
 	    esac
-	    for ((i=0; i < NDEVICES; i++)); do
-		case x"$fs" in
-		    x"tarfs" | x"cpio_"* | x"iso9660" | xrockridge | xjoliet | xrockridge_joliet | x"ziso9660" | x"romfs" | x"squash4_"* | x"iso9660_1999" | xrockridge_1999 | xjoliet_1999 | xrockridge_joliet_1999) ;;
-		    *)
-			while ! losetup -d "${LODEVICES[i]}"; do
+	    case x"$fs" in
+		x"tarfs" | x"cpio_"* | x"iso9660" | xrockridge | xjoliet | xrockridge_joliet | x"ziso9660" | x"romfs" | x"squash4_"* | x"iso9660_1999" | xrockridge_1999 | xjoliet_1999 | xrockridge_joliet_1999) ;;
+		*)
+		    for lodev in $LODEVICES; do
+			while ! losetup -d "$lodev"; do
 			    sleep 1
-			done;;
-		esac
-		rm "${FSIMAGES[i]}"
+			done
+		    done;;
+	    esac
+	    for i in $(range 0 $((NDEVICES-1)) 1); do
+		rm "$FSIMAGEP${i}.img"
 	    done
 	    if [ x"$fs" = x"zfs" ]; then
 		rmdir "$MNTPOINTRW"/"grub fs"  || true
diff --git a/tests/util/grub-shell-tester.in b/tests/util/grub-shell-tester.in
index 5adce0a47fe3208e14bbbf4820685d67b43ef9bb..8a87109b15240de9d61f2ac02becfcb5300582f1 100644
--- a/tests/util/grub-shell-tester.in
+++ b/tests/util/grub-shell-tester.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 set -e
 
 # Compares GRUB script output with BASH output.
diff --git a/tests/util/grub-shell.in b/tests/util/grub-shell.in
index 814f36c6bd2438b7f9c59f5f4a9777e95b9e38db..d690d6734efb82109f7635c4688b6fc7417a5751 100644
--- a/tests/util/grub-shell.in
+++ b/tests/util/grub-shell.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 set -e
 
 # Run GRUB script in a Qemu instance
diff --git a/tests/xfs_test.in b/tests/xfs_test.in
index 3807e2e5c77e244f8b2f0d43ec28b86b3f2f9e9b..03a3513595dc719cd72b4d9b7198f22b338cb588 100644
--- a/tests/xfs_test.in
+++ b/tests/xfs_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/tests/xzcompress_test.in b/tests/xzcompress_test.in
index b2bd999ec071c24205533e50cf51f46ec59a2218..03bfb5e951dd8dfb7ccb15fb6a31dd4aea639df9 100644
--- a/tests/xzcompress_test.in
+++ b/tests/xzcompress_test.in
@@ -1,4 +1,4 @@
-#! /bin/sh
+#! @BUILD_SHEBANG@
 # Copyright (C) 2013  Free Software Foundation, Inc.
 #
 # GRUB is free software: you can redistribute it and/or modify
diff --git a/tests/zfs_test.in b/tests/zfs_test.in
index 047120e47a0e042f0540d6762666edf4cb0b37fb..eee62c10d704ec42b090eba5ac16b4966ff760ad 100644
--- a/tests/zfs_test.in
+++ b/tests/zfs_test.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!@BUILD_SHEBANG@
 
 set -e
 
diff --git a/util/grub.d/20_linux_xen.in b/util/grub.d/20_linux_xen.in
index c48af948d6ecdf672aa341f713912ba15de8f27d..c002fc9f9465c08945b5ab7326033b538c0184e6 100644
--- a/util/grub.d/20_linux_xen.in
+++ b/util/grub.d/20_linux_xen.in
@@ -122,16 +122,16 @@ linux_entry ()
         else
             xen_rm_opts="no-real-mode edd=off"
         fi
-	multiboot	${rel_xen_dirname}/${xen_basename} placeholder ${xen_args} \${xen_rm_opts}
+	${xen_loader}	${rel_xen_dirname}/${xen_basename} placeholder ${xen_args} \${xen_rm_opts}
 	echo	'$(echo "$lmessage" | grub_quote)'
-	module	${rel_dirname}/${basename} placeholder root=${linux_root_device_thisversion} ro ${args}
+	${module_loader}	${rel_dirname}/${basename} placeholder root=${linux_root_device_thisversion} ro ${args}
 EOF
   if test -n "${initrd}" ; then
     # TRANSLATORS: ramdisk isn't identifier. Should be translated.
     message="$(gettext_printf "Loading initial ramdisk ...")"
     sed "s/^/$submenu_indentation/" << EOF
 	echo	'$(echo "$message" | grub_quote)'
-	module	--nounzip   ${rel_dirname}/${initrd}
+	${module_loader}	--nounzip   ${rel_dirname}/${initrd}
 EOF
   fi
   sed "s/^/$submenu_indentation/" << EOF
@@ -206,6 +206,14 @@ while [ "x${xen_list}" != "x" ] ; do
     if [ "x$is_top_level" != xtrue ]; then
 	echo "	submenu '$(gettext_printf "Xen hypervisor, version %s" "${xen_version}" | grub_quote)' \$menuentry_id_option 'xen-hypervisor-$xen_version-$boot_device_id' {"
     fi
+    $grub_file --is-arm64-efi $current_xen
+    if [ $? -ne 0 ]; then
+	xen_loader="multiboot"
+	module_loader="module"
+    else
+	xen_loader="xen_hypervisor"
+	module_loader="xen_module"
+    fi
     while [ "x$list" != "x" ] ; do
 	linux=`version_find_latest $list`
 	gettext_printf "Found linux image: %s\n" "$linux" >&2
